---
title: 'Manage user sessions'
description: 'Store tokens safely with proper cookie security, validate on every request, and refresh with rotation to keep sessions secure'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: 'Manage user sessions'
prev: false
next:
  label: 'End the session and invalidate tokens'
  link: '/fsa/guides/logout/'
---

import {
  Steps,
  Tabs,
  TabItem,
  Aside,
  Card,
  Badge,
} from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import { AuthResultTabsSection } from '@components/templates';
import CheckItem from '@/components/ui/CheckItem.astro';
import IconTdesignSequence from '~icons/tdesign/sequence'

User sessions determine how long users stay signed in to your application. After users successfully authenticate, you receive session tokens that manage their access. These tokens control session duration, multi-device access, and cross-product authentication within your company's ecosystem.

This guide shows you how to store these tokens securely with proper cookie attributes, validate them on every request, and refresh them with rotation to prevent token replay attacks.


<details>
<summary><IconTdesignSequence style="display: inline; width: 1rem; height: 1rem; vertical-align: middle; margin-right: 0.5rem;" /> Review the session management sequence</summary>

![User session management flow diagram showing how access tokens and refresh tokens work together](@/assets/docs/fsa/manage-session/1.png)

</details>


<Steps>
1. ## Store session tokens securely

    After successful identity verification using any of the auth methods (passwordless, social, enterprise SSO), your application receives session tokens â€” access and refresh tokens.

   <AuthResultTabsSection />

   Store each token based on its security requirements. For SPAs and mobile apps, consider storing access tokens in memory and sending via `Authorization: Bearer` headers to minimize CSRF exposure. For traditional web apps, use the cookie-based approach below:
   - **Access Token**: Store in a secure, HttpOnly cookie with proper `Path` scoping (e.g., `/api`) to prevent XSS attacks. This token has a short lifespan and provides access to protected resources.
   - **Refresh Token**: Store in your backend database or secure server-side storage with rotation on each use. This long-lived token generates new access tokens and should be bound to the client session.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="Express.js" showLineNumbers=true  collapse={1-4} "accessToken" "refreshToken"
     import cookieParser from 'cookie-parser';
     // Enable parsing of cookies from request headers
     app.use(cookieParser());

     // Extract authentication data from the successful authentication response
     const { accessToken, expiresIn, refreshToken, user } = authResult;

     // Persist refresh token in database for token rotation on each refresh
     // Store with session binding (user-agent, IP) to detect token theft
     await db.saveRefreshToken(user.id, refreshToken, {
       userAgent: req.headers['user-agent'],
       ip: req.ip
     });

     // Create secure HttpOnly cookie containing the access token
     // Path scoping limits where browser sends this cookie (least privilege)
     res.cookie('accessToken', accessToken, {
       maxAge: (expiresIn - 60) * 1000, // Subtract 60s buffer for clock skew (milliseconds)
       httpOnly: true, // Prevents JavaScript access to mitigate XSS attacks
       secure: process.env.NODE_ENV === 'production', // HTTPS-only in production
       sameSite: 'strict', // Prevents CSRF attacks; use 'lax' if top-level navigation needed
       path: '/api' // Restrict cookie to API routes only
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="Flask" collapse={1-4} "access_token" "refresh_token"
     from flask import Flask, make_response, request
     import os
     app = Flask(__name__)

     # Extract authentication data from the successful authentication response
     access_token = auth_result.access_token
     expires_in = auth_result.expires_in
     refresh_token = auth_result.refresh_token
     user = auth_result.user

     # Persist refresh token in database for token rotation on each refresh
     # Store with session binding (user-agent, IP) to detect token theft
     db.save_refresh_token(user.id, refresh_token, {
       'user_agent': request.headers.get('User-Agent'),
       'ip': request.remote_addr
     })

     # Create secure HttpOnly cookie containing the access token
     # Path scoping limits where browser sends this cookie (least privilege)
     response = make_response()
     response.set_cookie(
       'accessToken',
       access_token,
       max_age=expires_in - 60,  # Subtract 60s buffer for clock skew (seconds in Flask)
       httponly=True,             # Prevents JavaScript access to mitigate XSS attacks
       secure=os.environ.get('FLASK_ENV') == 'production',  # HTTPS-only in production
       samesite='Strict',         # Prevents CSRF attacks; use 'Lax' if top-level navigation needed
       path='/api'                # Restrict cookie to API routes only
     )
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="Gin" collapse={1-7} "accessToken" "refreshToken"
     import (
       "net/http"
       "os"
       "time"
       "github.com/gin-gonic/gin"
     )

     // Extract authentication data from the successful authentication response
     accessToken := authResult.AccessToken
     expiresIn := authResult.ExpiresIn
     refreshToken := authResult.RefreshToken
     user := authResult.User

     // Persist refresh token in database for token rotation on each refresh
     // Store with session binding (user-agent, IP) to detect token theft
     db.SaveRefreshToken(user.ID, refreshToken, map[string]string{
       "userAgent": c.Request.UserAgent(),
       "ip":        c.ClientIP(),
     })

     // Create secure HttpOnly cookie containing the access token
     // Path scoping limits where browser sends this cookie (least privilege)
     c.SetSameSite(http.SameSiteStrictMode) // Prevents CSRF; use Lax if top-level navigation needed
     c.SetCookie(
       "accessToken",
       accessToken,
       expiresIn-60, // Subtract 60s buffer for clock skew (seconds in Gin)
       "/api",       // Restrict cookie to API routes only
       "",
       os.Getenv("GIN_MODE") == "release", // HTTPS-only in production
       true, // Prevents JavaScript access to mitigate XSS attacks
     )
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Spring" collapse={1-6} "accessToken" "refreshToken"
     import javax.servlet.http.Cookie;
     import javax.servlet.http.HttpServletResponse;
     import org.springframework.core.env.Environment;
     @Autowired
     private Environment env;

     // Extract authentication data from the successful authentication response
     String accessToken = authResult.getAccessToken();
     int expiresIn = authResult.getExpiresIn();
     String refreshToken = authResult.getRefreshToken();
     User user = authResult.getUser();

     // Persist refresh token in database for token rotation on each refresh
     // Store with session binding (user-agent, IP) to detect token theft
     Map<String, String> binding = new HashMap<>();
     binding.put("userAgent", request.getHeader("User-Agent"));
     binding.put("ip", request.getRemoteAddr());
     db.saveRefreshToken(user.getId(), refreshToken, binding);

     // Create secure HttpOnly cookie containing the access token
     // Path scoping limits where browser sends this cookie (least privilege)
     Cookie cookie = new Cookie("accessToken", accessToken);
     cookie.setMaxAge(expiresIn - 60); // Subtract 60s buffer for clock skew (seconds in Spring)
     cookie.setHttpOnly(true); // Prevents JavaScript access to mitigate XSS attacks
     cookie.setSecure("production".equals(env.getActiveProfiles()[0])); // HTTPS-only in production
     cookie.setPath("/api"); // Restrict cookie to API routes only
     response.addCookie(cookie);
     response.setHeader("Set-Cookie",
       response.getHeader("Set-Cookie") + "; SameSite=Strict"); // Prevents CSRF attacks
     ```
     </TabItem>
   </Tabs>

   Configure session policy from your Dashboard > Authentication > Session Policy

   <Aside type="tip">
   When using cookie-based authentication, implement CSRF protection for state-changing operations (POST, PUT, PATCH, DELETE). Use synchronizer tokens or signed double-submit cookies alongside `SameSite` attributes for defense in depth.
   </Aside>


3. ## Check the access token before handling requests

   Validate every request for a valid access token in your application. Create middleware to protect your application routes. This middleware validates the access token on every request to secured endpoints. For APIs, consider reading from `Authorization: Bearer` headers instead of cookies to minimize CSRF risk.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" "validateAccessToken"
     async function verifyToken(req, res, next) {
       // Extract access token from request cookies
       const { accessToken } = req.cookies;

       // Return 401 error if no token is present
       if (!accessToken) {
         return res.status(401).json({ error: 'Authentication required' });
       }

       try {
         // Verify token validity using Scalekit's validation method
         const isValid = await scalekit.validateAccessToken(accessToken);

         if (!isValid) {
           // If token validation fails (expired or invalid), attempt token refresh
           return handleTokenRefresh(req, res, next);
         }

         // Token is valid, proceed to the next middleware or route handler
         next();
       } catch (error) {
         // If validation throws an exception, attempt token refresh as fallback
         return handleTokenRefresh(req, res, next);
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" wrap collapse={1-2} "validate_access_token"
     from flask import request, jsonify
     from functools import wraps
     def verify_token(f):
         @wraps(f)
         def decorated_function(*args, **kwargs):
             # Extract access token from request cookies
             access_token = request.cookies.get('accessToken')

             # Return 401 error if no token is present
             if not access_token:
                 return jsonify({'error': 'Authentication required'}), 401

             try:
                 # Verify token validity using Scalekit's validation method
                 is_valid = scalekit.validate_access_token(access_token)

                 if not is_valid:
                     # If token validation fails (expired or invalid), attempt token refresh
                     return handle_token_refresh(f, *args, **kwargs)

                 # Token is valid, proceed to the protected view function
                 return f(*args, **kwargs)

             except Exception:
                 # If validation throws an exception, attempt token refresh as fallback
                 return handle_token_refresh(f, *args, **kwargs)

         return decorated_function
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" collapse={1-4}
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func VerifyToken() gin.HandlerFunc {
       return func(c *gin.Context) {
         // Extract access token from the request cookies
         accessToken, err := c.Cookie("accessToken")

         // Return 401 error if no token is present or cookie error occurs
         if err != nil || accessToken == "" {
           c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
           c.Abort()
           return
         }

         // Verify token validity using Scalekit's validation method
         isValid, err := scalekit.ValidateAccessToken(accessToken)

         // If token validation fails (expired or invalid), attempt token refresh
         if err != nil || !isValid {
           handleTokenRefresh(c)
           return
         }

         // Token is valid, proceed to the next handler in the chain
         c.Next()
       }
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" collapse={1-5,22-28, 45-64}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import org.springframework.web.servlet.HandlerInterceptor;

     /**
      * Intercepts HTTP requests to verify authentication tokens.
      * Implements Spring's HandlerInterceptor to check access tokens
      * before request processing.
      */
     @Component
     public class AuthInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(
         HttpServletRequest request,
         HttpServletResponse response,
         Object handler
       ) throws Exception {
         // Extract access token from cookies
         String accessToken = getCookieValue(request, "accessToken");

         // Return 401 if no token is present
         if (accessToken == null) {
           response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
           response.getWriter().write("{\"error\": \"Authentication required\"}");
           return false;
         }

         try {
           // Verify token validity using Scalekit's validation method
           boolean isValid = scalekit.validateAccessToken(accessToken);

           if (!isValid) {
             // If token is expired or invalid, attempt to refresh it
             return handleTokenRefresh(request, response);
           }

           // Token is valid, allow request to proceed
           return true;
         } catch (Exception e) {
           // If validation throws an exception, attempt token refresh as fallback
           return handleTokenRefresh(request, response);
         }
       }

       /**
        * Helper method to extract a specific cookie value from the request.
        *
        * @param request The HTTP request containing cookies
        * @param cookieName The name of the cookie to retrieve
        * @return The cookie value or null if not found
        */
       private String getCookieValue(HttpServletRequest request, String cookieName) {
         Cookie[] cookies = request.getCookies();
         if (cookies != null) {
           for (Cookie cookie : cookies) {
             if (cookieName.equals(cookie.getName())) {
               return cookie.getValue();
             }
           }
         }
         return null;
       }
      }
      ```
      </TabItem>
   </Tabs>

4. ## Maintain sessions by refreshing access tokens

   When access tokens expire, you can use the refresh token to obtain new ones without requiring users to sign in again. Implement refresh token rotation by replacing the old refresh token with a new one on each refresh and invalidating the old token server-side. This limits the window for token replay attacks and enables detection of token theft. Optionally, verify that session binding attributes (user-agent, IP) haven't changed significantly to detect suspicious activity.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" {3,10, 17, 25-30}
     async function handleTokenRefresh(req, res, next) {
       // Extract user ID from session or user object to identify the session
       const userId = req.session?.userId || req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }

       // Fetch the refresh token and binding metadata from persistent storage
       const tokenData = await db.getRefreshToken(userId);
       if (!tokenData || !tokenData.token) {
         return res.status(401).json({ error: 'Session expired' });
       }

       // Optional: Verify session binding to detect token theft
       // Allow some tolerance for legitimate changes (e.g., IP changes on mobile)
       if (tokenData.userAgent && tokenData.userAgent !== req.headers['user-agent']) {
         await db.revokeRefreshToken(userId); // Potential token theft detected
         return res.status(401).json({ error: 'Session security violation. Please sign in again.' });
       }

       try {
         // Exchange refresh token for new credentials with token rotation
         const authResult = await scalekit.refreshAccessToken(tokenData.token);
         const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;

         // Rotate: Invalidate old token and persist new refresh token with binding
         await db.revokeRefreshToken(userId, tokenData.token); // Invalidate old token
         await db.saveRefreshToken(userId, newRefreshToken, {
           userAgent: req.headers['user-agent'],
           ip: req.ip
         });

         // Set access token in HttpOnly cookie with security configurations and Path scoping
         res.cookie('accessToken', accessToken, {
           maxAge: (expiresIn - 60) * 1000, // Subtract 60s buffer for clock skew (milliseconds)
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict',
           path: '/api' // Restrict cookie to API routes only
         });

         // Update request context with user data and continue to next middleware
         req.user = authResult.user;
         next();
       } catch (error) {
         // Refresh failed - invalidate token family to prevent replay attacks
         await db.revokeAllRefreshTokens(userId);
         res.clearCookie('accessToken', { path: '/api' }); // Match Path when clearing
         return res.status(401).json({ error: 'Session expired. Please sign in again.' });
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" {4, 10,16, 27-34}
     from flask import request, jsonify, make_response
     import os
     def handle_token_refresh(f, *args, **kwargs):
         # Extract user ID from session or user object to identify the session
         user_id = request.session.get('userId') if hasattr(request, 'session') else getattr(request, 'user', {}).get('id')
         if not user_id:
             return jsonify({'error': 'Authentication required'}), 401

         # Fetch the refresh token and binding metadata from persistent storage
         token_data = db.get_refresh_token(user_id)
         if not token_data or not token_data.get('token'):
             return jsonify({'error': 'Session expired'}), 401

         # Optional: Verify session binding to detect token theft
         if token_data.get('user_agent') and token_data['user_agent'] != request.headers.get('User-Agent'):
             db.revoke_refresh_token(user_id)  # Potential token theft detected
             return jsonify({'error': 'Session security violation. Please sign in again.'}), 401

         try:
             # Exchange refresh token for new credentials with token rotation
             auth_result = scalekit.refresh_access_token(token_data['token'])
             access_token = auth_result.access_token
             expires_in = auth_result.expires_in
             new_refresh_token = auth_result.refresh_token

             # Rotate: Invalidate old token and persist new refresh token with binding
             db.revoke_refresh_token(user_id, token_data['token'])  # Invalidate old token
             db.save_refresh_token(user_id, new_refresh_token, {
                 'user_agent': request.headers.get('User-Agent'),
                 'ip': request.remote_addr
             })

             # Set access token in HttpOnly cookie with security configurations and Path scoping
             response = make_response(f(*args, **kwargs))
             response.set_cookie(
                 'accessToken',
                 access_token,
                 max_age=expires_in - 60,  # Subtract 60s buffer for clock skew (seconds in Flask)
                 httponly=True,
                 secure=os.environ.get('FLASK_ENV') == 'production',
                 samesite='Strict',
                 path='/api'  # Restrict cookie to API routes only
             )

             # Update request context with user data and continue to next middleware
             request.user = auth_result.user
             return response
         except Exception:
             # Refresh failed - invalidate token family to prevent replay attacks
             db.revoke_all_refresh_tokens(user_id)
             response = make_response(jsonify({'error': 'Session expired. Please sign in again.'}), 401)
             response.set_cookie('accessToken', '', expires=0, path='/api')  # Match Path when clearing
             return response
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" {14, 33-41}
     import (
       "net/http"
       "os"
       "github.com/gin-gonic/gin"
     )
     func handleTokenRefresh(c *gin.Context) {
       // Identify the user session from context to maintain authentication state
       userID := getUserIDFromContext(c)
       if userID == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
         c.Abort()
         return
       }
       // Fetch the refresh token and binding metadata from persistent storage
       tokenData, err := db.GetRefreshToken(userID)
       if err != nil || tokenData.Token == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired"})
         c.Abort()
         return
       }
       // Optional: Verify session binding to detect token theft
       if tokenData.UserAgent != "" && tokenData.UserAgent != c.Request.UserAgent() {
         db.RevokeRefreshToken(userID) // Potential token theft detected
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session security violation. Please sign in again."})
         c.Abort()
         return
       }
       // Exchange refresh token for new credentials with token rotation
       authResult, err := scalekit.RefreshAccessToken(tokenData.Token)
       if err != nil {
         // Refresh failed - invalidate token family to prevent replay attacks
         db.RevokeAllRefreshTokens(userID)
         c.SetCookie("accessToken", "", -1, "/api", "", false, true) // Match Path when clearing
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired. Please sign in again."})
         c.Abort()
         return
       }
       // Rotate: Invalidate old token and persist new refresh token with binding
       db.RevokeRefreshToken(userID, tokenData.Token) // Invalidate old token
       db.SaveRefreshToken(userID, authResult.RefreshToken, map[string]string{
         "userAgent": c.Request.UserAgent(),
         "ip":        c.ClientIP(),
       })
       // Set access token in HttpOnly cookie with security configurations and Path scoping
       c.SetSameSite(http.SameSiteStrictMode)
       c.SetCookie(
         "accessToken",
         authResult.AccessToken,
         authResult.ExpiresIn-60, // Subtract 60s buffer for clock skew (seconds in Gin)
         "/api",                  // Restrict cookie to API routes only
         "",
         os.Getenv("GIN_MODE") == "release", // Secure flag in production
         true, // HttpOnly flag
       )
       // Update request context with user data and continue to next middleware
       c.Set("user", authResult.User)
       c.Next()
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" collapse={1-3} { 7, 15, 24}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import java.util.Map;
     import java.util.HashMap;
     private boolean handleTokenRefresh(HttpServletRequest request, HttpServletResponse response)
         throws Exception {
       // Identify the user session from context to maintain authentication state
       String userId = getUserIdFromRequest(request);
       if (userId == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Authentication required\"}");
         return false;
       }

       // Fetch the refresh token and binding metadata from persistent storage
       TokenData tokenData = db.getRefreshToken(userId);
       if (tokenData == null || tokenData.getToken() == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired\"}");
         return false;
       }

       // Optional: Verify session binding to detect token theft
       if (tokenData.getUserAgent() != null &&
           !tokenData.getUserAgent().equals(request.getHeader("User-Agent"))) {
         db.revokeRefreshToken(userId); // Potential token theft detected
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session security violation. Please sign in again.\"}");
         return false;
       }

       try {
         // Exchange refresh token for new credentials with token rotation
         AuthResult authResult = scalekit.refreshToken(tokenData.getToken());
         String accessToken = authResult.getAccessToken();
         int expiresIn = authResult.getExpiresIn();
         String newRefreshToken = authResult.getRefreshToken();

         // Rotate: Invalidate old token and persist new refresh token with binding
         db.revokeRefreshToken(userId, tokenData.getToken()); // Invalidate old token
         Map<String, String> binding = new HashMap<>();
         binding.put("userAgent", request.getHeader("User-Agent"));
         binding.put("ip", request.getRemoteAddr());
         db.saveRefreshToken(userId, newRefreshToken, binding);

         // Set access token in HttpOnly cookie with security configurations and Path scoping
         Cookie cookie = new Cookie("accessToken", accessToken);
         cookie.setMaxAge(expiresIn - 60); // Subtract 60s buffer for clock skew (seconds in Spring)
         cookie.setHttpOnly(true);
         cookie.setSecure("production".equals(env.getActiveProfiles()[0]));
         cookie.setPath("/api"); // Restrict cookie to API routes only
         response.addCookie(cookie);
         response.setHeader("Set-Cookie",
           response.getHeader("Set-Cookie") + "; SameSite=Strict"); // Prevents CSRF attacks

         // Update request context with user data and continue to next middleware
         request.setAttribute("user", authResult.getUser());
         return true;
       } catch (Exception e) {
         // Refresh failed - invalidate token family to prevent replay attacks
         db.revokeAllRefreshTokens(userId);
         Cookie expiredCookie = new Cookie("accessToken", "");
         expiredCookie.setMaxAge(0);
         expiredCookie.setPath("/api"); // Match Path when clearing
         response.addCookie(expiredCookie);
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired. Please sign in again.\"}");
         return false;
       }
      }
      ```
      </TabItem>
   </Tabs>

   Apply this middleware to protected routes:

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="app.js" "verifyToken"
     // Protect routes that require authentication
     app.get('/dashboard', verifyToken, (req, res) => {
       res.json({ message: `Welcome ${req.user.name}!` });
     });
     app.get('/api/profile', verifyToken, (req, res) => {
       res.json({ user: req.user });
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="app.py" "verify_token"
     # Protect routes that require authentication
     @app.route('/dashboard')
     @verify_token
     def dashboard():
         return jsonify({'message': f'Welcome {request.user.name}!'})
     @app.route('/api/profile')
     @verify_token
     def profile():
         return jsonify({'user': request.user})
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="main.go" "VerifyToken"
     // Protect routes that require authentication
     r.GET("/dashboard", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{
         "message": fmt.Sprintf("Welcome %s!", user.Name),
       })
     })
     r.GET("/api/profile", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{"user": user})
     })
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Controller.java" "VerifyToken"
     // Protect routes that require authentication
     @GetMapping("/dashboard")
     public ResponseEntity<Map<String, String>> dashboard(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, String> response = new HashMap<>();
       response.put("message", "Welcome " + user.getName() + "!");
       return ResponseEntity.ok(response);
     }
     @GetMapping("/api/profile")
     public ResponseEntity<Map<String, Object>> profile(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, Object> response = new HashMap<>();
       response.put("user", user);
       return ResponseEntity.ok(response);
     }
     ```
     </TabItem>
   </Tabs>

6. ## Manage session security and duration

      Manage user session behavior directly from your Scalekit dashboard without modifying application code. Configure session durations and authentication frequency to balance security and user experience for your application.

      ![](@/assets/docs/manage-session/session-policies-dashboard.png)

       In your Scalekit dashboard, the **Session settings** page lets you set these options:

      - **Absolute session timeout**: This is the maximum time a user can stay signed in, no matter what. After this time, they must log in again. For example, if you set it to 30 minutes, users will be logged out after 30 minutes, even if they are still using your app.

      - **Idle session timeout**: This is the time your app waits before logging out a user who is not active. If you turn this on, the session will end if the user does nothing for the set time. For example, if you set it to 10 minutes, and the user does not click or type for 10 minutes, they will be logged out.

      - **Access token lifetime**: This is how long an access token is valid. When it expires, your app needs to get a new token (using the refresh token) so the user can keep using the app without logging in again. For example, if you set it to 5 minutes, your app will need to refresh the token every 5 minutes.

      Shorter timeouts provide better security, while longer timeouts reduce authentication interruptions.

   <Aside type="note">
   **Logout security**: When implementing logout, ensure you clear cookies with the same attributes used when setting them (especially `Path` and `Domain`). Revoke the refresh token server-side and invalidate any server sessions. For enhanced security, consider revoking all refresh tokens for the user to force logout across all devices.
   </Aside>
</Steps>