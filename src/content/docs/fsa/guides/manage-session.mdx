---
title: 'Manage user sessions'
description: 'Store tokens safely, validate on every request, and refresh quietly so sessions stay seamless and secure'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: 'Manage user sessions'
prev: false
next:
  label: 'End the session and invalidate tokens'
  link: '/fsa/guides/logout/'
---

import {
  Steps,
  Tabs,
  TabItem,
  Aside,
  Card,
  Badge,
} from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import { AuthResultTabsSection } from '@components/templates';
import CheckItem from '@/components/ui/CheckItem.astro';
import IconTdesignSequence from '~icons/tdesign/sequence'

User sessions determine how long users stay signed in to your application. After users successfully authenticate, you receive session tokens that manage their access. These tokens control session duration, multi-device access, and cross-product authentication within your company's ecosystem.

This guide shows you how to store these tokens securely and refresh them before they expire.


<details>
<summary><IconTdesignSequence style="display: inline; width: 1rem; height: 1rem; vertical-align: middle; margin-right: 0.5rem;" /> Review the session management sequence</summary>

![User session management flow diagram showing how access tokens and refresh tokens work together](@/assets/docs/fsa/manage-session/1.png)

</details>


<Steps>
1. ## Store session tokens securely

    After successful identity verification using any of the auth methods (passwordless, social, enterprise SSO), your application receives session tokens â€” access and refresh tokens.

   <AuthResultTabsSection />

   Store each token based on its security requirements:
   - **Access Token**: Store in a secure, HTTP-only cookie to prevent XSS attacks. This token has a short lifespan and provides access to protected resources.
   - **Refresh Token**: Store in your backend database or secure server-side storage. This long-lived token generates new access tokens.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="Express.js" showLineNumbers=true  collapse={1-4} "accessToken" "refreshToken"
     import cookieParser from 'cookie-parser';
     // Enable parsing of cookies from request headers
     app.use(cookieParser());

     // Extract authentication data from the successful authentication response
     const { accessToken, expiresIn, refreshToken, user } = authResult;

     // Persist refresh token in database for later token renewal
     // This allows issuing new access tokens without requiring re-authentication
     await db.saveRefreshToken(user.id, refreshToken);

     // Create secure HTTP-only cookie containing the access token
     // The cookie expires shortly before the token itself to prevent edge cases
     res.cookie('accessToken', accessToken, {
       maxAge: (expiresIn - 60) * 1000, // Subtract 60s buffer for clock skew
       httpOnly: true, // Prevents JavaScript access to mitigate XSS attacks
       secure: process.env.NODE_ENV === 'production', // HTTPS-only in production
       sameSite: 'strict' // Prevents CSRF attacks
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="Flask" collapse={1-4} "access_token" "refresh_token"
     from flask import Flask, make_response
     import os
     app = Flask(__name__)

     # Extract authentication data from the successful authentication response
     access_token = auth_result.access_token
     expires_in = auth_result.expires_in
     refresh_token = auth_result.refresh_token
     user = auth_result.user

     # Persist refresh token in database for later token renewal
     # This allows issuing new access tokens without requiring re-authentication
     db.save_refresh_token(user.id, refresh_token)

     # Create secure HTTP-only cookie containing the access token
     response = make_response()
     response.set_cookie(
       'accessToken',
       access_token,
       max_age=(expires_in - 60) * 1000,  # Subtract 60s buffer for clock skew
       httponly=True,                      # Prevents JavaScript access to mitigate XSS attacks
       secure=os.environ.get('FLASK_ENV') == 'production',  # HTTPS-only in production
       samesite='Strict'                   # Prevents CSRF attacks
     )
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="Gin" collapse={1-7} "accessToken" "refreshToken"
     import (
       "net/http"
       "os"
       "time"
       "github.com/gin-gonic/gin"
     )

     // Extract authentication data from the successful authentication response
     accessToken := authResult.AccessToken
     expiresIn := authResult.ExpiresIn
     refreshToken := authResult.RefreshToken
     user := authResult.User

     // Persist refresh token in database for later token renewal
     // This allows issuing new access tokens without requiring re-authentication
     db.SaveRefreshToken(user.ID, refreshToken)

     // Create secure HTTP-only cookie containing the access token
     c.SetCookie(
       "accessToken",
       accessToken,
       (expiresIn-60)*1000, // Subtract 60s buffer for clock skew
       "/",
       "",
       os.Getenv("GIN_MODE") == "release", // HTTPS-only in production
       true, // Prevents JavaScript access to mitigate XSS attacks
     )
     // Prevents CSRF attacks
     c.SetSameSite(http.SameSiteStrictMode)
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Spring" collapse={1-6} "accessToken" "refreshToken"
     import javax.servlet.http.Cookie;
     import javax.servlet.http.HttpServletResponse;
     import org.springframework.core.env.Environment;
     @Autowired
     private Environment env;

     // Extract authentication data from the successful authentication response
     String accessToken = authResult.getAccessToken();
     int expiresIn = authResult.getExpiresIn();
     String refreshToken = authResult.getRefreshToken();
     User user = authResult.getUser();

     // Persist refresh token in database for later token renewal
     // This allows issuing new access tokens without requiring re-authentication
     db.saveRefreshToken(user.getId(), refreshToken);

     // Create secure HTTP-only cookie containing the access token
     Cookie cookie = new Cookie("accessToken", accessToken);
     cookie.setMaxAge((expiresIn - 60) * 1000); // Subtract 60s buffer for clock skew
     cookie.setHttpOnly(true); // Prevents JavaScript access to mitigate XSS attacks
     cookie.setSecure("production".equals(env.getActiveProfiles()[0])); // HTTPS-only in production
     cookie.setPath("/");
     response.addCookie(cookie);
     ```
     </TabItem>
   </Tabs>

   Configure session settings from your [Scalekit dashboard's Session Configuration](/fsa/reference/user-management-settings) to control session lifetimes and security policies.


3. ## Check the access token before handling requests

   Validate every request for a valid access token in your application. Create middleware to protect your application routes. This middleware validates the access token on every request to secured endpoints.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" "validateAccessToken"
     async function verifyToken(req, res, next) {
       // Extract access token from request cookies
       const { accessToken } = req.cookies;

       // Return 401 error if no token is present
       if (!accessToken) {
         return res.status(401).json({ error: 'Authentication required' });
       }

       try {
         // Verify token validity using Scalekit's validation method
         const isValid = await scalekit.validateAccessToken(accessToken);

         if (!isValid) {
           // If token validation fails (expired or invalid), attempt token refresh
           return handleTokenRefresh(req, res, next);
         }

         // Token is valid, proceed to the next middleware or route handler
         next();
       } catch (error) {
         // If validation throws an exception, attempt token refresh as fallback
         return handleTokenRefresh(req, res, next);
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" wrap collapse={1-2} "validate_access_token"
     from flask import request, jsonify
     from functools import wraps
     def verify_token(f):
         @wraps(f)
         def decorated_function(*args, **kwargs):
             # Extract access token from request cookies
             access_token = request.cookies.get('accessToken')

             # Return 401 error if no token is present
             if not access_token:
                 return jsonify({'error': 'Authentication required'}), 401

             try:
                 # Verify token validity using Scalekit's validation method
                 is_valid = scalekit.validate_access_token(access_token)

                 if not is_valid:
                     # If token validation fails (expired or invalid), attempt token refresh
                     return handle_token_refresh(f, *args, **kwargs)

                 # Token is valid, proceed to the protected view function
                 return f(*args, **kwargs)

             except Exception:
                 # If validation throws an exception, attempt token refresh as fallback
                 return handle_token_refresh(f, *args, **kwargs)

         return decorated_function
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" collapse={1-4}
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func VerifyToken() gin.HandlerFunc {
       return func(c *gin.Context) {
         // Extract access token from the request cookies
         accessToken, err := c.Cookie("accessToken")

         // Return 401 error if no token is present or cookie error occurs
         if err != nil || accessToken == "" {
           c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
           c.Abort()
           return
         }

         // Verify token validity using Scalekit's validation method
         isValid, err := scalekit.ValidateAccessToken(accessToken)

         // If token validation fails (expired or invalid), attempt token refresh
         if err != nil || !isValid {
           handleTokenRefresh(c)
           return
         }

         // Token is valid, proceed to the next handler in the chain
         c.Next()
       }
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" collapse={1-5,22-28, 45-64}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import org.springframework.web.servlet.HandlerInterceptor;

     /**
      * Intercepts HTTP requests to verify authentication tokens.
      * Implements Spring's HandlerInterceptor to check access tokens
      * before request processing.
      */
     @Component
     public class AuthInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(
         HttpServletRequest request,
         HttpServletResponse response,
         Object handler
       ) throws Exception {
         // Extract access token from cookies
         String accessToken = getCookieValue(request, "accessToken");

         // Return 401 if no token is present
         if (accessToken == null) {
           response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
           response.getWriter().write("{\"error\": \"Authentication required\"}");
           return false;
         }

         try {
           // Verify token validity using Scalekit's validation method
           boolean isValid = scalekit.validateAccessToken(accessToken);

           if (!isValid) {
             // If token is expired or invalid, attempt to refresh it
             return handleTokenRefresh(request, response);
           }

           // Token is valid, allow request to proceed
           return true;
         } catch (Exception e) {
           // If validation throws an exception, attempt token refresh as fallback
           return handleTokenRefresh(request, response);
         }
       }

       /**
        * Helper method to extract a specific cookie value from the request.
        *
        * @param request The HTTP request containing cookies
        * @param cookieName The name of the cookie to retrieve
        * @return The cookie value or null if not found
        */
       private String getCookieValue(HttpServletRequest request, String cookieName) {
         Cookie[] cookies = request.getCookies();
         if (cookies != null) {
           for (Cookie cookie : cookies) {
             if (cookieName.equals(cookie.getName())) {
               return cookie.getValue();
             }
           }
         }
         return null;
       }
      }
      ```
      </TabItem>
   </Tabs>

4. ## Maintain sessions by refreshing access tokens

   When access tokens expire, you can use the refresh token to obtain new ones without requiring users to sign in again. Store refresh tokens securely in a database, HTTP-only cookies, or another secure storage mechanism. This approach maintains seamless user sessions while ensuring security through the token refresh flow.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" {3,10, 17, 25-30}
     async function handleTokenRefresh(req, res, next) {
       // Extract user ID from session or user object to identify the session
       const userId = req.session?.userId || req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }

       // Fetch the refresh token from persistent storage
       // This token will be used to request new access credentials
       const storedRefreshToken = await db.getRefreshToken(userId);
       if (!storedRefreshToken) {
         return res.status(401).json({ error: 'Session expired' });
       }

       try {
         // Exchange refresh token for new credentials from Scalekit
         const authResult = await scalekit.refreshAccessToken(storedRefreshToken);
         const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;

         // Persist the new refresh token for future token refreshes
         await db.saveRefreshToken(userId, newRefreshToken);

         // Set access token in HTTP-only cookie with security configurations
         // Subtract 60 seconds to account for network latency and clock skew
         res.cookie('accessToken', accessToken, {
           maxAge: (expiresIn - 60) * 1000,
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict'
         });

         // Update request context with user data and continue to next middleware
         req.user = authResult.user;
         next();
       } catch (error) {
         // Authentication chain broken - user session cannot be recovered
         // Clear any existing credentials and require re-authentication
         res.clearCookie('accessToken');
         return res.status(401).json({ error: 'Session expired. Please sign in again.' });
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" {4, 10,16, 27-34}
     from flask import request, jsonify, make_response
     def handle_token_refresh(f, *args, **kwargs):
         # Extract user ID from session or user object to identify the session
         user_id = request.session.get('userId') if hasattr(request, 'session') else getattr(request, 'user', {}).get('id')
         if not user_id:
             return jsonify({'error': 'Authentication required'}), 401

         # Fetch the refresh token from persistent storage
         # This token will be used to request new access credentials
         stored_refresh_token = db.get_refresh_token(user_id)
         if not stored_refresh_token:
             return jsonify({'error': 'Session expired'}), 401

         try:
             # Exchange refresh token for new credentials from Scalekit
             auth_result = scalekit.refresh_access_token(stored_refresh_token)
             access_token = auth_result.access_token
             expires_in = auth_result.expires_in
             new_refresh_token = auth_result.refresh_token

             # Persist the new refresh token for future token refreshes
             db.save_refresh_token(user_id, new_refresh_token)

             # Set access token in HTTP-only cookie with security configurations
             # Subtract 60 seconds to account for network latency and clock skew
             response = make_response(f(*args, **kwargs))
             response.set_cookie(
                 'accessToken',
                 access_token,
                 max_age=(expires_in - 60) * 1000,
                 httponly=True,
                 secure=os.environ.get('FLASK_ENV') == 'production',
                 samesite='Strict'
             )

             # Update request context with user data and continue to next middleware
             request.user = auth_result.user
             return response
         except Exception:
             # Authentication chain broken - user session cannot be recovered
             # Clear any existing credentials and require re-authentication
             response = make_response(jsonify({'error': 'Session expired. Please sign in again.'}), 401)
             response.set_cookie('accessToken', '', expires=0)
             return response
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" {14, 33-41}
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func handleTokenRefresh(c *gin.Context) {
       // Identify the user session from context to maintain authentication state
       userID := getUserIDFromContext(c)
       if userID == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
         c.Abort()
         return
       }
       // Fetch the refresh token from persistent storage for token rotation
       storedRefreshToken, err := db.GetRefreshToken(userID)
       if err != nil || storedRefreshToken == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired"})
         c.Abort()
         return
       }
       // Exchange refresh token for new credentials with Scalekit
       authResult, err := scalekit.RefreshAccessToken(storedRefreshToken)
       if err != nil {
         // Authentication chain broken - clear credentials and require re-authentication
         c.SetCookie("accessToken", "", -1, "/", "", false, true)
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired. Please sign in again."})
         c.Abort()
         return
       }
       // Persist the new refresh token for future token refreshes
       db.SaveRefreshToken(userID, authResult.RefreshToken)
       // Set access token in HTTP-only cookie with security configurations
       // Subtract 60 seconds to account for network latency and clock skew
       c.SetCookie(
         "accessToken",
         authResult.AccessToken,
         (authResult.ExpiresIn-60)*1000,
         "/",
         "",
         os.Getenv("GIN_MODE") == "release", // Secure flag in production
         true, // HTTP-only flag
       )
       // Update request context with user data and continue to next middleware
       c.Set("user", authResult.User)
       c.Next()
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" collapse={1-3} { 7, 15, 24}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     private boolean handleTokenRefresh(HttpServletRequest request, HttpServletResponse response)
         throws Exception {
       // Identify the user session from context to maintain authentication state
       String userId = getUserIdFromRequest(request);
       if (userId == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Authentication required\"}");
         return false;
       }

       // Fetch the refresh token from persistent storage for token rotation
       String storedRefreshToken = db.getRefreshToken(userId);
       if (storedRefreshToken == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired\"}");
         return false;
       }

       try {
         // Exchange refresh token for new credentials with Scalekit
         AuthResult authResult = scalekit.refreshToken(storedRefreshToken);
         String accessToken = authResult.getAccessToken();
         int expiresIn = authResult.getExpiresIn();
         String newRefreshToken = authResult.getRefreshToken();

         // Persist the new refresh token for future token refreshes
         db.saveRefreshToken(userId, newRefreshToken);

         // Set access token in HTTP-only cookie with security configurations
         Cookie cookie = new Cookie("accessToken", accessToken);
         // Subtract 60 seconds to account for network latency and clock skew
         cookie.setMaxAge((expiresIn - 60) * 1000);
         cookie.setHttpOnly(true);
         cookie.setSecure("production".equals(env.getActiveProfiles()[0]));
         cookie.setPath("/");
         response.addCookie(cookie);

         // Update request context with user data and continue to next middleware
         request.setAttribute("user", authResult.getUser());
         return true;
       } catch (Exception e) {
         // Authentication chain broken - clear credentials and require re-authentication
         Cookie expiredCookie = new Cookie("accessToken", "");
         expiredCookie.setMaxAge(0);
         response.addCookie(expiredCookie);
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired. Please sign in again.\"}");
         return false;
       }
      }
      ```
      </TabItem>
   </Tabs>

   Apply this middleware to protected routes:

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="app.js" "verifyToken"
     // Protect routes that require authentication
     app.get('/dashboard', verifyToken, (req, res) => {
       res.json({ message: `Welcome ${req.user.name}!` });
     });
     app.get('/api/profile', verifyToken, (req, res) => {
       res.json({ user: req.user });
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="app.py" "verify_token"
     # Protect routes that require authentication
     @app.route('/dashboard')
     @verify_token
     def dashboard():
         return jsonify({'message': f'Welcome {request.user.name}!'})
     @app.route('/api/profile')
     @verify_token
     def profile():
         return jsonify({'user': request.user})
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="main.go" "VerifyToken"
     // Protect routes that require authentication
     r.GET("/dashboard", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{
         "message": fmt.Sprintf("Welcome %s!", user.Name),
       })
     })
     r.GET("/api/profile", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{"user": user})
     })
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Controller.java" "VerifyToken"
     // Protect routes that require authentication
     @GetMapping("/dashboard")
     public ResponseEntity<Map<String, String>> dashboard(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, String> response = new HashMap<>();
       response.put("message", "Welcome " + user.getName() + "!");
       return ResponseEntity.ok(response);
     }
     @GetMapping("/api/profile")
     public ResponseEntity<Map<String, Object>> profile(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, Object> response = new HashMap<>();
       response.put("user", user);
       return ResponseEntity.ok(response);
     }
     ```
     </TabItem>
   </Tabs>

6. ## Manage session security and duration

      Manage user session behavior directly from your Scalekit dashboard without modifying application code. Configure session durations and authentication frequency to balance security and user experience for your application.

      ![](@/assets/docs/manage-session/session-policies-dashboard.png)

       In your Scalekit dashboard, the **Session settings** page lets you set these options:

      - **Absolute session timeout**: This is the maximum time a user can stay signed in, no matter what. After this time, they must log in again. For example, if you set it to 30 minutes, users will be logged out after 30 minutes, even if they are still using your app.

      - **Idle session timeout**: This is the time your app waits before logging out a user who is not active. If you turn this on, the session will end if the user does nothing for the set time. For example, if you set it to 10 minutes, and the user does not click or type for 10 minutes, they will be logged out.

      - **Access token lifetime**: This is how long an access token is valid. When it expires, your app needs to get a new token (using the refresh token) so the user can keep using the app without logging in again. For example, if you set it to 5 minutes, your app will need to refresh the token every 5 minutes.

      Shorter timeouts provide better security, while longer timeouts reduce authentication interruptions.
</Steps>


<Aside type="tip" title="Organization-level session settings">
Enable organization administrators to control session settings for their workspace. [Contact our support team](/support/contact-us/) to activate this feature for your account.
</Aside>


