---
title: 'Manage user sessions'
description: 'Store tokens safely with proper cookie security, validate on every request, and refresh with rotation to keep sessions secure'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: 'Manage user sessions'
prev: false
next:
  label: 'End the session and invalidate tokens'
  link: '/fsa/guides/logout/'
---

import {
  Steps,
  Tabs,
  TabItem,
  Aside,
  Card,
  Badge,
} from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import { AuthResultTabsSection } from '@components/templates';
import CheckItem from '@/components/ui/CheckItem.astro';
import IconTdesignSequence from '~icons/tdesign/sequence'

User sessions determine how long users stay signed in to your application. After users successfully authenticate, you receive session tokens that manage their access. These tokens control session duration, multi-device access, and cross-product authentication within your company's ecosystem.

This guide shows you how to store these tokens securely with proper cookie attributes, validate them on every request, and refresh them with rotation to prevent token replay attacks.


<details>
<summary><IconTdesignSequence style="display: inline; width: 1rem; height: 1rem; vertical-align: middle; margin-right: 0.5rem;" /> Review the session management sequence</summary>

![User session management flow diagram showing how access tokens and refresh tokens work together](@/assets/docs/fsa/manage-session/1.png)

</details>


<Steps>
1. ## Store session tokens securely

    After successful identity verification using any of the auth methods (passwordless, social, enterprise SSO), your application receives session tokens(access and refresh tokens) towards the [end of the login](/authenticate/fsa/complete-login/).

   <AuthResultTabsSection />

   Store each token based on its security requirements. For SPAs and mobile apps, consider storing access tokens in memory and sending via `Authorization: Bearer` headers to minimize CSRF exposure. For traditional web apps, use the cookie-based approach below:
   - **Access Token**: Store in a secure, HttpOnly cookie with proper `Path` scoping (e.g., `/api`) to prevent XSS attacks. This token has a short lifespan and provides access to protected resources.
   - **Refresh Token**: Store in a separate HttpOnly, Secure cookie with `Path=/auth/refresh` scoping. This limits the refresh token to only be sent to your refresh endpoint, reducing exposure. Rotate the token on each use to detect theft.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="Express.js" showLineNumbers=true  collapse={1-4} "accessToken" "refreshToken"
     import cookieParser from 'cookie-parser';
     // Enable parsing of cookies from request headers
     app.use(cookieParser());

     // Extract authentication data from the successful authentication response
     const { accessToken, expiresIn, refreshToken, user } = authResult;

     // Store access token in HttpOnly cookie with Path scoping to API routes
     // Path scoping limits where browser sends this cookie (least privilege)
     res.cookie('accessToken', accessToken, {
       maxAge: (expiresIn - 60) * 1000, // Subtract 60s buffer for clock skew (milliseconds)
       httpOnly: true, // Prevents JavaScript access to mitigate XSS attacks
       secure: process.env.NODE_ENV === 'production', // HTTPS-only in production
       sameSite: 'strict', // Prevents CSRF attacks; use 'lax' if top-level navigation needed
       path: '/api' // Restrict cookie to API routes only
     });

     // Store refresh token in separate HttpOnly cookie with Path scoped to refresh endpoint
     // This ensures refresh token is only sent to the refresh endpoint, minimizing exposure
     res.cookie('refreshToken', refreshToken, {
       httpOnly: true, // Prevents JavaScript access to mitigate XSS attacks
       secure: process.env.NODE_ENV === 'production', // HTTPS-only in production
       sameSite: 'strict', // Prevents CSRF attacks
       path: '/auth/refresh' // Only sent to refresh endpoint (least privilege)
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="Flask" collapse={1-4} "access_token" "refresh_token"
     from flask import Flask, make_response, request
     import os
     app = Flask(__name__)

     # Extract authentication data from the successful authentication response
     access_token = auth_result.access_token
     expires_in = auth_result.expires_in
     refresh_token = auth_result.refresh_token
     user = auth_result.user

     response = make_response()

     # Store access token in HttpOnly cookie with Path scoping to API routes
     # Path scoping limits where browser sends this cookie (least privilege)
     response.set_cookie(
       'accessToken',
       access_token,
       max_age=expires_in - 60,  # Subtract 60s buffer for clock skew (seconds in Flask)
       httponly=True,             # Prevents JavaScript access to mitigate XSS attacks
       secure=os.environ.get('FLASK_ENV') == 'production',  # HTTPS-only in production
       samesite='Strict',         # Prevents CSRF attacks; use 'Lax' if top-level navigation needed
       path='/api'                # Restrict cookie to API routes only
     )

     # Store refresh token in separate HttpOnly cookie with Path scoped to refresh endpoint
     # This ensures refresh token is only sent to the refresh endpoint, minimizing exposure
     response.set_cookie(
       'refreshToken',
       refresh_token,
       httponly=True,             # Prevents JavaScript access to mitigate XSS attacks
       secure=os.environ.get('FLASK_ENV') == 'production',  # HTTPS-only in production
       samesite='Strict',         # Prevents CSRF attacks
       path='/auth/refresh'       # Only sent to refresh endpoint (least privilege)
     )
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="Gin" collapse={1-7} "accessToken" "refreshToken"
     import (
       "net/http"
       "os"
       "time"
       "github.com/gin-gonic/gin"
     )

     // Extract authentication data from the successful authentication response
     accessToken := authResult.AccessToken
     expiresIn := authResult.ExpiresIn
     refreshToken := authResult.RefreshToken
     user := authResult.User

     // Set SameSite mode for CSRF protection
     c.SetSameSite(http.SameSiteStrictMode) // Prevents CSRF; use Lax if top-level navigation needed

     // Store access token in HttpOnly cookie with Path scoping to API routes
     // Path scoping limits where browser sends this cookie (least privilege)
     c.SetCookie(
       "accessToken",
       accessToken,
       expiresIn-60, // Subtract 60s buffer for clock skew (seconds in Gin)
       "/api",       // Restrict cookie to API routes only
       "",
       os.Getenv("GIN_MODE") == "release", // HTTPS-only in production
       true, // Prevents JavaScript access to mitigate XSS attacks
     )

     // Store refresh token in separate HttpOnly cookie with Path scoped to refresh endpoint
     // This ensures refresh token is only sent to the refresh endpoint, minimizing exposure
     c.SetCookie(
       "refreshToken",
       refreshToken,
       0,            // No expiry for refresh token cookie (session lifetime controlled server-side)
       "/auth/refresh", // Only sent to refresh endpoint (least privilege)
       "",
       os.Getenv("GIN_MODE") == "release", // HTTPS-only in production
       true, // Prevents JavaScript access to mitigate XSS attacks
     )
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Spring" collapse={1-6} "accessToken" "refreshToken"
     import javax.servlet.http.Cookie;
     import javax.servlet.http.HttpServletResponse;
     import org.springframework.core.env.Environment;
     @Autowired
     private Environment env;

     // Extract authentication data from the successful authentication response
     String accessToken = authResult.getAccessToken();
     int expiresIn = authResult.getExpiresIn();
     String refreshToken = authResult.getRefreshToken();
     User user = authResult.getUser();

     // Store access token in HttpOnly cookie with Path scoping to API routes
     // Path scoping limits where browser sends this cookie (least privilege)
     Cookie accessTokenCookie = new Cookie("accessToken", accessToken);
     accessTokenCookie.setMaxAge(expiresIn - 60); // Subtract 60s buffer for clock skew (seconds in Spring)
     accessTokenCookie.setHttpOnly(true); // Prevents JavaScript access to mitigate XSS attacks
     accessTokenCookie.setSecure("production".equals(env.getActiveProfiles()[0])); // HTTPS-only in production
     accessTokenCookie.setPath("/api"); // Restrict cookie to API routes only
     response.addCookie(accessTokenCookie);
     response.setHeader("Set-Cookie",
       response.getHeader("Set-Cookie") + "; SameSite=Strict"); // Prevents CSRF attacks

     // Store refresh token in separate HttpOnly cookie with Path scoped to refresh endpoint
     // This ensures refresh token is only sent to the refresh endpoint, minimizing exposure
     Cookie refreshTokenCookie = new Cookie("refreshToken", refreshToken);
     refreshTokenCookie.setHttpOnly(true); // Prevents JavaScript access to mitigate XSS attacks
     refreshTokenCookie.setSecure("production".equals(env.getActiveProfiles()[0])); // HTTPS-only in production
     refreshTokenCookie.setPath("/auth/refresh"); // Only sent to refresh endpoint (least privilege)
     response.addCookie(refreshTokenCookie);
     ```
     </TabItem>
   </Tabs>

   Configure session policy from your Dashboard > Authentication > Session Policy

   <Aside type="tip">
   When using cookie-based authentication, implement CSRF protection for state-changing operations (POST, PUT, PATCH, DELETE). Use synchronizer tokens or signed double-submit cookies alongside `SameSite` attributes for defense in depth.
   </Aside>


3. ## Check the access token before handling requests

   Validate every request for a valid access token in your application. Create middleware to protect your application routes. This middleware validates the access token on every request to secured endpoints. For APIs, consider reading from `Authorization: Bearer` headers instead of cookies to minimize CSRF risk.


   Here's an example middle ware method validating access toekn and refreshing the token if it's expired for every request.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" "validateAccessToken"
     async function verifyToken(req, res, next) {
       // Extract access token from request cookies
       const { accessToken } = req.cookies;

       // Return 401 error if no token is present
       if (!accessToken) {
         return res.status(401).json({ error: 'Authentication required' });
       }

       try {
         // Verify token validity using Scalekit's validation method
         const isValid = await scalekit.validateAccessToken(accessToken);

         if (!isValid) {
           // If token validation fails (expired or invalid), attempt token refresh
           return handleTokenRefresh(req, res, next);
         }

         // Token is valid, proceed to the next middleware or route handler
         next();
       } catch (error) {
         // If validation throws an exception, attempt token refresh as fallback
         return handleTokenRefresh(req, res, next);
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" wrap collapse={1-2} "validate_access_token"
     from flask import request, jsonify
     from functools import wraps
     def verify_token(f):
         @wraps(f)
         def decorated_function(*args, **kwargs):
             # Extract access token from request cookies
             access_token = request.cookies.get('accessToken')

             # Return 401 error if no token is present
             if not access_token:
                 return jsonify({'error': 'Authentication required'}), 401

             try:
                 # Verify token validity using Scalekit's validation method
                 is_valid = scalekit.validate_access_token(access_token)

                 if not is_valid:
                     # If token validation fails (expired or invalid), attempt token refresh
                     return handle_token_refresh(f, *args, **kwargs)

                 # Token is valid, proceed to the protected view function
                 return f(*args, **kwargs)

             except Exception:
                 # If validation throws an exception, attempt token refresh as fallback
                 return handle_token_refresh(f, *args, **kwargs)

         return decorated_function
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" collapse={1-4}
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func VerifyToken() gin.HandlerFunc {
       return func(c *gin.Context) {
         // Extract access token from the request cookies
         accessToken, err := c.Cookie("accessToken")

         // Return 401 error if no token is present or cookie error occurs
         if err != nil || accessToken == "" {
           c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
           c.Abort()
           return
         }

         // Verify token validity using Scalekit's validation method
         isValid, err := scalekit.ValidateAccessToken(accessToken)

         // If token validation fails (expired or invalid), attempt token refresh
         if err != nil || !isValid {
           handleTokenRefresh(c)
           return
         }

         // Token is valid, proceed to the next handler in the chain
         c.Next()
       }
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" collapse={1-5,22-28, 45-64}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import org.springframework.web.servlet.HandlerInterceptor;

     /**
      * Intercepts HTTP requests to verify authentication tokens.
      * Implements Spring's HandlerInterceptor to check access tokens
      * before request processing.
      */
     @Component
     public class AuthInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(
         HttpServletRequest request,
         HttpServletResponse response,
         Object handler
       ) throws Exception {
         // Extract access token from cookies
         String accessToken = getCookieValue(request, "accessToken");

         // Return 401 if no token is present
         if (accessToken == null) {
           response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
           response.getWriter().write("{\"error\": \"Authentication required\"}");
           return false;
         }

         try {
           // Verify token validity using Scalekit's validation method
           boolean isValid = scalekit.validateAccessToken(accessToken);

           if (!isValid) {
             // If token is expired or invalid, attempt to refresh it
             return handleTokenRefresh(request, response);
           }

           // Token is valid, allow request to proceed
           return true;
         } catch (Exception e) {
           // If validation throws an exception, attempt token refresh as fallback
           return handleTokenRefresh(request, response);
         }
       }

       /**
        * Helper method to extract a specific cookie value from the request.
        *
        * @param request The HTTP request containing cookies
        * @param cookieName The name of the cookie to retrieve
        * @return The cookie value or null if not found
        */
       private String getCookieValue(HttpServletRequest request, String cookieName) {
         Cookie[] cookies = request.getCookies();
         if (cookies != null) {
           for (Cookie cookie : cookies) {
             if (cookieName.equals(cookie.getName())) {
               return cookie.getValue();
             }
           }
         }
         return null;
       }
      }
      ```
      </TabItem>
   </Tabs>

4. ## Maintain sessions by refreshing access tokens

   When access tokens expire, you can use the refresh token to obtain new ones without requiring users to sign in again. The refresh token is stored in a separate cookie that's only sent to your `/auth/refresh` endpoint. Implement refresh token rotation by replacing the old cookie with a new one on each refresh. This limits the window for token replay attacks.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="/auth/refresh endpoint" {5, 12, 18-21, 24-29}
     app.post('/auth/refresh', async (req, res) => {
       // Extract refresh token from cookie
       // Browser only sends this cookie to /auth/refresh due to Path scoping
       const { refreshToken } = req.cookies;

       if (!refreshToken) {
         return res.status(401).json({ error: 'No refresh token provided' });
       }

       try {
         // Exchange refresh token for new credentials with token rotation
         const authResult = await scalekit.refreshAccessToken(refreshToken);
         const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;

         // Rotate: Replace old access token cookie with new one
         res.cookie('accessToken', accessToken, {
           maxAge: (expiresIn - 60) * 1000, // Subtract 60s buffer for clock skew (milliseconds)
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict',
           path: '/api' // Restrict cookie to API routes only
         });

         // Rotate: Replace old refresh token cookie with new one
         res.cookie('refreshToken', newRefreshToken, {
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict',
           path: '/auth/refresh' // Only sent to refresh endpoint (least privilege)
         });

         // Return success
         res.json({ success: true });
       } catch (error) {
         // Refresh failed - clear both cookies
         res.clearCookie('accessToken', { path: '/api' }); // Match Path when clearing
         res.clearCookie('refreshToken', { path: '/auth/refresh' });
         return res.status(401).json({ error: 'Session expired. Please sign in again.' });
       }
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="/auth/refresh endpoint" {5, 11, 16-22, 25-31}
     from flask import request, jsonify, make_response
     import os

     @app.route('/auth/refresh', methods=['POST'])
     def refresh_token():
         # Extract refresh token from cookie
         # Browser only sends this cookie to /auth/refresh due to Path scoping
         refresh_token = request.cookies.get('refreshToken')

         if not refresh_token:
             return jsonify({'error': 'No refresh token provided'}), 401

         try:
             # Exchange refresh token for new credentials with token rotation
             auth_result = scalekit_client.refresh_access_token(refresh_token)
             access_token = auth_result.access_token
             expires_in = auth_result.expires_in
             new_refresh_token = auth_result.refresh_token

             response = make_response(jsonify({'success': True}))

             # Rotate: Replace old access token cookie with new one
             response.set_cookie(
                 'accessToken',
                 access_token,
                 max_age=expires_in - 60,  # Subtract 60s buffer for clock skew (seconds in Flask)
                 httponly=True,
                 secure=os.environ.get('FLASK_ENV') == 'production',
                 samesite='Strict',
                 path='/api'  # Restrict cookie to API routes only
             )

             # Rotate: Replace old refresh token cookie with new one
             response.set_cookie(
                 'refreshToken',
                 new_refresh_token,
                 httponly=True,
                 secure=os.environ.get('FLASK_ENV') == 'production',
                 samesite='Strict',
                 path='/auth/refresh'  # Only sent to refresh endpoint (least privilege)
             )

             return response
         except Exception:
             # Refresh failed - clear both cookies
             response = make_response(jsonify({'error': 'Session expired. Please sign in again.'}), 401)
             response.set_cookie('accessToken', '', expires=0, path='/api')  # Match Path when clearing
             response.set_cookie('refreshToken', '', expires=0, path='/auth/refresh')
             return response
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="/auth/refresh endpoint" {5, 12, 19-26, 29-36}
     import (
       "net/http"
       "os"
       "github.com/gin-gonic/gin"
     )
     func refreshTokenHandler(c *gin.Context) {
       // Extract refresh token from cookie
       // Browser only sends this cookie to /auth/refresh due to Path scoping
       refreshToken, err := c.Cookie("refreshToken")
       if err != nil || refreshToken == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "No refresh token provided"})
         return
       }

       // Exchange refresh token for new credentials with token rotation
       authResult, err := scalekitClient.RefreshAccessToken(refreshToken)
       if err != nil {
         // Refresh failed - clear both cookies
         c.SetCookie("accessToken", "", -1, "/api", "", false, true) // Match Path when clearing
         c.SetCookie("refreshToken", "", -1, "/auth/refresh", "", false, true)
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired. Please sign in again."})
         return
       }

       // Set SameSite mode for CSRF protection
       c.SetSameSite(http.SameSiteStrictMode)

       // Rotate: Replace old access token cookie with new one
       c.SetCookie(
         "accessToken",
         authResult.AccessToken,
         authResult.ExpiresIn-60, // Subtract 60s buffer for clock skew (seconds in Gin)
         "/api",                  // Restrict cookie to API routes only
         "",
         os.Getenv("GIN_MODE") == "release", // Secure flag in production
         true, // HttpOnly flag
       )

       // Rotate: Replace old refresh token cookie with new one
       c.SetCookie(
         "refreshToken",
         authResult.RefreshToken,
         0,                       // No expiry for refresh token cookie
         "/auth/refresh",         // Only sent to refresh endpoint (least privilege)
         "",
         os.Getenv("GIN_MODE") == "release", // Secure flag in production
         true, // HttpOnly flag
       )

       c.JSON(http.StatusOK, gin.H{"success": true})
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="/auth/refresh endpoint" collapse={1-5} {11, 19, 26-32, 35-40}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import org.springframework.core.env.Environment;
     import org.springframework.web.bind.annotation.*;

     @RestController
     public class RefreshController {
       @PostMapping("/auth/refresh")
       public ResponseEntity<?> refreshToken(HttpServletRequest request, HttpServletResponse response) {
         // Extract refresh token from cookie
         // Browser only sends this cookie to /auth/refresh due to Path scoping
         String refreshToken = getCookieValue(request, "refreshToken");

         if (refreshToken == null) {
           return ResponseEntity.status(401).body(Map.of("error", "No refresh token provided"));
         }

         try {
           // Exchange refresh token for new credentials with token rotation
           AuthResult authResult = scalekit.authentication().refreshToken(refreshToken);
           String accessToken = authResult.getAccessToken();
           int expiresIn = authResult.getExpiresIn();
           String newRefreshToken = authResult.getRefreshToken();

           // Rotate: Replace old access token cookie with new one
           Cookie accessTokenCookie = new Cookie("accessToken", accessToken);
           accessTokenCookie.setMaxAge(expiresIn - 60); // Subtract 60s buffer (seconds in Spring)
           accessTokenCookie.setHttpOnly(true);
           accessTokenCookie.setSecure("production".equals(env.getActiveProfiles()[0]));
           accessTokenCookie.setPath("/api"); // Restrict cookie to API routes only
           response.addCookie(accessTokenCookie);

           // Rotate: Replace old refresh token cookie with new one
           Cookie refreshTokenCookie = new Cookie("refreshToken", newRefreshToken);
           refreshTokenCookie.setHttpOnly(true);
           refreshTokenCookie.setSecure("production".equals(env.getActiveProfiles()[0]));
           refreshTokenCookie.setPath("/auth/refresh"); // Only sent to refresh endpoint
           response.addCookie(refreshTokenCookie);
           response.setHeader("Set-Cookie",
             response.getHeader("Set-Cookie") + "; SameSite=Strict"); // Prevents CSRF attacks

           return ResponseEntity.ok(Map.of("success", true));
         } catch (Exception e) {
           // Refresh failed - clear both cookies
           Cookie accessCookie = new Cookie("accessToken", "");
           accessCookie.setMaxAge(0);
           accessCookie.setPath("/api"); // Match Path when clearing
           response.addCookie(accessCookie);

           Cookie refreshCookie = new Cookie("refreshToken", "");
           refreshCookie.setMaxAge(0);
           refreshCookie.setPath("/auth/refresh");
           response.addCookie(refreshCookie);

           return ResponseEntity.status(401).body(Map.of("error", "Session expired. Please sign in again."));
         }
       }

       private String getCookieValue(HttpServletRequest request, String cookieName) {
         Cookie[] cookies = request.getCookies();
         if (cookies != null) {
           for (Cookie cookie : cookies) {
             if (cookieName.equals(cookie.getName())) {
               return cookie.getValue();
             }
           }
         }
         return null;
       }
      }
      ```
      </TabItem>
   </Tabs>

   When a client receives a 401 error from your API (indicating an expired access token), call your `/auth/refresh` endpoint to obtain new tokens. The browser automatically includes the refresh token cookie due to Path scoping.

6. ## Manage session security and duration

      Manage user session behavior directly from your Scalekit dashboard without modifying application code. Configure session durations and authentication frequency to balance security and user experience for your application.

      ![](@/assets/docs/manage-session/session-policies-dashboard.png)

       In your Scalekit dashboard, the **Session settings** page lets you set these options:

      - **Absolute session timeout**: This is the maximum time a user can stay signed in, no matter what. After this time, they must log in again. For example, if you set it to 30 minutes, users will be logged out after 30 minutes, even if they are still using your app.

      - **Idle session timeout**: This is the time your app waits before logging out a user who is not active. If you turn this on, the session will end if the user does nothing for the set time. For example, if you set it to 10 minutes, and the user does not click or type for 10 minutes, they will be logged out.

      - **Access token lifetime**: This is how long an access token is valid. When it expires, your app needs to get a new token (using the refresh token) so the user can keep using the app without logging in again. For example, if you set it to 5 minutes, your app will need to refresh the token every 5 minutes.

      Shorter timeouts provide better security, while longer timeouts reduce authentication interruptions.

   <Aside type="note">
   **Logout security**: When implementing logout, clear both the `accessToken` and `refreshToken` cookies with the same `Path` attributes used when setting them (`/api` and `/auth/refresh` respectively). Additionally, revoke the refresh token with Scalekit and invalidate any server-side sessions to ensure complete logout.
   </Aside>
</Steps>