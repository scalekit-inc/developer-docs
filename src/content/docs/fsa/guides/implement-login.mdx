---
title: "Initiate user login"
description: "Create authorization URLs and redirect users to Scalekit's hosted login page with proper parameters and organization routing."
sidebar:
  label: "Initiate user login"
tableOfContents:
  maxHeadingLevel: 2
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: "Try quickstart"
  link: "/fsa/quickstart/"

---
import { Card, CardGrid, Steps, TabItem, Tabs, Aside, LinkCard } from '@astrojs/starlight/components';

Login initiation begins your authentication flow. You redirect users to Scalekit's hosted login page by creating an authorization URL with appropriate parameters. When users visit this URL, Scalekit's authorization server validates the request, displays the login interface, and handles authentication through your configured connection methods (SSO, social providers, or passwordless).

## Authorization URL format

The authorization URL directs users to Scalekit's login page with all necessary request parameters:

```sh title="Authorization URL format" showLineNumbers=true
<SCALEKIT_ENVIRONMENT_URL>/oauth/authorize?
  response_type=code& # always `code` for authorization code flow
  client_id=<SCALEKIT_CLIENT_ID>& # Dashboard > Developers > Settings > API Credentials
  redirect_uri=<CALLBACK_URL>& # Dashboard > Authentication > Redirect URLs > Allowed Callback URLs
  scope=openid+profile+email+offline_access& # Permissions requested. Include `offline_access` for refresh tokens
  state=<RANDOM_STATE> # prevent CSRF attacks
```

The authorization request includes several parameters that control authentication behavior and security:

- **Required parameters** ensure Scalekit can identify your application and return the user securely
- **Optional parameters** enable organization routing and pre-populate fields
- **Security parameters** prevent unauthorized access attempts

## Request parameters

Understand each parameter and how it controls the authorization flow:

| Parameter | Required | Description |
|-----------|----------|-------------|
| `response_type` | Yes | Set to `code` for authorization code flow. Indicates the expected response type. |
| `client_id` | Yes | Your application's public identifier from the dashboard. Scalekit uses this to identify and validate your application. |
| `redirect_uri` | Yes | Your application's callback URL where Scalekit returns the authorization code. Must be registered in your dashboard settings. |
| `scope` | Yes | Space-separated list of permissions. Always include `openid profile email`. Add `offline_access` to request refresh tokens for extended sessions. |
| `state` | Recommended | Random string generated by your application. Scalekit returns this unchanged. Use it to prevent CSRF attacks and maintain request state. |
| `prompt` | Recommended | Value to control the authentication flow. <br /> Use `login` to force re-authentication. <br/>Use `create` to trigger sign up page <br/> `select_account` to select an account if they have multiple accounts |
| `organization_id` | Optional | Route user to specific organization's configured authentication method. |
| `connection_id` | Optional | Skip organization selection and direct user to specific SSO connection. |
| `login_hint` | Optional | Pre-populate the email field with a hint. Useful for domain-based routing when combined with `organization_id`. |

### Security: the state parameter

Always generate a cryptographically secure random string for the `state` parameter. Your application must validate that the state value returned in the callback matches the original value you sent. This prevents **CSRF (Cross-Site Request Forgery)** attacks where an attacker tricks users into approving unauthorized authentication requests.

```javascript
// Generate secure random state
const state = require('crypto').randomBytes(32).toString('hex');
// Store it temporarily (session, cache, etc)
session.oauthState = state;
// Include in authorization URL
const authUrl = scalekit.getAuthorizationUrl(redirectUri, { state });
```

<Aside type="caution" title="Always validate state on callback">
Never skip state validation. An attacker could craft an authorization request and trick your users into visiting it. By validating the state parameter, you ensure the callback response matches a request your application initiated.
</Aside>

## Create authorization URL

Use the Scalekit SDK to generate properly formatted authorization URLs. The SDK handles parameter encoding, validation, and generates secure random state values automatically.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">
```javascript title="Express.js" collapse={1-4} {11} "getAuthorizationUrl"
import { Scalekit } from '@scalekit-sdk/node';

const scalekit = new Scalekit(/* your credentials */);

// Basic authorization URL for general login
const redirectUri = 'https://yourapp.com/auth/callback';
const options = {
  scopes: ['openid', 'profile', 'email', 'offline_access'],
};

const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);

// Redirect user to Scalekit's hosted login page
res.redirect(authorizationUrl);
```
</TabItem>
<TabItem value="python" label="Python">
```python title="Flask" collapse={1-3} {11} "get_authorization_url"
from scalekit import ScalekitClient, AuthorizationUrlOptions

scalekit = ScalekitClient(/* your credentials */)

# Basic authorization URL for general login
redirect_uri = 'https://yourapp.com/auth/callback'
options = AuthorizationUrlOptions(
    scopes=['openid', 'profile', 'email', 'offline_access']
)

authorization_url = scalekit.get_authorization_url(redirect_uri, options)

# Redirect user to Scalekit's hosted login page
return redirect(authorization_url)
```
</TabItem>
<TabItem value="go" label="Go">
```go title="Gin" collapse={1-4} {11} "GetAuthorizationUrl"
import "github.com/scalekit-inc/scalekit-sdk-go"

scalekit := scalekit.NewScalekitClient(/* your credentials */)

// Basic authorization URL for general login
redirectUri := "https://yourapp.com/auth/callback"
options := scalekit.AuthorizationUrlOptions{
    Scopes: []string{"openid", "profile", "email", "offline_access"},
}

authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)

// Redirect user to Scalekit's hosted login page
c.Redirect(http.StatusFound, authorizationUrl.String())
```
</TabItem>
<TabItem value="java" label="Java">
```java title="Spring" collapse={1-4} {11} "getAuthorizationUrl"
import com.scalekit.ScalekitClient;
import com.scalekit.internal.http.AuthorizationUrlOptions;

ScalekitClient scalekit = new ScalekitClient(/* your credentials */);

// Basic authorization URL for general login
String redirectUri = "https://yourapp.com/auth/callback";
AuthorizationUrlOptions options = new AuthorizationUrlOptions();
options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));

URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);

// Redirect user to Scalekit's hosted login page
return new RedirectView(authorizationUrl.toString());
```
</TabItem>
</Tabs>


After the user authenticates:
1. Scalekit generates an authorization code
2. The user's browser is redirected to your registered allowed callback URL with the `code` parameter
3. Your backend exchanges the code for tokens by making a server-to-server request

This approach keeps sensitive operations server-side and protects your application's credentials.

Let's take a look at how to complete the login in the next step.
