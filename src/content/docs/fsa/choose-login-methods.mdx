---
title: "Configure authentication methods"
description: "Set up passwordless, social, and enterprise SSO authentication options for your users. Learn when to use each method and how to configure them."
sidebar:
  label: "Manage auth methods"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 { font-size: var(--sl-text-xl); }
      .sl-markdown-content h3 { font-size: var(--sl-text-lg); }
prev:
  label: "Initiate login"
  link: "/fsa/guides/implement-login/"
next:
  label: "Handle redirections"  
  link: "/fsa/guides/handle-redirections/"
seeAlso:
  label: "Configuration guides"
  items:
    - title: "Social login integrations"
      icon: "puzzle"
      url: "/guides/integrations/social-connections/"
    - title: "Enterprise SSO setup"
      icon: "seti:lock"
      url: "/sso/quickstart/"
    - title: "Login page branding"
      icon: "paintbrush"
      url: "/fsa/guides/login-page-branding/"
    - title: "Signup restrictions"
      icon: "shield"
      url: "/fsa/guides/signup-restrictions/"
---

import { CardGrid, Steps, TabItem, Tabs, Aside, LinkCard, Badge } from '@astrojs/starlight/components';

Configure authentication methods to match your users' preferences and your organization's requirements. Scalekit supports passwordless, social, and enterprise SSO authentication options that can be used individually or combined.

## Choose the right authentication methods

Different authentication methods serve different user types and security requirements:

| Method | Best for | User experience & Security |
|--------|----------|---------------------------|
| **Passwordless** | General users, quick onboarding | Frictionless, no passwords to remember. High security with email verification |
| **Social login** | Consumer apps, familiar providers | One-click sign-in with existing accounts. Medium security (depends on provider) |
| **Enterprise SSO** | B2B customers, organizations | Single sign-on with corporate identity. Highest security (organization-controlled) |

### When to use multiple methods

**Recommended combinations:**
- **Passwordless + Social** - Consumer apps with broad appeal
- **Passwordless + SSO** - B2B apps with both individual and enterprise users  
- **All three methods** - Multi-tenant platforms serving diverse user bases

**Organization-specific routing:**
Enterprise users are automatically routed to their organization's configured SSO method, while individual users see passwordless and social options.

## Configure passwordless login

In the dashboard, go to **Authentication > Auth methods > Passwordless**


![](@/assets/docs/unlisted/passwordless/1-v2.png)

To protect your application, Scalekit limits a user to **five** attempts to enter the correct OTP within a ten-minute window for each authentication request. If the user exceeds this limit, they must restart the authentication process.

Users can sign in securely by:

 - Entering a verification code sent to their email
 - Clicking a magic link sent to their email



## Configure social logins

Social login enables authentication through existing accounts from providers like Google, Microsoft, and GitHub. Users don't need to create or remember new credentials, making the sign-in process faster and more convenient. Scalekit should be set up with social providers in the dashboard.

By default, Google is pre-configured in development environments for simplified testing. Follow our [quickstart](/fsa/quickstart/) to implement the integration. The rest is configuration in the dashboard.

<Steps>

1. ### Set up a social provider in your current environment

   Navigate to **Authentication** > **Auth Methods** > **Social logins** in your dashboard to configure these settings

   <CardGrid>
      <LinkCard title="Google" href="/guides/integrations/social-connections/google">
        Enable users to sign in with their Google accounts using OAuth 2.0
      </LinkCard>
      <LinkCard title="GitHub" href="/guides/integrations/social-connections/github">
        Allow users to authenticate using their GitHub credentials
      </LinkCard>
      <LinkCard title="Microsoft" href="/guides/integrations/social-connections/microsoft">
        Integrate Microsoft accounts for seamless user authentication
      </LinkCard>
      <LinkCard title="GitLab" href="/guides/integrations/social-connections/gitlab">
        Enable GitLab-based authentication for your application
      </LinkCard>
      <LinkCard title="LinkedIn" href="/guides/integrations/social-connections/linkedin">
        Let users sign in with their LinkedIn accounts using OAuth 2.0
      </LinkCard>
      <LinkCard title="Salesforce" href="/guides/integrations/social-connections/salesforce">
        Enable Salesforce-based authentication for your application
      </LinkCard>
   </CardGrid>

   Users can sign in using their existing accounts from your configured providers.

2. ### Direct users to specific social providers <Badge text="optional" variant="tip" />

   Route users directly to a specific social provider by including the provider parameter in your authorization URL.

   **Supported providers:** `google`, `microsoft`, `github`, `salesforce`, `linkedin`, `gitlab`

   <Tabs syncKey="tech-stack">
   <TabItem value="nodejs" label="Node.js">
   ```javascript title="Express.js" {3} "provider"
   const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, {
     scopes: ['openid', 'profile', 'email', 'offline_access'],
     provider: 'google',
     state: 'random_csrf_token'
   });

   res.redirect(authorizationUrl);
   ```
   </TabItem>
   <TabItem value="py" label="Python">
   ```python title="Flask" {3} "provider" 
   options = AuthorizationUrlOptions(
     scopes=['openid', 'profile', 'email', 'offline_access'],
     provider='google',
     state='random_csrf_token'
   )

   authorization_url = scalekit.get_authorization_url(redirect_uri, options)
   return redirect(authorization_url)
   ```
   </TabItem>
   <TabItem value="golang" label="Go">
   ```go title="Gin" {3} "Provider"
   options := scalekit.AuthorizationUrlOptions{
     Scopes: []string{"openid", "profile", "email", "offline_access"},
     Provider: "google",
     State: "random_csrf_token"
   }

   authorizationUrl, _ := scalekit.GetAuthorizationUrl(redirectUri, options)
   c.Redirect(http.StatusFound, authorizationUrl.String())
   ```
   </TabItem>
   <TabItem value="java" label="Java">
   ```java title="Spring" {3} "setProvider"
   AuthorizationUrlOptions options = new AuthorizationUrlOptions();
   options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
   options.setProvider("google");
   options.setState("random_csrf_token");

   URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
   return new RedirectView(authorizationUrl.toString());
   ```
   </TabItem>
   </Tabs>

   <Aside type="note" title="Provider parameter bypasses method selection">
    Including a `provider` parameter directs users straight to the specified social provider's login page. This is useful for custom login interfaces where you want to show separate buttons for each provider.

    Without this parameter, users see Scalekit's hosted login page with all enabled authentication methods.
   </Aside>

</Steps>


## Configure enterprise SSO

Enterprise SSO allows organizations to authenticate users through their corporate identity provider (Okta, Azure AD, etc.). Users are automatically routed to their organization's SSO based on their email domain or organization membership.

### Organization-aware authentication

Route enterprise users to their organization's SSO connection:

<Tabs syncKey="tech-stack">
<TabItem value="nodejs" label="Node.js">
```javascript title="Express.js" {3-4} "organizationId"
const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, {
  scopes: ['openid', 'profile', 'email', 'offline_access'],
  organizationId: 'org_12345',        // Route to organization's SSO
  loginHint: 'user@company.com',      // Domain-based routing
});

res.redirect(authorizationUrl);
```
</TabItem>
<TabItem value="py" label="Python">
```python title="Flask" {3-4} "organization_id"
options = AuthorizationUrlOptions(
  scopes=['openid', 'profile', 'email', 'offline_access'],
  organization_id='org_12345',       # Route to organization's SSO
  login_hint='user@company.com'      # Domain-based routing
)

authorization_url = scalekit.get_authorization_url(redirect_uri, options)
return redirect(authorization_url)
```
</TabItem>
<TabItem value="golang" label="Go">
```go title="Gin" {3-4} "OrganizationId"
options := scalekit.AuthorizationUrlOptions{
  Scopes: []string{"openid", "profile", "email", "offline_access"},
  OrganizationId: "org_12345",       // Route to organization's SSO
  LoginHint: "user@company.com"      // Domain-based routing
}

authorizationUrl, _ := scalekit.GetAuthorizationUrl(redirectUri, options)
c.Redirect(http.StatusFound, authorizationUrl.String())
```
</TabItem>
<TabItem value="java" label="Java">
```java title="Spring" {3-4} "setOrganizationId"
AuthorizationUrlOptions options = new AuthorizationUrlOptions();
options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
options.setOrganizationId("org_12345");        // Route to organization's SSO
options.setLoginHint("user@company.com");      // Domain-based routing

URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
return new RedirectView(authorizationUrl.toString());
```
</TabItem>
</Tabs>

Enterprise users see their identity provider's login page. Users verify their identity through the authentication policies set by their organization's administrator. After successful verification, the user profile is [normalized](/sso/guides/user-profile-details/) and sent to your app.

The organization should be set up with a valid SSO connection. [See the full implementation guide for testing and onboarding enterprise customers](/sso/quickstart/).

## Multi-tenant authentication patterns

### Organization-first routing

For B2B applications where users belong to specific organizations:

<Tabs syncKey="tech-stack">
<TabItem value="nodejs" label="Node.js">
```javascript title="Organization routing" {2-3} "getOrganizationId"
// Extract organization from subdomain, path, or user input
const orgId = getOrganizationId(req);

const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, {
  scopes: ['openid', 'profile', 'email', 'offline_access'],
  organizationId: orgId,
});
```
</TabItem>
<TabItem value="py" label="Python">
```python title="Organization routing" {2-3} "get_organization_id"
# Extract organization from subdomain, path, or user input
org_id = get_organization_id(request)

options = AuthorizationUrlOptions(
  scopes=['openid', 'profile', 'email', 'offline_access'],
  organization_id=org_id
)
```
</TabItem>
<TabItem value="golang" label="Go">
```go title="Organization routing" {2-3} "getOrganizationId"
// Extract organization from subdomain, path, or user input
orgId := getOrganizationId(c.Request)

options := scalekit.AuthorizationUrlOptions{
  Scopes: []string{"openid", "profile", "email", "offline_access"},
  OrganizationId: orgId,
}
```
</TabItem>
<TabItem value="java" label="Java">
```java title="Organization routing" {2-3} "getOrganizationId"
// Extract organization from subdomain, path, or user input
String orgId = getOrganizationId(request);

AuthorizationUrlOptions options = new AuthorizationUrlOptions();
options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
options.setOrganizationId(orgId);
```
</TabItem>
</Tabs>

### Domain-based routing

Let Scalekit automatically detect the organization from the user's email domain:

<Tabs syncKey="tech-stack">
<TabItem value="nodejs" label="Node.js">
```javascript title="Domain-based routing" {3} "loginHint"
const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, {
  scopes: ['openid', 'profile', 'email', 'offline_access'],
  loginHint: userEmail,  // Scalekit extracts domain and routes to org
});
```
</TabItem>
<TabItem value="py" label="Python">
```python title="Domain-based routing" {3} "login_hint"
options = AuthorizationUrlOptions(
  scopes=['openid', 'profile', 'email', 'offline_access'],
  login_hint=user_email  # Scalekit extracts domain and routes to org
)
```
</TabItem>
<TabItem value="golang" label="Go">
```go title="Domain-based routing" {3} "LoginHint"
options := scalekit.AuthorizationUrlOptions{
  Scopes: []string{"openid", "profile", "email", "offline_access"},
  LoginHint: userEmail,  // Scalekit extracts domain and routes to org
}
```
</TabItem>
<TabItem value="java" label="Java">
```java title="Domain-based routing" {3} "setLoginHint"
AuthorizationUrlOptions options = new AuthorizationUrlOptions();
options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
options.setLoginHint(userEmail);  // Scalekit extracts domain and routes to org
```
</TabItem>
</Tabs>

## Security considerations

### CSRF protection

Always include the `state` parameter with a random value to prevent cross-site request forgery:

<Tabs syncKey="tech-stack">
<TabItem value="nodejs" label="Node.js">
```javascript title="CSRF protection" {2,4} "state"
const state = generateRandomString(32);
req.session.authState = state;

const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, {
  scopes: ['openid', 'profile', 'email', 'offline_access'],
  state: state,
});
```
</TabItem>
<TabItem value="py" label="Python">
```python title="CSRF protection" {2,4} "state"
state = generate_random_string(32)
session['auth_state'] = state

options = AuthorizationUrlOptions(
  scopes=['openid', 'profile', 'email', 'offline_access'],
  state=state
)
```
</TabItem>
<TabItem value="golang" label="Go">
```go title="CSRF protection" {2,4} "State"
state := generateRandomString(32)
session.Set("auth_state", state)

options := scalekit.AuthorizationUrlOptions{
  Scopes: []string{"openid", "profile", "email", "offline_access"},
  State: state,
}
```
</TabItem>
<TabItem value="java" label="Java">
```java title="CSRF protection" {2,4} "setState"
String state = generateRandomString(32);
session.setAttribute("authState", state);

AuthorizationUrlOptions options = new AuthorizationUrlOptions();
options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
options.setState(state);
```
</TabItem>
</Tabs>

### Production requirements

- **Use HTTPS** - Required in production for secure token transmission
- **Store tokens securely** - Use HTTP-only cookies or secure server-side storage
- **Validate redirects** - Configure allowed redirect URIs in your dashboard

<Aside type="tip" title="Security best practices">
For comprehensive security guidance including threat modeling, advanced patterns, and detailed security checklists, see our [Authentication Security Guide](/guides/security/authentication-security/).
</Aside>