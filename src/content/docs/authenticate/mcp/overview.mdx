---
title: Auth for MCP servers - Overview
description: Secure your Model Context Protocol (MCP) servers with Scalekit's drop-in OAuth 2.1 authorization solution
tableOfContents:
  maxHeadingLevel: 2
sidebar:
  label: Overview
prev: false
next: false
banner:
  content: |
    Join our dev community to connect with Scalekit engineers for questions or feedback
---

import { Steps, LinkCard } from '@astrojs/starlight/components';
import Subtitle from '@/components/ui/Subtitle.astro'

<Subtitle>How MCP is transforming AI application architecture and why authorization matters more than ever</Subtitle>

The artificial intelligence landscape is rapidly evolving from simple chatbots to sophisticated agents capable of interacting with real-world systems, accessing sensitive data, and performing complex workflows. As AI applications become more powerful and integrated into business-critical processes, the need for standardized, secure communication protocols has never been more urgent.

Enter the Model Context Protocol (MCP) ? a breakthrough standard that's reshaping how AI models interact with external systems while introducing new security challenges that demand careful attention.

## What is Model Context Protocol (MCP)?

Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.

The Model Context Protocol is an open standard that defines how AI applications can safely and efficiently access external resources, tools, and data sources. Instead of each AI system requiring custom integrations for every service it needs to access, MCP creates a universal interface that works across different AI models, platforms, and data sources.

### The MCP architecture

At its core, MCP follows a client-server architecture where a host application can connect to multiple servers:

- **MCP hosts**: AI applications like Claude Desktop, IDEs, or custom AI tools that need to access external resources
- **MCP clients**: Protocol clients that maintain connections between hosts and servers
- **MCP servers**: Lightweight programs that expose specific capabilities (tools, data, or services) through the standardized protocol
- **Data sources**: Local files, databases, APIs, and services that MCP servers can access

This architecture enables a plugin ecosystem where AI models can seamlessly integrate with hundreds of different services without requiring custom code for each integration.

## The path to secure MCP: OAuth 2.1 integration

Recognizing these challenges, the MCP specification evolved to incorporate robust authorization mechanisms. The Model Context Protocol provides authorization capabilities at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners.

### Why OAuth 2.1 for MCP?

The MCP specification chose OAuth 2.1 as its authorization framework for several compelling reasons

|  |  |
|---------|-------------|
| Industry standard | OAuth 2.1 is a well-established, widely-adopted standard for delegated authorization, with extensive tooling and ecosystem support. |
| Security best practices | OAuth 2.1 incorporates lessons learned from OAuth 2.0, removing deprecated flows and enforcing security measures like PKCE (Proof Key for Code Exchange). |
| Flexibility | Supports multiple grant types suitable for different MCP use cases:<br/> **Authorization code**: When AI agents act on behalf of human users<br/> **Client credentials**: For machine-to-machine integrations |
| Ecosystem compatibility | Works with existing identity providers and authorization servers, making it easier for enterprises to integrate MCP into their existing security infrastructure. |

### MCP authorization specification overview

This authorization mechanism is based on established specifications listed below, but implements a selected subset of their features to ensure security and interoperability while maintaining simplicity:

- **OAuth 2.1**: Core authorization framework with enhanced security
- **OAuth 2.0 Authorization Server Metadata (RFC8414)**: Standardized server discovery
- **OAuth 2.0 Dynamic Client Registration Protocol (RFC7591)**: Automatic client registration
- **OAuth 2.0 Protected Resource Metadata (RFC9728)**: Resource server discovery
- **Client ID Metadata Document (CIMD)**: Lets authorization servers fetch client metadata directly from a client-hosted document for authorization

![MCP OAuth 2.1 Authorization Flow](@/assets/docs/guides/mcp/overview-mcp-seq-diag.png)

## The authorization flow in practice

Now let's zoom in and see how the MCP OAuth 2.1 flow unfolds step-by-step:

{/* 
This section is intentionally left commented out in case there needs to be updates to the existing d2 Diagram for the MCP Flow for
future updates or implemenation.

```d2 pad=36

title: "MCP OAuth 2.1 Authorization Code Flow with PKCE" {
  near: top-center
  shape: text
  style.font-size: 18
}

shape: sequence_diagram

# ============ Discovery Phase ============
MCP Client -> MCP Server: Fetch MCP session capabilities/auth/session
MCP Server -> MCP Client: Get description
MCP Client -> MCP Server: Fetch server capabilities/scopes/permissions
MCP Server -> MCP Client: API capabilities, authentication scopes, authorization server metadata
MCP Client -> MCP Server: Request available auth configuration options
MCP Server -> Authorization Server: GET /.well-known/oauth-authorization-server
Authorization Server -> MCP Server: Authorization server metadata (endpoints, OAuth support)
MCP Server -> MCP Client: Returns OAuth server configuration

# ============ Authorization Phase ============
MCP Client -> MCP Server: Initiate OAuth flow (PKCE)
MCP Client -> MCP Server: GET /api/authorize
MCP Server -> Authorization Server: Redirect to /oauth/authorize with PKCE challenge
Authorization Server -> User: Display login/consent prompt
User -> Authorization Server: Authenticate & grant consent
Authorization Server -> MCP Server: Redirect with authorization code & state
MCP Server -> MCP Client: Return authorization code
MCP Client -> Authorization Server: POST /oauth/token with PKCE verifier
Authorization Server -> MCP Client: Issue access token (PKCE verified)
MCP Client -> MCP Server: Store token
MCP Server -> MCP Client: Success response

# ============ Use Phase ============
MCP Client -> MCP Server: API call with Bearer token
MCP Server -> MCP Server: Validate token
MCP Server -> MCP Client: Authorized response

# ============ Token Refresh Phase ============
MCP Client -> Authorization Server: POST /oauth/token (grant_type=refresh_token)
Authorization Server -> MCP Client: New access token & refresh token
``` */}


**Discovery phase**
<Steps>

1. **MCP client** encounters a protected MCP server
2. **Server** responds with `401 Unauthorized` and `WWW-Authenticate` header pointing to Scalekit Auth Server
3. **Client** discovers Scalekit Auth Server capabilities through metadata endpoints

</Steps>

```d2 pad=36

title: "MCP Login Discovery Phase" {
  near: top-center
  shape: text
  style.font-size: 18
}

shape: sequence_diagram

MCP Client
Your MCP Server
Scalekit Auth Server
Your Customer's User

MCP Client -> Your MCP Server: POST /mcp\n(Without Authorization Header)
Your MCP Server -> MCP Client: 401 Unauthorized\n(WWW-Authenticate: resource_metadata="...")
MCP Client -> Your MCP Server: GET /.well-known/oauth-protected-resource\n(Fetch info on how and where to connect to MCP Server)
Your MCP Server -> MCP Client: Returns resource metadata\n(authorization server URL, scopes)
MCP Client -> Scalekit Auth Server: GET /.well-known/oauth-authorization-server
Scalekit Auth Server -> MCP client: Scalekit Auth Server metadata\n(endpoints, scopes, flows)
```

**Authorization phase**

<Steps>
4. **Client** registers with Scalekit Auth Server (if using DCR)
5. **Scalekit Auth Server** issues client credentials (if using DCR)
6. **Client** initiates appropriate OAuth flow
7. **User** grants consent (for Authorization Code flow)
8. **Scalekit Auth Server** issues access token with appropriate scopes
</Steps>


```d2 pad=36
title: "MCP DCR Authorization Phase" {
  near: top-center
  shape: text
  style.font-size: 18
}

shape: sequence_diagram

MCP Client
Your MCP Server
Scalekit Auth Server
Your Customer's User

MCP Client -> Scalekit Auth Server: POST /res_123../client_register
Scalekit Auth Server -> MCP Client: return with client_id and client_secret
MCP Client -> Scalekit Auth Server: redirect to oauth/authorize
Scalekit Auth Server -> Your Customer's User: Prompt to Authenticate & Consent
Your Customer's User -> Scalekit Auth Server: Redirect with authorization code & state
Scalekit Auth Server -> MCP Client: Return with authorization code
MCP Client -> Scalekit Auth Server: POST /oauth/token with PKCE verifier and auth code
Scalekit Auth Server -> MCP Client: Issue access token, id_token, scopes 
```

```d2 pad=36
title: "MCP CIMD Authorization Phase" {
  near: top-center
  shape: text
  style.font-size: 18
}

shape: sequence_diagram

MCP Client
Your MCP Server
Scalekit Auth Server
Your Customer's User

MCP Client -> Scalekit Auth Server: Redirect to oauth/authorize with PKCE Challenge
Scalekit Auth Server -> MCP Client: Scalekit auth server fetches CIMD Metadata
MCP Client -> Scalekit Auth Server: gets Metadata document and validates metadata
Scalekit Auth Server -> Your Customer's User: Prompt to Authenticate & Consent
Your Customer's User -> Scalekit Auth Server: Redirect with authorization code & state
Scalekit Auth Server -> MCP Client: Return with authorization code
MCP Client -> Scalekit Auth Server: POST /oauth/token with PKCE verifier and auth code
Scalekit Auth Server -> MCP Client: Issue access token, id_token, scopes 
```

**Access phase**

<Steps>
9. **Client** includes access token in requests to MCP server
10. **MCP server** validates token and enforces scope-based permissions
11. **Server** processes request and returns response
12. **All interactions** are logged for audit and compliance
</Steps>


```d2 pad=36

title: "Human and MCP Server (OAuth 2.1 Authorization Code Flow)" {
  near: top-center
  shape: text
  style.font-size: 18
}

shape: sequence_diagram

MCP Client
Your MCP Server
Scalekit Auth Server

access_phase: {
  style.fill: "#a29696"
  
  MCP Client -> Your MCP Server: API call with Bearer token
  Your MCP Server -> Your MCP Server: Validate token
  Your MCP Server -> MCP Client: Authorized response
}

if session expires: {
  style.fill: "#a29696"
  
  MCP Client -> Scalekit Auth Server: POST /oauth/token\n(grant_type=refresh_token)
  Scalekit Auth Server -> MCP Client: New access token & refresh token
}
    
  
```



## Key security enhancements in MCP OAuth 2.1

The current MCP authorization specification incorporates several critical security improvements:

#### Mandatory PKCE

MCP clients MUST implement PKCE according to OAuth 2.1 Section 7.5.2. PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.

#### Strict redirect URI validation

MCP clients MUST pre-register exact redirect URIs with the authorization server. During authorization, the server MUST enforce an exact match to prevent redirection attacks.

#### Short-lived tokens

MCP authorization servers SHOULD issue short-lived access tokens to reduce the impact of leaked tokens. This minimizes the window of exposure if tokens are compromised.

#### Comprehensive scope model

MCP OAuth 2.1 supports granular permissions through scopes like:

| Scope                               | Description                          |
|-------------------------------------|--------------------------------------|
| `todo:read`                         | Read todo tasks                      |
| `todo:write`                        | Create and edit todo tasks           |

#### Client ID Metadata Document (CIMD)

MCP clients SHOULD support the Client ID Metadata Document (CIMD) specification, which allows clients to publish their OAuth client metadata at a well-known URL under their control. This enables authorization servers to automatically retrieve and validate client metadata without requiring an explicit dynamic registration request, simplifying onboarding for new AI agents while maintaining secure, decentralized client configuration.

#### Dynamic client registration

MCP clients and authorization servers SHOULD support the OAuth 2.1 Dynamic Client Registration Protocol to allow MCP clients to obtain OAuth client IDs without user interaction. This enables seamless onboarding of new AI agents without manual configuration.

## Why authorization matters more than ever

As AI applications become more sophisticated and handle increasingly sensitive operations, proper authorization is no longer optional ? it's essential for several reasons:

#### Regulatory compliance

Many industries require strict access controls and audit trails. Healthcare organizations must comply with HIPAA, financial services with SOX and PCI DSS, and global companies with GDPR. <a href="https://www.scalekit.com/blog/oauth-2-1-mcp-secure-ai-integrations" target="_blank">OAuth 2.1 and MCP provide the security framework needed for regulatory compliance</a>.

#### Enterprise adoption

Enterprises won't deploy AI systems that can't integrate with their existing identity and access management infrastructure. OAuth 2.1 compatibility makes MCP servers enterprise-ready.

#### Risk management

As AI agents gain the ability to perform real-world actions ? sending emails, making purchases, modifying databases ? the potential impact of unauthorized access grows exponentially. Proper authorization limits the blast radius of security incidents.

#### Trust and transparency

Users and organizations need to understand what AI systems can access and how that access is controlled. OAuth scopes provide clear, granular permissions that can be communicated to stakeholders.

#### Future-proofing

As AI capabilities expand, authorization frameworks must be able to evolve. OAuth 2.1's extensible scope model and standards-based approach provide a foundation for future security enhancements.


### Next steps

<LinkCard href="/authenticate/mcp/quickstart" title="MCP OAuth 2.1 implementation guide" description="Step-by-step instructions for setting up production-ready authorization for your MCP server, including code examples and best practices." />
