---
title: Merge user identities
description: "Learn how Scalekit automatically merges user identities from different authentication methods, ensuring a single user profile and preventing duplicate accounts"
tableOfContents: true
browseCentral:
  label: "See how Scalekit merges user identities"
  filterType: ["tutorial"]
  category: ["Manage users & orgs"]
  icon: book
sidebar:
  label: "Merge user identities"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  link: '/authenticate/manage-users-orgs/email-domain-rules/'
  label: 'Configure email domain rules'
next:
  link: '/authenticate/manage-organizations/remove-users-from-organization/'
  label: 'Remove users from organizations'
---

import { Aside, Badge } from '@astrojs/starlight/components';

Users can sign into your application using different authentication methods. For example, a user might authenticate with a passwordless method today and LinkedIn OAuth tomorrow. Scalekit automatically merges these identities into a single user profile, preventing duplicate accounts and ensuring a unified experience across all authentication methods.

Identity linking is the process in which Scalekit safely deduplicates various authentication methods across identity providers to offer a single, unified user interface. Scalekit uses the **email address** as the unique identifier and access to the email inbox as the source of truth.

```d2 pad=50
direction: right;

email: "Email: jane.roe@megacrop.com"
google_oauth: "Google OAuth"
microsoft_oauth: "Microsoft OAuth"
user: "User"

email -> google_oauth: "Credential"
email -> microsoft_oauth: "Credential"
google_oauth -> user: "Linked"
microsoft_oauth -> user: "Linked"
```

When users prove access to their email inbox through any authentication method, Scalekit treats this as an identity. Scalekit automatically links multiple identities together using the user's email address as the source of truth, ensuring that all authentication methods for the same email address are associated with a single User object.

## Email verification

Scalekit ensures all user emails are unique via an email verification process. By default, email verification is required for all users for authentication to succeed. This ensures that verified users are always returned to your application.

When a user signs in with a new authentication method for the first time—for example, they sign in through Google OAuth despite already having a passwordless account—Scalekit will safely attach the new authentication method to the existing user. This is only performed if Scalekit can verify that the user has access to the email inbox referenced by that authentication method.

Scalekit considers it a **security risk if the user cannot verify access to their email**. Some identity providers allow creating accounts with any email address without verification. For instance, an IT admin of an organization with the domain `megacrop.com` could make an account for `admin@competitor.com`. If access to `admin@competitor.com` is not verified, the admin could sign in to the application as that user.

Scalekit does not complete the authentication flow when a new identity cannot be safely linked to an existing user to ensure account takeover risks are minimized.

<Aside type="note" title="Email verification requirement">
  Email verification is required by default for all authentication methods. This prevents unauthorized access and ensures users have control over their accounts.
</Aside>

## Domain verification

When an organization administrator verifies a domain for their organization through [allowed email domains](/authenticate/manage-users-orgs/email-domain-rules/), it means they have access to create email inboxes. Thus, a **verified domain implies the ability to verify all users with that email domain**.

In practice, when a domain is verified and an SSO connection is configured, users who sign in through an organization's identity provider are automatically considered email verified if the domain matches. This shortcut reduces friction for your end users while maintaining security.

Users who sign in through SSO with an email address that is not a verified domain are not considered verified and will have to go through the email verification process.

<Aside type="tip" title="Configure allowed email domains">
  Learn how to set up allowed email domains for automatic organization membership and domain verification in the [email domain rules guide](/authenticate/manage-users-orgs/email-domain-rules/).
</Aside>

## Link SSO identities

Not only can a user have multiple authentication methods, they may also have multiple SSO credentials. This might happen when a user works with multiple organizations that each require SSO authentication for all members. In this case, there is still only one User object, but they would choose which organization's SSO identity provider to use when authenticating.

```d2 pad=50
direction: right;

user: "User"
org1_sso: "Organization 1 SSO"
org2_sso: "Organization 2 SSO"
user_profile: "Single User Profile"

user -> org1_sso: "SSO Credential 1"
user -> org2_sso: "SSO Credential 2"
org1_sso -> user_profile: "Linked"
org2_sso -> user_profile: "Linked"
```

When users sign in through an SSO identity provider for the first time, Scalekit checks if their email domain is verified. If verified, Scalekit automatically links the SSO credential to the user's existing account.

The email verification safety still applies. When the user signs in for the first time through an SSO identity provider where the user's email address is not a verified domain, the user is asked to verify their email before the SSO credential is linked to their account.

<Aside type="note" title="Multiple organizations">
  Users can belong to multiple organizations, each with their own SSO configuration. Scalekit maintains a single user profile while allowing users to authenticate through different organization identity providers.
</Aside>
