---
title: API keys
description: "Issue long-lived, revocable API keys scoped to organizations and users for programmatic access to your APIs"
sidebar:
  label: "API keys"
tags: [api-tokens, api-keys, m2m, authentication, bearer-tokens]
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
---

import { Aside, Steps, Tabs, TabItem, Card, CardGrid } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

Scalekit API keys let you give your customers long-lived, revocable credentials for programmatic access to your APIs. Each API key is scoped to an organization and optionally to a specific user, so you have fine-grained control over who can access what. Unlike [JWT-based M2M authentication](/authenticate/m2m/api-auth-quickstart/), API keys are simple bearer strings with no embedded claims — Scalekit handles all validation server-side.

Scalekit validates every API key in real time, which gives you two security advantages out of the box. Keys can be **validated immediately** after creation — there is no propagation delay. And keys can be **revoked instantly** — once you call invalidate, the very next validation request rejects the key. No waiting for expiry windows or maintaining revocation lists.

Scalekit API keys also support **user-level scoping**, which enables you to issue personal API keys tied to a specific user within an organization. Your API middleware can extract the `userId` from the validated key to enforce user-specific authorization — enabling personal access tokens, per-user rate limiting, and audit trails tied to individual users.

We recommend API keys when your customers need persistent credentials for integrations, CI/CD pipelines, service accounts, or any automation that calls your APIs. For short-lived JWTs with scopes and audience restrictions, use [M2M client credentials](/authenticate/m2m/api-auth-quickstart/) instead.

```d2 pad=36
shape: sequence_diagram

API Client
User
Your App
Scalekit

User -> Your App: Request API key
Your App -> Scalekit: Create token (organizationId, userId)
Scalekit -> Your App: API key + tokenId
Your App -> User: API key
User -> API Client: Configure API key
API Client -> Your App: Request with Authorization header
Your App -> Scalekit: Validate token
Scalekit -> Your App: Organization, user, and role info
Your App -> Your App: Process request
Your App -> API Client: Response
```

<Aside type="tip">
  The plain-text API key is returned **only at creation time**. Scalekit does not store the key and cannot retrieve it later. Instruct your users to copy and store the key securely before closing the creation dialog.
</Aside>

## Install the SDK

<InstallSDK />

Initialize the Scalekit client with your environment credentials:

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript title="Express.js" collapse={1-2}
import { ScalekitClient } from '@scalekit-sdk/node';

const scalekit = new ScalekitClient(
  process.env.SCALEKIT_ENVIRONMENT_URL,
  process.env.SCALEKIT_CLIENT_ID,
  process.env.SCALEKIT_CLIENT_SECRET
);
```

</TabItem>
<TabItem value="python" label="Python">

```python title="Flask" collapse={1-2}
import os
from scalekit import ScalekitClient

scalekit_client = ScalekitClient(
    env_url=os.environ["SCALEKIT_ENVIRONMENT_URL"],
    client_id=os.environ["SCALEKIT_CLIENT_ID"],
    client_secret=os.environ["SCALEKIT_CLIENT_SECRET"],
)
```

</TabItem>
<TabItem value="go" label="Go">

```go title="Gin" collapse={1-2}
import scalekit "github.com/scalekit-inc/scalekit-sdk-go/v2"

scalekitClient := scalekit.NewScalekitClient(
  os.Getenv("SCALEKIT_ENVIRONMENT_URL"),
  os.Getenv("SCALEKIT_CLIENT_ID"),
  os.Getenv("SCALEKIT_CLIENT_SECRET"),
)
```

</TabItem>
<TabItem value="java" label="Java">

```java title="Spring Boot" collapse={1-2}
import com.scalekit.ScalekitClient;

ScalekitClient scalekitClient = new ScalekitClient(
    System.getenv("SCALEKIT_ENVIRONMENT_URL"),
    System.getenv("SCALEKIT_CLIENT_ID"),
    System.getenv("SCALEKIT_CLIENT_SECRET")
);
```

</TabItem>
</Tabs>

## Create a token

### Organization-scoped API key

Create an API key scoped to an organization. This is the most common pattern for service-to-service integrations where the API key represents access on behalf of an entire organization.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
try {
  const response = await scalekit.token.createToken(organizationId, {
    description: 'CI/CD pipeline token',
  });

  // Store securely — this value cannot be retrieved again after creation
  const opaqueToken = response.token;
  // Stable identifier for management operations (format: apit_xxxxx)
  const tokenId = response.tokenId;
} catch (error) {
  console.error('Failed to create token:', error.message);
}
```

</TabItem>
<TabItem value="python" label="Python">

```python
try:
    response = scalekit_client.tokens.create_token(
        organization_id=organization_id,
        description="CI/CD pipeline token",
    )

    # SDK returns (response, metadata) tuple — access response at index 0
    opaque_token = response[0].token  # store this securely
    token_id = response[0].token_id   # format: apit_xxxxx
except Exception as e:
    print(f"Failed to create token: {e}")
```

</TabItem>
<TabItem value="go" label="Go">

```go
response, err := scalekitClient.Token().CreateToken(
  ctx, organizationId, scalekit.CreateTokenOptions{
    Description: "CI/CD pipeline token",
  },
)
if err != nil {
  log.Printf("Failed to create token: %v", err)
  return
}

// Store securely — this value cannot be retrieved again after creation
opaqueToken := response.Token
// Stable identifier for management operations (format: apit_xxxxx)
tokenId := response.TokenId
```

</TabItem>
<TabItem value="java" label="Java">

```java
try {
    CreateTokenResponse response = scalekitClient.tokens().create(organizationId);

    // Store securely — this value cannot be retrieved again after creation
    String opaqueToken = response.getToken();
    // Stable identifier for management operations (format: apit_xxxxx)
    String tokenId = response.getTokenId();
} catch (Exception e) {
    System.err.println("Failed to create token: " + e.getMessage());
}
```

</TabItem>
</Tabs>

### User-scoped API key

Scope an API key to a specific user within an organization to enable personal access tokens, per-user audit trails, and user-level rate limiting. You can also attach custom claims as key-value metadata.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
try {
  const userToken = await scalekit.token.createToken(organizationId, {
    userId: 'usr_12345',
    customClaims: {
      team: 'engineering',
      environment: 'production',
    },
    description: 'Deployment service token',
  });

  const opaqueToken = userToken.token;
  const tokenId = userToken.tokenId;
} catch (error) {
  console.error('Failed to create token:', error.message);
}
```

</TabItem>
<TabItem value="python" label="Python">

```python
try:
    user_token = scalekit_client.tokens.create_token(
        organization_id=organization_id,
        user_id="usr_12345",
        custom_claims={
            "team": "engineering",
            "environment": "production",
        },
        description="Deployment service token",
    )

    opaque_token = user_token[0].token
    token_id = user_token[0].token_id
except Exception as e:
    print(f"Failed to create token: {e}")
```

</TabItem>
<TabItem value="go" label="Go">

```go
userToken, err := scalekitClient.Token().CreateToken(
  ctx, organizationId, scalekit.CreateTokenOptions{
    UserId:      "usr_12345",
    CustomClaims: map[string]string{
      "team":        "engineering",
      "environment": "production",
    },
    Description: "Deployment service token",
  },
)
if err != nil {
  log.Printf("Failed to create user token: %v", err)
  return
}

opaqueToken := userToken.Token
tokenId := userToken.TokenId
```

</TabItem>
<TabItem value="java" label="Java">

```java
try {
    Map<String, String> customClaims = Map.of(
        "team", "engineering",
        "environment", "production"
    );

    CreateTokenResponse userToken = scalekitClient.tokens().create(
        organizationId, "usr_12345", customClaims, null, "Deployment service token"
    );

    String opaqueToken = userToken.getToken();
    String tokenId = userToken.getTokenId();
} catch (Exception e) {
    System.err.println("Failed to create token: " + e.getMessage());
}
```

</TabItem>
</Tabs>

The response contains three fields:

| Field | Description |
|-------|-------------|
| `token` | The API key string. **Returned only at creation.** |
| `token_id` | A stable identifier (format: `apit_xxxxx`) for referencing the token in management operations. |
| `token_info` | Metadata including organization, user, custom claims, and timestamps. |

## Validate a token

Scalekit validates the API key server-side and returns its associated context.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
try {
  const result = await scalekit.token.validateToken(opaqueToken);

  const orgId = result.tokenInfo.organizationId;
  const userId = result.tokenInfo.userId;
  const claims = result.tokenInfo.customClaims;
} catch (error) {
  // Token is invalid, expired, or revoked
  console.error('Token validation failed:', error.message);
}
```

</TabItem>
<TabItem value="python" label="Python">

```python
try:
    result = scalekit_client.tokens.validate_token(token=opaque_token)

    org_id = result[0].token_info.organization_id
    user_id = result[0].token_info.user_id
    claims = result[0].token_info.custom_claims
except Exception:
    # Token is invalid, expired, or revoked
    print("Token validation failed")
```

</TabItem>
<TabItem value="go" label="Go">

```go
result, err := scalekitClient.Token().ValidateToken(ctx, opaqueToken)
if err != nil {
  // Token is invalid, expired, or revoked
  log.Printf("Token validation failed: %v", err)
  return
}

orgId := result.TokenInfo.OrganizationId
userId := result.TokenInfo.UserId
claims := result.TokenInfo.CustomClaims
```

</TabItem>
<TabItem value="java" label="Java">

```java
try {
    ValidateTokenResponse result = scalekitClient.tokens().validate(opaqueToken);

    String orgId = result.getTokenInfo().getOrganizationId();
    String userId = result.getTokenInfo().getUserId();
    Map<String, String> claims = result.getTokenInfo().getCustomClaimsMap();
} catch (Exception e) {
    // Token is invalid, expired, or revoked
    System.err.println("Token validation failed: " + e.getMessage());
}
```

</TabItem>
</Tabs>

Validation fails with an error if the API key is invalid, expired, or has been revoked. Use this behavior to reject unauthorized requests in your API middleware.

### Access roles and organization details

The validated token also includes roles assigned to the user and external identifiers for the organization. Use these to make authorization decisions without additional lookups.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
const result = await scalekit.token.validateToken(opaqueToken);

// Roles assigned to the user
const roles = result.tokenInfo.roles;

// External identifiers for mapping to your system
const externalOrgId = result.tokenInfo.organizationExternalId;
const externalUserId = result.tokenInfo.userExternalId;
```

</TabItem>
<TabItem value="python" label="Python">

```python
result = scalekit_client.tokens.validate_token(token=opaque_token)

# Roles assigned to the user
roles = result[0].token_info.roles

# External identifiers for mapping to your system
external_org_id = result[0].token_info.organization_external_id
external_user_id = result[0].token_info.user_external_id
```

</TabItem>
<TabItem value="go" label="Go">

```go
result, err := scalekitClient.Token().ValidateToken(ctx, opaqueToken)
if err != nil {
  log.Printf("Token validation failed: %v", err)
  return
}

// Roles assigned to the user
roles := result.TokenInfo.Roles

// External identifiers for mapping to your system
externalOrgId := result.TokenInfo.OrganizationExternalId
externalUserId := result.TokenInfo.UserExternalId
```

</TabItem>
<TabItem value="java" label="Java">

```java
ValidateTokenResponse result = scalekitClient.tokens().validate(opaqueToken);

// Roles assigned to the user
List<String> roles = result.getTokenInfo().getRolesList();

// External identifiers for mapping to your system
String externalOrgId = result.getTokenInfo().getOrganizationExternalId();
String externalUserId = result.getTokenInfo().getUserExternalId();
```

</TabItem>
</Tabs>

<Aside type="note">
  Roles are available when you use [Full Stack Authentication](/authenticate/fsa/quickstart/) with [role-based access control](/authenticate/authz/overview/). Assign roles to users through the Scalekit dashboard or API.
</Aside>

### Access custom metadata

Custom claims attached during token creation are returned in the validation response. Use them for fine-grained authorization decisions without additional database lookups.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
const result = await scalekit.token.validateToken(opaqueToken);

const team = result.tokenInfo.customClaims?.team;
const environment = result.tokenInfo.customClaims?.environment;

// Use metadata for authorization
if (environment !== 'production') {
  return res.status(403).json({ error: 'Production access required' });
}
```

</TabItem>
<TabItem value="python" label="Python">

```python
result = scalekit_client.tokens.validate_token(token=opaque_token)

team = result[0].token_info.custom_claims.get("team")
environment = result[0].token_info.custom_claims.get("environment")

# Use metadata for authorization
if environment != "production":
    return jsonify({"error": "Production access required"}), 403
```

</TabItem>
<TabItem value="go" label="Go">

```go
result, err := scalekitClient.Token().ValidateToken(ctx, opaqueToken)
if err != nil {
  log.Printf("Token validation failed: %v", err)
  return
}

team := result.TokenInfo.CustomClaims["team"]
environment := result.TokenInfo.CustomClaims["environment"]

// Use metadata for authorization
if environment != "production" {
  c.JSON(403, gin.H{"error": "Production access required"})
  return
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
ValidateTokenResponse result = scalekitClient.tokens().validate(opaqueToken);

String team = result.getTokenInfo().getCustomClaimsMap().get("team");
String environment = result.getTokenInfo().getCustomClaimsMap().get("environment");

// Use metadata for authorization
if (!"production".equals(environment)) {
    return ResponseEntity.status(403).body(Map.of("error", "Production access required"));
}
```

</TabItem>
</Tabs>

## List tokens

Retrieve all active API keys for an organization. Use pagination to handle large result sets, and filter by `userId` to find keys scoped to a specific user.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
// List tokens for an organization
const response = await scalekit.token.listTokens(organizationId, {
  pageSize: 10,
});

for (const token of response.tokens) {
  console.log(token.tokenId, token.description);
}

// Paginate through results
if (response.nextPageToken) {
  const nextPage = await scalekit.token.listTokens(organizationId, {
    pageSize: 10,
    pageToken: response.nextPageToken,
  });
}

// Filter tokens by user
const userTokens = await scalekit.token.listTokens(organizationId, {
  userId: 'usr_12345',
});
```

</TabItem>
<TabItem value="python" label="Python">

```python
# List tokens for an organization
response = scalekit_client.tokens.list_tokens(
    organization_id=organization_id,
    page_size=10,
)

for token in response[0].tokens:
    print(token.token_id, token.description)

# Paginate through results
if response[0].next_page_token:
    next_page = scalekit_client.tokens.list_tokens(
        organization_id=organization_id,
        page_size=10,
        page_token=response[0].next_page_token,
    )

# Filter tokens by user
user_tokens = scalekit_client.tokens.list_tokens(
    organization_id=organization_id,
    user_id="usr_12345",
)
```

</TabItem>
<TabItem value="go" label="Go">

```go
// List tokens for an organization
response, err := scalekitClient.Token().ListTokens(
  ctx, organizationId, scalekit.ListTokensOptions{
    PageSize: 10,
  },
)

for _, token := range response.Tokens {
  fmt.Println(token.TokenId, token.GetDescription())
}

// Paginate through results
if response.NextPageToken != "" {
  nextPage, err := scalekitClient.Token().ListTokens(
    ctx, organizationId, scalekit.ListTokensOptions{
      PageSize:  10,
      PageToken: response.NextPageToken,
    },
  )
}

// Filter tokens by user
userTokens, err := scalekitClient.Token().ListTokens(
  ctx, organizationId, scalekit.ListTokensOptions{
    UserId: "usr_12345",
  },
)
```

</TabItem>
<TabItem value="java" label="Java">

```java
// List tokens for an organization
ListTokensResponse response = scalekitClient.tokens().list(organizationId, 10, null);

for (Token token : response.getTokensList()) {
    System.out.println(token.getTokenId() + " " + token.getDescription());
}

// Paginate through results
if (!response.getNextPageToken().isEmpty()) {
    ListTokensResponse nextPage = scalekitClient.tokens().list(
        organizationId, 10, response.getNextPageToken()
    );
}

// Filter tokens by user
ListTokensResponse userTokens = scalekitClient.tokens().list(
    organizationId, "usr_12345", 10, null
);
```

</TabItem>
</Tabs>

The response includes `totalCount` for the total number of matching tokens and `nextPageToken` / `prevPageToken` cursors for navigating pages.

## Invalidate a token

Revoke an API key to immediately prevent it from being used. Invalidation takes effect instantly — any subsequent validation request for this key will fail.

This operation is **idempotent**: calling invalidate on an already-revoked key succeeds without error.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript
// Invalidate by API key string
await scalekit.token.invalidateToken(opaqueToken);

// Or invalidate by token_id (useful when you store tokenId for lifecycle management)
await scalekit.token.invalidateToken(tokenId);
```

</TabItem>
<TabItem value="python" label="Python">

```python
# Invalidate by API key string
scalekit_client.tokens.invalidate_token(token=opaque_token)

# Or invalidate by token_id (useful when you store token_id for lifecycle management)
scalekit_client.tokens.invalidate_token(token=token_id)
```

</TabItem>
<TabItem value="go" label="Go">

```go
// Invalidate by API key string
err := scalekitClient.Token().InvalidateToken(ctx, opaqueToken)

// Or invalidate by token_id (useful when you store tokenId for lifecycle management)
err = scalekitClient.Token().InvalidateToken(ctx, tokenId)
```

</TabItem>
<TabItem value="java" label="Java">

```java
// Invalidate by API key string
scalekitClient.tokens().invalidate(opaqueToken);

// Or invalidate by token_id (useful when you store tokenId for lifecycle management)
scalekitClient.tokens().invalidate(tokenId);
```

</TabItem>
</Tabs>

## Protect your API endpoints

Add API key validation as middleware in your API server. Extract the Bearer token from the `Authorization` header, validate it through Scalekit, and use the returned `token_info` for authorization decisions.

<Tabs syncKey="tech-stack">
<TabItem value="node" label="Node.js">

```javascript title="Express.js"
async function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    // Reject requests without credentials to prevent unauthorized access
    return res.status(401).json({ error: 'Missing authorization token' });
  }

  try {
    // Server-side validation — Scalekit checks token status in real time
    const result = await scalekit.token.validateToken(token);
    // Attach token context to the request for downstream handlers
    req.tokenInfo = result.tokenInfo;
    next();
  } catch (error) {
    // Revoked, expired, or malformed tokens are rejected immediately
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// Apply to protected routes
app.get('/api/resources', authenticateToken, (req, res) => {
  const orgId = req.tokenInfo.organizationId;
  // Serve resources scoped to this organization
});
```

</TabItem>
<TabItem value="python" label="Python">

```python title="Flask"
from functools import wraps
from flask import request, jsonify, g

def authenticate_token(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get("Authorization", "")
        if not auth_header.startswith("Bearer "):
            # Reject requests without credentials to prevent unauthorized access
            return jsonify({"error": "Missing authorization token"}), 401

        token = auth_header.split(" ")[1]

        try:
            # Server-side validation — Scalekit checks token status in real time
            result = scalekit_client.tokens.validate_token(token=token)
            # Attach token context for downstream handlers
            g.token_info = result[0].token_info
        except Exception:
            # Revoked, expired, or malformed tokens are rejected immediately
            return jsonify({"error": "Invalid or expired token"}), 401

        return f(*args, **kwargs)
    return decorated

# Apply to protected routes
@app.route("/api/resources")
@authenticate_token
def get_resources():
    org_id = g.token_info.organization_id
    # Serve resources scoped to this organization
```

</TabItem>
<TabItem value="go" label="Go">

```go title="Gin"
func AuthenticateToken(scalekitClient scalekit.Scalekit) gin.HandlerFunc {
  return func(c *gin.Context) {
    authHeader := c.GetHeader("Authorization")
    if !strings.HasPrefix(authHeader, "Bearer ") {
      // Reject requests without credentials to prevent unauthorized access
      c.JSON(401, gin.H{"error": "Missing authorization token"})
      c.Abort()
      return
    }

    token := strings.TrimPrefix(authHeader, "Bearer ")

    // Server-side validation — Scalekit checks token status in real time
    result, err := scalekitClient.Token().ValidateToken(c.Request.Context(), token)
    if err != nil {
      // Revoked, expired, or malformed tokens are rejected immediately
      c.JSON(401, gin.H{"error": "Invalid or expired token"})
      c.Abort()
      return
    }

    // Attach token context for downstream handlers
    c.Set("tokenInfo", result.TokenInfo)
    c.Next()
  }
}

// Apply to protected routes
r.GET("/api/resources", AuthenticateToken(scalekitClient), func(c *gin.Context) {
  tokenInfo := c.MustGet("tokenInfo").(*scalekit.TokenInfo)
  orgId := tokenInfo.OrganizationId
  // Serve resources scoped to this organization
})
```

</TabItem>
<TabItem value="java" label="Java">

```java title="Spring Boot"
@Component
public class TokenAuthFilter extends OncePerRequestFilter {
    private final ScalekitClient scalekitClient;

    public TokenAuthFilter(ScalekitClient scalekitClient) {
        this.scalekitClient = scalekitClient;
    }

    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            // Reject requests without credentials to prevent unauthorized access
            response.sendError(401, "Missing authorization token");
            return;
        }

        String token = authHeader.substring(7);

        try {
            // Server-side validation — Scalekit checks token status in real time
            ValidateTokenResponse result = scalekitClient.tokens().validate(token);
            // Attach token context for downstream handlers
            request.setAttribute("tokenInfo", result.getTokenInfo());
            filterChain.doFilter(request, response);
        } catch (Exception e) {
            // Revoked, expired, or malformed tokens are rejected immediately
            response.sendError(401, "Invalid or expired token");
        }
    }
}

// Access in your controller
@GetMapping("/api/resources")
public ResponseEntity<?> getResources(HttpServletRequest request) {
    Token tokenInfo = (Token) request.getAttribute("tokenInfo");
    String orgId = tokenInfo.getOrganizationId();
    // Serve resources scoped to this organization
}
```

</TabItem>
</Tabs>

## Best practices

<CardGrid>
  <Card title="Store API keys securely">
    We recommend treating API keys like passwords. Store them in encrypted secrets managers or environment variables. Never log keys, commit them to version control, or expose them in client-side code.
  </Card>
  <Card title="Set expiry for time-limited access">
    Use the `expiry` parameter for keys that should automatically become invalid after a set period. This limits the blast radius if a key is compromised.
  </Card>
  <Card title="Use custom claims for context">
    Attach metadata like `team`, `environment`, or `service` as custom claims. Your API middleware can use these claims for fine-grained authorization without additional database lookups.
  </Card>
  <Card title="Rotate keys safely">
    To rotate an API key: create a new key, update the consuming service to use the new key, verify the new key works, then invalidate the old key. This avoids downtime during rotation.
  </Card>
</CardGrid>

## Next steps

You now have the building blocks to issue, validate, and manage API keys in your application. For short-lived, scoped authentication between services, see [M2M authentication with client credentials](/authenticate/m2m/api-auth-quickstart/). To control what each key can access, configure [scopes for your M2M clients](/guides/m2m/scopes/).
