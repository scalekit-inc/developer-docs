---
title: Single page application
description: "Implement Multi Application SSO for single page apps using Authorization Code with PKCE"
sidebar:
  label: "Single Page App"
tableOfContents: true
prev:
  label: "Web application"
  link: "/authenticate/fsa/multiapp/web-app"
next:
  label: "Desktop & mobile apps"
  link: "/authenticate/fsa/multiapp/native-app"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 { font-size: var(--sl-text-xl); }
      .sl-markdown-content h3 { font-size: var(--sl-text-lg); }
seeAlso:
  items:
    - title: "Browse example apps"
      icon: "app"
      url: "https://github.com/scalekit-inc/multiapp-demo"
  expanded: true
  label: "See also"
---

import { Steps } from '@astrojs/starlight/components';

A single page application (SPA) is a **frontend-only** application. It is a **public OAuth client**, so it does **not** use a `client_secret`. The SPA initiates login, handles the callback, and performs the authorization code exchange directly from the browser using **Authorization Code with PKCE**.

:::tip
ðŸ‘‰ [**Check out the example apps on GitHub**](https://github.com/scalekit-inc/multiapp-demo) to see Web, Single page, Desktop, and Mobile apps sharing a single Scalekit session.
:::

This guide expands the four-step flow from the overview specifically for **single page applications**. SPAs use a `client_id` only, and include PKCE parameters to complete the authorization code flow securely.

Note: This guide assumes you already have your `ENV_URL` and `client_id`. If not, see how to create and manage applications [here](/authenticate/fsa/multiapp/manage-apps)

## High-level flow

```d2
shape: sequence_diagram

User
"Single page app (browser)"
Scalekit

User -> "Single page app (browser)": Click "Login"
"Single page app (browser)" -> Scalekit: Redirect to /oauth/authorize \n (+ state + PKCE challenge)
Scalekit -> "Single page app (browser)": Redirect to /callback with code + state
"Single page app (browser)" -> Scalekit: POST /oauth/token
Scalekit -> "Single page app (browser)": access_token, refresh_token, id_token
"Single page app (browser)" -> "Single page app (browser)": Store tokens + continue
```

## Step-by-step implementation

<Steps>

1. ## Initiate login or signup

   Login begins when your SPA redirects the user to Scalekit's hosted login page using the authorization endpoint.

   ```sh
   <ENV_URL>/oauth/authorize?
     response_type=code&
     client_id=<CLIENT_ID>&
     redirect_uri=<CALLBACK_URL>&
     scope=openid+profile+email+offline_access&
     state=<RANDOM_STATE>&
     code_challenge=<PKCE_CODE_CHALLENGE>&
     code_challenge_method=S256
   ```

   Your SPA should generate and store:
   - `state` (so you can validate the callback)
   - `code_verifier` (kept locally), and the derived `code_challenge` (sent on `/oauth/authorize`)

   For detailed definition of the base parameters, refer [here](/authenticate/fsa/implement-login)

2. ## Handle the callback and complete login

   After authentication, Scalekit redirects the user back to your callback URL with `code` and `state`.

   Your SPA must:
   - Validate the returned `state`
   - Handle any error parameters
   - Exchange the authorization code for tokens (including the `code_verifier`)

   ```sh
   POST <ENV_URL>/oauth/token
   Content-Type: application/x-www-form-urlencoded

   grant_type=authorization_code&
   client_id=<CLIENT_ID>&
   code=<CODE>&
   redirect_uri=<CALLBACK_URL>&
   code_verifier=<PKCE_CODE_VERIFIER>
   ```

   ```json
   {
     "access_token": "...",
     "refresh_token": "...",
     "id_token": "...",
     "expires_in": 299
   }
   ```

   Note: Authorization codes are single-use and short-lived.

3. ## Manage sessions and token refresh

   Once tokens are issued, your SPA is responsible for session management.

   **Token roles**
   - **Access token**: short-lived, used for authenticated requests
   - **Refresh token**: used to obtain new tokens
   - **ID token**: user identity claims and required for logout

   For SPAs, tokens are stored client-side (for example, in memory, session storage, or local storage) depending on your application needs.

   When an access token expires, request new tokens using the refresh token:

   ```sh
   POST <ENV_URL>/oauth/token
   Content-Type: application/x-www-form-urlencoded

   grant_type=refresh_token&
   client_id=<CLIENT_ID>&
   refresh_token=<REFRESH_TOKEN>
   ```

   Validate access tokens by checking:
   - Verify the token signature using Scalekitâ€™s public keys (JWKS).
   - `iss` matches your Scalekit environment
   - `aud` matches your `client_id`
   - `exp` and `iat` are valid

   Public keys for verification are available at:

   ```sh
   <ENV_URL>/keys
   ```

4. ## Implement logout

   Logging out requires clearing your application session and invalidating the Scalekit session.

   Your logout action should:
   - Extract the ID token (if available)
   - Clear locally stored tokens
   - Redirect the browser to Scalekit's logout endpoint

   ```sh
   <ENV_URL>/oidc/logout?
     id_token_hint=<ID_TOKEN>&
     post_logout_redirect_uri=<POST_LOGOUT_REDIRECT_URI>
   ```

   Logout must be performed via a **browser redirect** so that Scalekit can identify and terminate the session.

</Steps>
