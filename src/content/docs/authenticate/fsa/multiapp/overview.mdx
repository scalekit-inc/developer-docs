---
title: Multi-App Authentication
description: "One login for all your apps. Share authentication across web, mobile, and desktop applications with a unified session."
sidebar:
  label: "Overview"
tableOfContents: true
next:
  label: "Web App"
  link: "/authenticate/fsa/multiapp/web-app"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
seeAlso:
  items:
    - title: "Browse example apps"
      icon: "app"
      url: "https://github.com/scalekit-inc/multiapp-demo"
  expanded: true
  label: "See also"
---

import { Steps, LinkCard } from '@astrojs/starlight/components';
import Subtitle from '@/components/ui/Subtitle.astro'

<Subtitle>One login across your web app, SPA, mobile app, and desktop client.</Subtitle>

Your product likely spans multiple applicationsâ€”a web dashboard, a mobile app, maybe a desktop client. Without shared authentication, users sign in separately to each one. With Scalekit's Multi-App Authentication, you register each application as an OAuth client, and they all share a single user session. Users authenticate once and gain access everywhere.

:::tip
ðŸ‘‰ [**Check out the example apps on GitHub**](https://github.com/scalekit-inc/multiapp-demo) to see this in action with Web, SPA, Desktop, and Mobile apps sharing one session.
:::

## Why use this?

Managing separate login systems per application creates real problems:

- **Friction for users**: Repeated logins across your product suite
- **Security gaps**: Inconsistent session handling and token management
- **Engineering overhead**: Multiple auth implementations to build and maintain

## How it works

1. Register each application as an OAuth client in Scalekit
2. User logs into any one of your apps
3. Scalekit creates a session tied to that user
4. Other apps detect the existing sessionâ€”no login prompt
5. Logout from any app terminates the shared session

## Choose your app type

| App Type | Has Backend? | Uses Secret? | Auth Flow | Guide |
|----------|:------------:|:------------:|-----------|-------|
| Web app (Express, Django, Rails) | âœ“ | âœ“ | Authorization Code | [Web App â†’](/authenticate/fsa/multiapp/web-app) |
| SPA (React, Vue, Angular) | âœ— | âœ— | Auth Code + PKCE | [SPA â†’](/authenticate/fsa/multiapp/single-page-app) |
| Mobile (iOS, Android) | âœ— | âœ— | Auth Code + PKCE | [Mobile & Desktop â†’](/authenticate/fsa/multiapp/native-app) |
| Desktop (Electron, Tauri) | âœ— | âœ— | Auth Code + PKCE | [Mobile & Desktop â†’](/authenticate/fsa/multiapp/native-app) |

## How session sharing works

Each application is registered separately in Scalekit and receives its own OAuth client, with credentials based on the application type:

- **Web app** â†’ `client_id: webc_xxx` + `client_secret`
- **Single page app** â†’ `client_id: spac_xxx`
- **Desktop app** â†’ `client_id: ntvc_xxx`
- **Mobile app** â†’ `client_id: ntvc_xxx`

Even though each app has a **different** `client_id`, they all rely on the **same Scalekit user session**. Using separate clients per app gives you clearer audit logs, safer scope boundaries, and easier long-term maintenance.

```d2
shape: sequence_diagram

User
"App A"
"App B"
Scalekit

User -> "App A": Click "Login"
"App A" -> Scalekit: /oauth/authorize
Scalekit -> "App A": Authorization code
"App A" -> Scalekit: /oauth/token
Scalekit -> "App A": access_token, refresh_token, id_token

User -> "App B": Open app
"App B" -> Scalekit: /oauth/authorize
Scalekit -> "App B": Authorization code \n (Session already exists)
"App B" -> Scalekit: /oauth/token
Scalekit -> "App B": access_token, refresh_token, id_token

User -> "App B": Logout
"App B" -> Scalekit: /oidc/logout
Scalekit -> "App A": Session revoked
```

Revoking the Scalekit session does not automatically clear your applicationâ€™s local state. Each application is responsible for terminating its own session and clearing stored tokens. A common and reliable signal for logout is a failed refresh token exchange, which indicates that the session has been revoked at the Scalekit side.

For proactive sign-out across all applications, configure backchannel logout URIs so Scalekit can notify each app when a shared session is terminated.

## High-level implementation flow

Once your applications are registered, each app follows the same OAuth-based authentication flow.

### 1. Initiate login or signup

Begin authentication by redirecting the user to the `/oauth/authorize` endpoint with the appropriate parameters.  
Typical scopes include `openid`, `email`, `profile`, and `offline_access` (if refresh tokens are required). Scalekit handles user authentication.

### 2. Handle the callback

After authentication completes, Scalekit redirects the user to your `/callback` endpoint with `code` and `state`.  
Your application exchanges the authorization code at the `/oauth/token` endpoint to obtain tokens.

### 3. Manage sessions and token refresh

After receiving the access token, validate it by checking the issuer, audience (which must include the applicationâ€™s `client_id`), `iat`, and `exp`.  
Store tokens securely and use the `/oauth/token` endpoint with the `refresh_token` grant to obtain new access, refresh, and ID tokens when needed.

### 4. Implement logout

Initiate logout by calling the `/oidc/logout` endpoint with the relevant parameters. Clear your local application session when refresh token exchange fails or configure backchannel logout to proactively sign users out from all applications sharing the same session.

## Detailed implementation guides

Choose your application type for step-by-step implementation details and app-specific considerations.

<div>
  <LinkCard
    href="/authenticate/fsa/multiapp/web-app"
    title="Web application"
    description="Server-rendered or backend-driven apps using client_id and client_secret."
  />

  <LinkCard
    href="/authenticate/fsa/multiapp/single-page-app"
    title="Single page application"
    description="Frontend-only apps using Authorization Code with PKCE."
  />

  <LinkCard
    href="/authenticate/fsa/multiapp/native-app"
    title="Mobile & desktop application"
    description="iOS, Android, and desktop apps using PKCE-based OAuth flows."
  />
</div>

## Create apps in Scalekit

To enable multi-app authentication, each application must be registered in Scalekit. You can create and manage applications from the Scalekit dashboard:

<LinkCard
  href="/authenticate/fsa/multiapp/manage-apps"
  title="Manage applications"
  description="Create and manage multiple applications that share a single user session."
/>

Note: Public clients such as SPAs and native apps must never embed client secrets. These applications rely on Authorization Code with PKCE instead.

## Key takeaways

- Each application has its own OAuth client but shares a single Scalekit user session
- Any application can initiate login or logout
- OAuth scopes and token validation rules remain consistent across apps
- Refresh token failure is a reliable signal of session revocation
- Backchannel logout enables proactive sign-out across all connected applications

## Troubleshooting

### "Invalid redirect_uri" error

The exact URI (including trailing slashes and query parameters) must match what's configured in **Dashboard > Developers > Applications > [Your App] > Redirects**. Common mismatches include:

- `http` vs `https`
- Missing or extra trailing slash
- Different port numbers in development

### Session not shared between apps

Verify all applications are registered in the same Scalekit environment. Apps in different environments maintain separate session pools and cannot share authentication state.

### Refresh token rejected

The Scalekit session may have been revoked from another application, or the refresh token has expired. Redirect the user to login again to establish a new session.

### User prompted to login on every app

Check that:
1. All apps use the same Scalekit environment URL
2. The browser allows third-party cookies (required for session detection)
3. The user is using the same browser across apps
