---
title: Intercept authentication flows
description: Apply decision checks at key points in the authentication flow
sidebar:
  label: Intercept auth flows
next:
  label: Interceptor examples by trigger
  link: /guides/interceptor-scenarios/
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
seeAlso:
  items:
   - title: "See example interceptor scenarios"
     icon: "book"
     url: "/guides/interceptor-scenarios/"
  label: "Example scenarios"
---

import { Aside, Steps, TabItem, Tabs } from '@astrojs/starlight/components';
import IconTdesignSequence from '~icons/tdesign/sequence'

Execute custom business logic during sign-up or login processes. For example, you can integrate with external systems to validate user existence before allowing login, or prevent sign-ups originating from suspicious IP addresses.

Scalekit calls your application at key trigger points during authentication flows and waits for an ALLOW or DENY response to determine whether to continue with the authentication process. For example, one trigger point occurs immediately before a user signs up for your application. We'll explore more trigger points throughout this guide.


```d2
title: "Example of pre-signup interceptor " {
  near: top-center
  shape: text
  style.font-size: 16
}

shape: sequence_diagram

User -> Your app: Attempts sign-up
Your app -> Scalekit: Detects pre-signup trigger
Scalekit -> Your app: POST /auth/interceptors/pre-signup
Your app -> Your app: Process the request: allow IP address?
Your app -> Scalekit: Decision ALLOW or DENY
Scalekit -> User: Proceed or block sign-up

style: {
  font-size: 14
}
```

See

| Trigger point | When it runs |
|----------------|-------------|
| Pre-signup | Before a user creates a new organization |
| Pre-session creation | Before session tokens are issued for a user |
| Pre-user invitation | Before an invitation is created or sent for a new organization member |
| Pre-M2M token creation | Before issuing a machine-to-machine access token |

#### Register an interceptor

In the Scalekit dashboard, register an interceptor at a trigger point from the **Interceptors** tab.

<details>
<summary> Interceptors page </summary>
![Interceptors settings in the Scalekit dashboard](@/assets/docs/auth-flow-interceptors/add-interceptor-page.png)
</details>

<br />

<Steps>


 1. Enter a descriptive name, choose a trigger point, and provide the HTTPS endpoint that will receive POST requests.
 2. Set the timeout for your app's response.
 3. Choose the fallback behavior if your app fails or times out (allow or block the flow).
 4. Click **Create**.
 5. Toggle **Enable** to activate the interceptor.

</Steps>

## Audit logs

Scalekit keeps a log of every interceptor request sent to your app and the response it returned. Use these logs to debug and troubleshoot issues.

![Interceptor logs in the dashboard](@/assets/docs/auth-flow-interceptors/logging.png)

Requests and responses generated by the "Test" button are not logged. This keeps production logs free of test data.


## Verify interceptor payloads

Scalekit sends POST requests to your registered interceptor endpoint. To ensure the request is coming from Scalekit and not a malicious actor, you should verify the request using the signing secret found in the Scalekit dashboard > Interceptors.

Here's how to verify interceptor requests using the Scalekit SDK:

<Tabs>
<TabItem label="Node.js">

```javascript
app.post('/auth/interceptors/pre-signup', async (req, res) => {
  // Parse the JSON body of the request
  const event = await req.json();

  // Get headers from the request
  const headers = req.headers;

  // Secret from Scalekit dashboard > Interceptors
  const secret = process.env.SCALEKIT_INTERCEPTOR_SECRET;

  try {
    // Verify the interceptor payload
    await scalekit.verifyInterceptorPayload(secret, headers, event);
  } catch (error) {
    return res.status(400).json({
      error: 'Invalid signature',
    });
  }
});
```
</TabItem>

<TabItem label="Python">

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/auth/interceptors/pre-signup")
async def api_interceptor(request: Request):
    # Get request data
    body = await request.body()

    # Extract interceptor headers
    headers = {
        'interceptor-id': request.headers.get('interceptor-id'),
        'interceptor-signature': request.headers.get('interceptor-signature'),
        'interceptor-timestamp': request.headers.get('interceptor-timestamp')
    }

    # Verify interceptor signature
    is_valid = scalekit.verify_interceptor_payload(
        secret='<secret>',
        headers=headers,
        payload=body
    )
    print(is_valid)

    return JSONResponse(
        status_code=201,
        content=''
    )
```
</TabItem>

<TabItem label="Go">

```go
mux.HandleFunc("POST /auth/interceptors/pre-signup", func(w http.ResponseWriter, r *http.Request) {
    interceptorSecret := os.Getenv("SCALEKIT_INTERCEPTOR_SECRET")

    // Read request body
    bodyBytes, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Prepare headers for verification
    headers := map[string]string{
        "interceptor-id":        r.Header.Get("interceptor-id"),
        "interceptor-signature": r.Header.Get("interceptor-signature"),
        "interceptor-timestamp": r.Header.Get("interceptor-timestamp"),
    }

    // Verify interceptor signature
    _, err = sc.VerifyInterceptorPayload(
        interceptorSecret,
        headers,
        bodyBytes
    )
    if err != nil {
        http.Error(w, err.Error(), http.StatusUnauthorized)
        return
    }
})
```
</TabItem>

<TabItem label="Java">

```java
@PostMapping("/auth/interceptors/pre-signup")
public String interceptor(@RequestBody String body, @RequestHeader Map<String, String> headers) {
  String secret = "<INTERCEPTOR SECRET>";

  // Verify interceptor signature
  boolean valid = scalekit.interceptor().verifyInterceptorPayload(secret, headers, body.getBytes());

  if (!valid) {
    return "error";
  }

  ObjectMapper mapper = new ObjectMapper();

  try {
    // Parse interceptor data
    JsonNode node = mapper.readTree(body);
    String interceptorType = node.get("type").asText();
    JsonNode data = node.get("data");

    // Handle pre-signup interceptor
    if ("PRE_SIGNUP".equals(interceptorType)) {
      handlePreSignup(data);
    }
  } catch (IOException e) {
    return "error";
  }

  return "ok";
}
```
</TabItem>
</Tabs>

## Testing interceptors

Open the **Test** tab on the Interceptors page. The left panel shows the request body sent to your endpoint, and the right panel shows your application's response.

Based on your application's response, you can decide to allow or deny the user auth flow to continue to sign up or log into your application. This allows for you to test and take the interceptors live in production.

![Interceptors test tab example](@/assets/docs/auth-flow-interceptors/test-example.png)

<Aside type='note' title='Generic error messages'>
  Scalekit shows a generic error to end users when:

  - Your interceptor returns `DENY` without an `error.message`.
  - The interceptor request fails or times out and the fail policy is set to "Fail closed".

  Messages shown:
  - "The request could not be completed due to a policy restriction. Please contact support for assistance."
  - "The request could not be completed due to a policy restriction. Please contact support@yourapp.com for assistance." (when a support email is configured)
</Aside>

For quick testing without building or deploying an endpoint, use a request bin service like <a href="https://beeceptor.com/" target="_blank" rel="noopener">Beeceptor</a> or <a href="https://requestbin.com/" target="_blank" rel="noopener">RequestBin</a>. These services provide temporary endpoints that capture incoming requests and let you configure responses, making them ideal for interceptor development and validation.
