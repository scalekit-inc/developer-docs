---
title: "Migrate SSO without IdP reconfiguration for customers"
description: "Learn how to coexist with external SSO providers while gradually migrating to Scalekit's SSO solution"
sidebar:
  label: 'SSO migration strategy'
  hidden: true
topic: 'sso'
tableOfContents: true
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
---

import { Steps, Aside, Badge } from '@astrojs/starlight/components'


Single Sign-On capability of your application allows users in your customer's organizations to access your application using their existing credentials. In this guide, you will migrate SSO connections to Scalekit without requiring customers to reconfigure their identity providers from their existing SSO provider solutions such as Auth0 or WorkOS.

### Prerequisites

1. You control DNS for your auth domain, and its CNAME points to your external SSO provider.
    ```d2 layout=dagre
    direction: right

    Customer's IdP Configuration -> Your Application's DNS <- External SSO Provider: auth.yourapp.com/rest/the/path
    ```
2. Scalekit is set up — you have <a href="https://app.scalekit.com" target="_blank" rel="noopener">signed up</a> and installed the <a href="https://docs.scalekit.com/fsa/quickstart/#install-the-scalekit-sdk" target="_blank" rel="noopener">Scalekit SDK</a>.

<Aside title='Verify custom domain configurations'>
 Some existing customers will have configured their identity provider with necessary settings such as **SP Entity ID** and **ACS URL**. These should start with a domain that you own such as `auth.yourapp.com/rest/of/the/path` where CNAME is correctly configured with your external SSO provider.
 </Aside>


## Approach to migrate SSO connections

Our main goal is to make sure your current SSO connections keep working seamlessly, while enabling new connections to be set up with Scalekit—giving you the flexibility to migrate to Scalekit whenever you're ready.


This primarily involves two key components:

<Steps>

1. The data migration of tenant resources such as organizations and users. We provide a data migration utility to automate this approach.
2. A SSO proxy service that routes SSO connections between your existing SSO provider and Scalekit. We can assist with a ready-to-deploy SSO proxy service that best suits your infrastructure.

</Steps>
<Aside type="tip" title="Migration assistance available">
  Scalekit offers specialized migration tools to streamline both data migration and SSO proxy configuration. For personalized assistance with your migration plan, <a href="https://docs.scalekit.com/support/contact-us/" target="_blank" rel="noopener">contact our support team</a>.
</Aside>


```d2 title="SSO proxy sequence diagram"
direction: right
shape: sequence_diagram

User: User
App: YourApp
SSOProxy: SSO Proxy {
  icon: "https://icons.terrastruct.com/gcp%2FProducts%20and%20services%2FNetworking%2FCloud%20Routes.svg"
}
WorkOS: SSO Provider
ScaleKit: ScaleKit
IDP: Identity Provider

SSOProxy.style.fill: yellow
App.style.fill: yellow


User -> App: SSO login request
App -> App: Check if organization has been migrated {style.animated: true}
App -> SSOProxy: Forward request

SSOProxy -> WorkOS: To External SSO Provider {style.animated: true}
WorkOS -> IDP: SAML/OIDC auth
IDP -> WorkOS: User details
WorkOS -> SSOProxy: Return user details

SSOProxy -> ScaleKit: To ScaleKit (Migrated tenant) {style.animated: true}
ScaleKit -> IDP: SAML/OIDC auth
IDP -> ScaleKit: User details
ScaleKit -> SSOProxy: Return user details

SSOProxy -> App: Forward user details {style.animated: true}
App -> User: Access granted
```


### SSO proxy implementation

The SSO proxy ensures those connections continue to work while you gradually migrate. This approach is ideal when you prefer a staged rollout—move organizations one by one or all at once with data migration utilty without forcing customers to reconfigure SSO connection settings in their IdP.

<Steps>
1. asdf

</Steps>

-------
<Steps>
1. **Add a conditional between external provider and Scalekit authorization URL generation**

   Decide per organization (for example, by domain, organization ID, or connection ID) whether to initiate SSO with the external provider or Scalekit. This enables both systems to co-exist during migration.

   ```javascript title="example: auth-server.js"
    const orgsOfWorkos = [
      {
        domain: 'megasoft.com',
        organizationId:
          process.env.WORKOS_ORG_ID || 'org_01K365D5XXSYX9Y26FBM70GK8K',
        label: 'WorkOS Organization',
      },
      {
        domain: 'example.com',
        organizationId: process.env.WORKOS_ORG_ID || 'org_test_idp',
        label: 'Example Organization',
      },
      // Add more organizations as needed
    ];

        app.post('/sso-login', (req, res) => {
      const { email } = req.body;
      let [, domain] = email.split('@');

        // Check for force Scalekit header
        const forceScalekitHeader =
          req.headers['x-force-sk-route'] || req.headers['X-Force-Sk-Route'];
        const shouldForceScalekit =
          forceScalekitHeader && forceScalekitHeader.toLowerCase() === 'yes';

        // If force Scalekit header is set to "yes", always use Scalekit
        if (shouldForceScalekit) {
          let options = Object.create({});
          options['loginHint'] = email;
          options['domain'] = domain; // Add domain parameter for Scalekit
          // Remove organizationId and use domain-based discovery instead
          // options['organizationId'] = 'org_86863029123154451';

          try {
            const authorizationUrl = scalekit.getAuthorizationUrl(
              redirectUri,
              options
            );
            console.log(
              `Force using Scalekit for domain: ${domain} (header override)`
            );
            console.log('Scalekit Authorization URL:', authorizationUrl);
            res.redirect(authorizationUrl);
            return;
          } catch (error) {
            console.error('Scalekit SSO login error:', error);
            res.render('sso-login', {
              error: 'An error occurred while initiating Scalekit SSO login',
            });
            return;
          }
        }

      // Check if the domain belongs to an organization that uses WorkOS
      const workosOrg = orgsOfWorkos.find((org) => org.domain === domain);

      if (workosOrg) {
        // Use WorkOS for this organization
        try {
          const authorizationUrl = workos.sso.getAuthorizationUrl({
            organization: workosOrg.organizationId,
            redirectUri: 'http://localhost:3000/from-workos/callback',
            clientId: workosClientId,
          });

          console.log(
            `Using WorkOS for domain: ${domain}, organization: ${workosOrg.label}`
          );
          console.log('WorkOS Authorization URL:', authorizationUrl);
          res.redirect(authorizationUrl);
        } catch (error) {
          console.error('WorkOS SSO login error:', error);
          res.render('sso-login', {
            error: 'An error occurred while initiating WorkOS SSO login',
          });
        }
      } else {
        // Use Scalekit for other domains
        let options = Object.create({});
        options['loginHint'] = email;
        options['domain'] = domain; // Add domain parameter for Scalekit
        // Remove organizationId and use domain-based discovery instead
        // options['organizationId'] = 'org_86863029123154451';c

        try {
          const authorizationUrl = scalekit.getAuthorizationUrl(
            redirectUri,
            options
          );
          console.log(`Using Scalekit for domain: ${domain}`);
          // Redirect the user to the authorization URL
          res.redirect(authorizationUrl);
        } catch (error) {
          console.error('Scalekit SSO login error:', error);
          res.render('sso-login', {
            error: 'An error occurred while initiating Scalekit SSO login',
          });
        }
      }
    });
   ```

2. **Redirect users to your SSO proxy domain**

   After choosing the provider, send users to your SSO proxy (fronted by your **CNAME**, for example `auth.yourapp.com`). Ensure your proxy is deployed and reachable before testing.

   ```text title="Register both callback endpoints"
   https://yourapp.com/auth/ext-provider/callback
   https://yourapp.com/auth/scalekit/callback
   ```

3. **Proxy rewrites authorization to external SSO provider**

   The proxy forwards requests to the external provider, preserving identifiers such as **`state`** and **`organization`**.

   ```bash title="Example external provider authorize request"
   GET https://api.external-provider.com/sso/authorize?response_type=code \
     &client_id=sk_example_123456 \
     &redirect_uri=https://yourapp.com/callback/external-provider \
     &state=external_provider \
     &organization=org_01EHZNVPK3SFK441A1RGBFSHRT
   ```

4. **IdP authenticates and posts the response to your CNAME (proxy)**

   Your customers' IdP is configured with ACS/redirect URLs under your domain (CNAME), so successful SAML/OIDC responses return to the SSO proxy, not directly to your app.

   ```text title="ACS example"
   https://auth.yourapp.com/sso/saml/acs/{connection_id}
   ```

5. **Map the entity ID (callback ID)** so the proxy knows to use the external provider

   Provide the proxy with your existing **external provider callback identifiers** (often opaque IDs). The proxy uses these to route the SAML/OIDC callback to the external provider for processing. You can store these in environment variables or a JSON mapping file.

   ```text title="Example opaque callback path"
   https://auth.yourapp.com/ivETDqla2SfNIsvUH4mqqq6UL
   ```

6. **Receive the authorization code at your app's callback and exchange with the external provider**

   The external provider completes the handshake and redirects to your app's registered callback. The proxy can add a sentinel **state** (for example, **`external_provider`**) so your app knows to exchange the code with the external provider and fetch the user profile.

   ```javascript title="callback-handler.js (external provider)"
   import express from "express";
   import { ExternalSSOProvider } from "external-sso-sdk";

   const app = express();
   const externalProvider = new ExternalSSOProvider(process.env.EXTERNAL_SSO_API_KEY);

   app.get("/auth/ext-provider/callback", async (req, res) => {
     const { code, state, error, error_description } = req.query;
     if (error) return res.status(400).json({ error, error_description });

     try {
       const result = await externalProvider.sso.getProfileAndToken({
         code,
         clientId: process.env.EXTERNAL_SSO_CLIENT_ID,
         clientSecret: process.env.EXTERNAL_SSO_CLIENT_SECRET,
         redirectUri: "https://yourapp.com/auth/ext-provider/callback",
       });
       // result.profile contains user details; create session
       return res.redirect("/dashboard");
     } catch (e) {
       return res.status(500).json({ error: "External code exchange failed" });
     }
   });
   ```

7. **Create a session and finish login**

   Validate the tokens, establish the session, and redirect the user to the appropriate page in your application.

</Steps>


### Wrap up SSO proxy to handle SSO with Scalekit <Badge type="note" text="Phase 2"/>


Once you create equivalent organizations in Scalekit for the ones you plan to migrate, the proxy can begin routing callbacks to Scalekit for those organizations while others continue on the external provider.

<Aside type="note">
  We're developing a migration utility that automatically detects your external SSO provider organizations and creates equivalent ones in Scalekit. This tool significantly reduces manual setup during migration. If you'd like early access to this utility, <a href="https://docs.scalekit.com/support/contact-us/">contact our support team</a>.
</Aside>

<Steps>
1. **Select provider per organization; route migrated organizations to Scalekit**

   Implement a provider selection check using your domain/organization/connection selector. For **organizations created in Scalekit**, choose the Scalekit branch and redirect the user to your **SSO proxy domain**.

2. **Scalekit manages the SSO connection and sends the user to the IdP**

   The customer's IdP configuration still points to your CNAME, so the successful SAML/OIDC response returns to the SSO proxy.

3. **Proxy rewrites the callback to Scalekit**

   The proxy uses the known legacy **callback ID** (from the earlier external provider) and issues a **307 redirect** to the Scalekit **Single Sign-On URL** for that organization in your Scalekit environment.

4. **Scalekit returns the authorization code to your Scalekit callback**

   Register a **separate callback URL** for Scalekit (recommended) so your app can clearly distinguish code exchanges from external provider vs. Scalekit flows.

5. **Identify the source and exchange the code with Scalekit**

   The proxy can set a sentinel **state** (for example, **`scalekit_p`**). When your app receives the code with this state, use **`scalekit.authenticateWithCode()`** or the **`/oauth/token`** endpoint to fetch ID and access tokens and the user's profile.

   ```javascript title="callback-handler.js (Scalekit)"
   import express from "express";
   import { ScalekitClient } from "@scalekit-sdk/node";

   const app = express();
   const scalekit = new ScalekitClient(
     process.env.SCALEKIT_ENVIRONMENT_URL,
     process.env.SCALEKIT_CLIENT_ID,
     process.env.SCALEKIT_CLIENT_SECRET
   );

   app.get("/auth/scalekit/callback", async (req, res) => {
     const { code, error, error_description } = req.query;
     if (error) return res.status(400).json({ error, error_description });

     try {
       const auth = await scalekit.authenticateWithCode(
         code,
         "https://yourapp.com/auth/scalekit/callback"
       );
       // auth.user contains user details; create session
       return res.redirect("/dashboard");
     } catch (e) {
       return res.status(500).json({ error: "Scalekit code exchange failed" });
     }
   });
   ```

6. **Complete login and session**

   Validate tokens, create the session, and proceed to your post-login route.

</Steps>


<Aside type="note">
  <p>
    Setting up an SSO proxy can be streamlined based on your infrastructure:
  </p>
  <ul>
    <li>Ready to deploy SSO proxy setup on AWS Lambda</li>
    <li>DNS configuration assistance with Cloudflare</li>
    <li>Custom infrastructure requirements</li>
  </ul>
  <p>
    For any technical assistance with your specific environment or infrastructure needs, please <a href="https://docs.scalekit.com/support/contact-us/">contact our team</a>. We're here to help ensure a smooth migration process.
  </p>
</Aside>
