import { fileURLToPath } from 'url'
import { dirname, join } from 'path'
import { getCollection, type CollectionEntry } from 'astro:content'
import type { APIContext } from 'astro'
import type { APIRoute } from 'astro'
import { sidebar } from '../configs/sidebar.config'

/**
 * Configuration for generating llms text variants.
 */
export interface LlmsConfig {
  /** Title to appear at the very top of the generated file */
  title: string
  /** Optional description that will be added as a block-quote */
  description?: string
  /** Sidebar section IDs to include (e.g., ['fsa', 'sso']) - if empty, includes all */
  sections?: string[]
  /** Specific document paths to include/exclude */
  include?: string[]
  exclude?: string[]
  /** Whether to use Repomix for generation instead of the built-in pipeline */
  useRepomix?: boolean
  /** Extra Repomix CLI options to forward */
  repomixOptions?: Record<string, unknown>
}

/**
 * Extract document paths from sidebar configuration
 */
function extractPathsFromSidebar(sectionIds?: string[]): string[] {
  const paths: string[] = []

  for (const section of sidebar) {
    // If sections filter is provided, only include matching sections
    if (sectionIds && sectionIds.length > 0 && !sectionIds.includes(section.id)) {
      continue
    }

    // Extract paths from section items recursively
    function extractFromItems(items: any[]): void {
      for (const item of items) {
        if (typeof item === 'string') {
          paths.push(item)
        } else if (item.items) {
          extractFromItems(item.items)
        } else if (item.autogenerate) {
          // For autogenerated sections, we'll include the directory pattern
          paths.push(`${item.autogenerate.directory}/**/*`)
        }
      }
    }

    if (section.items) {
      extractFromItems(section.items)
    }
  }

  return paths
}

/**
 * Factory that returns an Astro API route handler based on a configuration object.
 *
 * Example usage in `src/pages/llms-full.txt.ts`:
 * ```ts
 * import { createLlmsRoute } from '@/utils/llms'
 * export const GET = createLlmsRoute({ title: 'Scalekit Full Documentation' })
 * ```
 */
export function createLlmsRoute(config: LlmsConfig): APIRoute {
  return async function GET(context) {
    const txt = await generateLlmsContent(config, context)
    return new Response(txt, {
      headers: { 'Content-Type': 'text/plain; charset=utf-8' },
    })
  }
}

/**
 * Simple path matching function (supports basic wildcards)
 */
function matchesPath(docPath: string, pattern: string): boolean {
  if (pattern.endsWith('/**/*')) {
    const prefix = pattern.slice(0, -5) // Remove '/**/*'
    return docPath.startsWith(prefix)
  }
  return docPath === pattern
}

/**
 * Core generation function. Either delegates to Repomix (if enabled) or uses
 * a simple content extraction approach.
 */
export async function generateLlmsContent(cfg: LlmsConfig, context: APIContext): Promise<string> {
  // 1. If the user explicitly asked for Repomix, try that first.
  if (cfg.useRepomix) {
    try {
      const { runCli } = await import('repomix')
      const projectRoot = process.cwd()
      const docsPath = join(projectRoot, 'src/content/docs')
      const options = {
        output: '', // no file output – we only need the content in-memory
        style: 'plain' as 'plain',
        compress: false,
        quiet: true,
        ...(cfg.repomixOptions ?? {}),
      }
      const result: any = await runCli([docsPath], projectRoot, options)
      if (result?.packResult?.combinedText) {
        const preamble = [`# ${cfg.title}`]
        if (cfg.description) preamble.push(`> ${cfg.description}`)
        return preamble.concat(result.packResult.combinedText).join('\n\n') + '\n'
      }
      // If Repomix did not return expected output, fall back to internal pipeline
      /* eslint-disable no-console */
      console.warn(
        '[llms] Repomix did not return expected output – falling back to internal pipeline',
      )
      /* eslint-enable no-console */
    } catch (err) {
      /* eslint-disable no-console */
      console.warn('[llms] Failed to use Repomix, falling back to internal pipeline', err)
      /* eslint-enable no-console */
    }
  }

  // 2. Built-in simple approach: get docs and filter based on config
  let docs = await getCollection('docs')

  // Filter based on sidebar sections if specified
  if (cfg.sections && cfg.sections.length > 0) {
    const allowedPaths = extractPathsFromSidebar(cfg.sections)
    docs = docs.filter((doc) => allowedPaths.some((path) => matchesPath(doc.id, path)))
  }

  // Apply additional include/exclude filters
  if (cfg.include && cfg.include.length > 0) {
    docs = docs.filter((doc) => cfg.include!.some((path) => matchesPath(doc.id, path)))
  }

  if (cfg.exclude && cfg.exclude.length > 0) {
    docs = docs.filter((doc) => !cfg.exclude!.some((path) => matchesPath(doc.id, path)))
  }

  // 3. Generate simple markdown output
  const segments: string[] = []
  if (cfg.title) {
    segments.push(`# ${cfg.title}`)
    if (cfg.description) segments.push(`> ${cfg.description}`)
  }

  for (const doc of docs) {
    const docSegs = [`## ${doc.data.hero?.title || doc.data.title}`]
    const description = doc.data.hero?.tagline || doc.data.description
    if (description) docSegs.push(`> ${description}`)

    // Simple content extraction - just get the raw body
    if (doc.body) {
      docSegs.push(doc.body.trim())
    }
    segments.push(docSegs.join('\n\n'))
  }

  return segments.join('\n\n---\n\n') + '\n'
}
