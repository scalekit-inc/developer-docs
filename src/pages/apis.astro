---
// Import the `<StarlightPage>` component first to set up cascade layers
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro'
import { ScalarComponent } from '@scalar/astro'
import ApiSearchIndex from '../components/ApiSearchIndex.astro'

/*
TODO:
- Level up the quality as in https://lichess.org/api
- Reference: github.com/lichess-org/api
**/

// Page metadata
const template = 'splash' as const
const frontmatter = {
  title: 'Scalekit API Reference',
  description: 'Complete reference for all Scalekit API endpoints',
  template,
  editUrl: false as const,
  head: [
    {
      tag: 'style' as const,
      content: `
        footer {
          display: none !important;
        }
        .content-panel:first-of-type:has(.sl-container:empty),
        .content-panel:first-of-type:not(:has(.api-reference-wrapper)) {
          display: none !important;
        }
        .content-panel:first-of-type:empty {
          display: none !important;
        }
        .scalar-api-reference {
          position: sticky;
          top: var(--sl-nav-height);
          height: calc(100vh - var(--sl-nav-height));
          overflow: auto;
        }
      `,
    },
  ],
}
---

<div class="scalar-api-reference">
  <!--
    Persist the selected "Request Example" client globally across endpoints.
    Scalar stores this preference under `scalar-reference-selected-client-v2`.
    We only set an initial default for first-time visitors; afterwards Scalar keeps it updated.
  -->
  <script is:inline>
    ;(() => {
      try {
        const KEY = 'scalar-reference-selected-client-v2'
        if (!window?.localStorage?.getItem(KEY)) {
          // Default to cURL on first visit (matches the previous `defaultHttpClient` behavior).
          window.localStorage.setItem(KEY, 'shell/curl')
        }
      } catch {
        // Ignore storage errors (private mode, blocked storage, etc.)
      }
    })()
  </script>
  <!--
    Scalar only emits `scalar-update-selected-client` for non-custom http-clients.
    When users pick an SDK example (which uses `custom/<lang>` ids), Scalar intentionally
    does NOT emit that event, so other request examples donâ€™t update.
    This bridge makes SDK selection global for inline request examples only.
  -->
  <script is:inline>
    ;(() => {
      const SELECTED_CLIENT_KEY = 'scalar-reference-selected-client-v2'

      // Scalar generates SDK examples from OpenAPI `x-codeSamples` and assigns them ids in the
      // form `custom/<lang>`. For our spec, those SDK labels are consistent and map cleanly.
      const sdkLabelToClientId = new Map([
        ['Node.js SDK', 'custom/javascript'],
        ['Python SDK', 'custom/python'],
        ['Go SDK', 'custom/go'],
        ['Java SDK', 'custom/java'],
      ])

      const normalizeText = (value) => (value ?? '').replace(/\s+/g, ' ').trim()

      // Keep this scoped to inline request examples, not the API client drawer/modal.
      const isInsideApiClientDialog = (el) => Boolean(el?.closest?.('[role="dialog"]'))
      const findClosestRequestCard = (el) => el?.closest?.('.request-card')
      const findScalarInstanceRoot = (el) =>
        el?.closest?.('[id^="scalar-client-"]') ?? document.getElementById('scalar-client-0')

      const syncCustomClientSelection = (sourceEl) => {
        if (!(sourceEl instanceof Element)) return
        if (isInsideApiClientDialog(sourceEl)) return

        const card = findClosestRequestCard(sourceEl)
        if (!card) return

        const pickerButton = card.querySelector('[data-testid="client-picker"]')
        if (!(pickerButton instanceof HTMLElement)) return

        const label = normalizeText(pickerButton.textContent)
        const clientId = sdkLabelToClientId.get(label)
        if (!clientId) return

        try {
          const current = window?.localStorage?.getItem(SELECTED_CLIENT_KEY)
          if (current === clientId) return

          window.localStorage.setItem(SELECTED_CLIENT_KEY, clientId)

          // Dispatch on the Scalar instance root so only that app instance updates.
          const root = findScalarInstanceRoot(card)
          root?.dispatchEvent(
            new CustomEvent('scalar-update-selected-client', {
              detail: clientId,
              bubbles: true,
              composed: true,
              cancelable: false,
            }),
          )
        } catch {
          // Ignore storage/DOM errors
        }
      }

      // The SDK picker is a teleported combobox. It doesn't reliably emit a DOM `change` event,
      // so we watch for the selected label (the `data-testid="client-picker"` button text) to change.
      const observedButtons = new WeakSet()
      const attachObservers = () => {
        document.querySelectorAll('[data-testid="client-picker"]').forEach((btn) => {
          if (!(btn instanceof HTMLElement)) return
          if (observedButtons.has(btn)) return

          observedButtons.add(btn)

          const observer = new MutationObserver(() => syncCustomClientSelection(btn))
          observer.observe(btn, { childList: true, subtree: true, characterData: true })
        })
      }

      // Attach initial observers and keep watching for new request cards as the user navigates.
      attachObservers()
      const pageObserver = new MutationObserver(() => attachObservers())
      pageObserver.observe(document.documentElement, { childList: true, subtree: true })
    })()
  </script>
  <ScalarComponent
    configuration={{
      url: '/api/scalekit.scalar.yaml',
      theme: 'default',
      layout: 'modern',
      pageTitle: 'Scalekit API',
      hideTestRequestButton: false,
      withDefaultFonts: false,
      hideModels: true,
      searchHotKey: 'p',
      hideDarkModeToggle: true,
      darkMode: false,
      proxyUrl: 'https://proxy.scalar.com',
      defaultOpenAllTags: false,
      servers: [
        {
          url: 'https://{SCALEKIT_ENVIRONMENT_URL}',
          description: 'Scalekit Environment',
          variables: {
            SCALEKIT_ENVIRONMENT_URL: {
              default: 'your-env.scalekit.com',
              description:
                'Your full Scalekit environment URL (e.g., my-env.scalekit.com or my-env.scalekit.dev)',
            },
          },
        },
      ],
      authentication: {
        preferredSecurityScheme: 'oauth2',
        securitySchemes: {
          oauth2: {
            type: 'oauth2',
            flows: {
              clientCredentials: {
                tokenUrl: 'https://{SCALEKIT_ENVIRONMENT_URL}/oauth/token',
                'x-scalar-credentials-location': 'body',
                'x-scalar-security-body': {
                  grant_type: 'client_credentials',
                },
              },
            },
          },
        },
      },
      hiddenClients: {
        c: ['libcurl'],
        csharp: ['httpclient', 'restsharp'],
        clojure: ['clj_http'],
        dart: ['http'],
        go: ['native'],
        http: ['http1.1', 'http1', 'http2'],
        java: ['asynchttp', 'okhttp', 'unirest', 'nethttp'],
        js: ['xhr', 'fetch', 'axios', 'jquery', 'ofetch', 'request'],
        kotlin: ['okhttp'],
        node: ['undici', 'axios', 'fetch', 'ofetch'],
        objc: ['nsurlsession'],
        ocaml: ['cohttp'],
        // Some Scalar builds expose F# separately; hide its HttpClient if present
        fsharp: ['httpclient'],
        php: ['curl', 'guzzle'],
        powershell: ['restmethod', 'webrequest'],
        python: ['python3', 'requests', 'httpx_sync', 'httpx_async'],
        r: ['httr'],
        ruby: ['native'],
        rust: ['reqwest'],
        shell: ['httpie', 'wget'],
        swift: ['nsurlsession'],
      },
      favicon:
        'https://cdn.prod.website-files.com/65b87d98fa638289e10b8f61/67ab35acf2f180e0fe0a94a8_S%20Icon%20-%20Black%20-%2032x32.png',
      hideClientButton: true,
      baseServerURL: 'https://scalekit.com',
      documentDownloadType: 'json',
      // hides an unnecessary button that says "Authorize" + intro card
      customCss: `#scalar-client-0 { margin-top: 8rem; } .introduction-card-item.scalar-reference-intro-clients { display: none; } }`,
      // Custom slug generation for webhooks to prevent "undefined" in URLs
      generateWebhookSlug: (webhook) => {
        // The webhook object structure from OpenAPI parsing doesn't include the original key
        // We need to extract a meaningful identifier from the available properties

        // Try to use summary first (most descriptive)
        if (webhook.summary) {
          return webhook.summary
            .toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '') // Remove special characters except spaces and hyphens
            .replace(/\s+/g, '-') // Replace spaces with hyphens
            .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
            .replace(/^-|-$/g, '') // Remove leading/trailing hyphens
        }

        // Fallback to a generic webhook identifier
        // This ensures we never get "undefined" in the URL
        return 'webhook-event'
      },
    }}
  />
</div>

<StarlightPage frontmatter={frontmatter}>
  <!-- Hidden search index for Pagefind -->
  <div style="display: none;">
    <ApiSearchIndex />
  </div>
</StarlightPage>
