---
/**
 * CodeWalkthrough.astro - Interactive code walkthrough component
 * Two-pane layout with step-by-step instructions on left and highlighted code on right
 * Supports multiple programming languages with multiple files per language
 */

import { Code } from '@astrojs/starlight/components'
import { readFileSync, readdirSync } from 'node:fs'
import { join } from 'node:path'

export interface LanguageConfig {
  id: string
  label: string
  codeDir: string // Directory containing all files for this language
}

export interface Props {
  /**
   * Array of language configurations
   * E.g., [{ id: "typescript", label: "Node.js", codeDir: "authentication/nodejs" }]
   */
  languages: LanguageConfig[]

  /**
   * Optional title for the code panel
   */
  title?: string

  /**
   * Show line numbers in the code
   * @default true
   */
  showLineNumbers?: boolean

  /**
   * Make code panel sticky while scrolling through steps
   * @default true
   */
  sticky?: boolean

  /**
   * Optional class name for custom styling
   */
  class?: string
}

const {
  languages,
  title,
  showLineNumbers = true,
  sticky = true,
  class: className = '',
} = Astro.props

// Read all code files for each language at build time
const codeByLanguage: Record<string, Record<string, string>> = {}
const filesByLanguage: Record<string, string[]> = {}

for (const lang of languages) {
  const codeDirPath = join(process.cwd(), 'src', 'content', 'code-samples', lang.codeDir)
  codeByLanguage[lang.id] = {}
  filesByLanguage[lang.id] = []

  try {
    const files = readdirSync(codeDirPath).filter((f) => !f.startsWith('.'))
    filesByLanguage[lang.id] = files

    for (const file of files) {
      const filePath = join(codeDirPath, file)
      try {
        codeByLanguage[lang.id][file] = readFileSync(filePath, 'utf-8').trim()
      } catch (error) {
        console.error(`Failed to read file: ${filePath}`, error)
        codeByLanguage[lang.id][file] = `// Error: Could not load ${file}`
      }
    }
  } catch (error) {
    console.error(`Failed to read directory: ${codeDirPath}`, error)
  }
}

const defaultLanguage = languages[0].id
---

<div class={`code-walkthrough-wrapper ${className}`}>
  <!-- Language Switcher -->
  <div class="language-switcher">
    <label class="language-switcher-label">Select your language:</label>
    <div class="language-buttons" role="tablist">
      {
        languages.map((lang, index) => (
          <button
            type="button"
            role="tab"
            class={`language-button ${index === 0 ? 'active' : ''}`}
            data-language={lang.id}
            aria-selected={index === 0 ? 'true' : 'false'}
          >
            {lang.label}
          </button>
        ))
      }
    </div>
  </div>

  <!-- Two-pane layout -->
  <div class="code-walkthrough" data-walkthrough>
    <!-- Left panel: Steps -->
    <div class="walkthrough-steps" data-walkthrough-steps>
      <slot />
    </div>

    <!-- Right panel: Code with language tabs and file tabs -->
    <div class={`walkthrough-code-panel ${sticky ? 'sticky' : ''}`} data-walkthrough-code>
      {
        title && (
          <p class="walkthrough-code-title">
            <em>{title}</em>
          </p>
        )
      }

      <!-- Render code for each language -->
      {
        languages.map((lang, langIndex) => (
          <div
            class={`walkthrough-language-container ${langIndex === 0 ? 'active' : ''}`}
            data-language-container
            data-language={lang.id}
          >
            {filesByLanguage[lang.id] && filesByLanguage[lang.id].length > 1 && (
              <div class="file-tabs">
                {filesByLanguage[lang.id].map((file, fileIndex) => (
                  <button
                    type="button"
                    class={`file-tab ${fileIndex === 0 ? 'active' : ''}`}
                    data-file={file}
                    data-language={lang.id}
                  >
                    {file}
                  </button>
                ))}
              </div>
            )}

            {filesByLanguage[lang.id] &&
              filesByLanguage[lang.id].map((file, fileIndex) => (
                <div
                  class={`walkthrough-code-container ${fileIndex === 0 ? 'active' : ''}`}
                  data-code-container
                  data-language={lang.id}
                  data-file={file}
                  role="tabpanel"
                >
                  <Code
                    code={codeByLanguage[lang.id][file]}
                    lang={lang.id}
                    showLineNumbers={showLineNumbers}
                  />
                </div>
              ))}
          </div>
        ))
      }
    </div>
  </div>
</div>

<style>
  .code-walkthrough-wrapper {
    margin: 2rem 0;
    width: 100%;
  }

  /* Language Switcher */
  .language-switcher {
    margin-bottom: 2rem;
    padding: 1.5rem;
    background: var(--sl-color-gray-6);
    border-radius: 0.5rem;
    border: 1px solid var(--sl-color-gray-5);
  }

  .language-switcher-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: 0.75rem;
    color: var(--sl-color-gray-2);
  }

  .language-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .language-button {
    padding: 0.5rem 1.25rem;
    border-radius: 0.375rem;
    border: 2px solid var(--sl-color-gray-5);
    background: var(--sl-color-bg);
    color: var(--sl-color-gray-2);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .language-button:hover {
    border-color: var(--sl-color-gray-4);
    background: var(--sl-color-gray-6);
  }

  .language-button.active {
    border-color: var(--sl-color-accent);
    background: var(--sl-color-accent);
    color: white;
  }

  .language-button:focus {
    outline: 2px solid var(--sl-color-accent);
    outline-offset: 2px;
  }

  /* Two-pane layout */
  .code-walkthrough {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    align-items: start;
    position: relative;
    overflow: visible;
  }

  .walkthrough-steps {
    min-width: 0;
    padding-bottom: 40vh;
    overflow: visible;
    position: relative;
    z-index: 1;
  }

  .walkthrough-code-panel {
    min-width: 0;
    position: relative;
    z-index: 2;
  }

  .walkthrough-code-panel.sticky {
    position: -webkit-sticky;
    position: sticky;
    top: 1rem;
    height: calc(100vh - 2rem);
    max-height: calc(100vh - 2rem);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-self: start;
  }

  .walkthrough-code-title {
    font-size: 0.875rem;
    font-weight: 500;
    margin: 0 0 0.75rem 0;
    color: var(--sl-color-gray-2);
    flex-shrink: 0;
  }

  /* Language Container */
  .walkthrough-language-container {
    display: none;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  .walkthrough-language-container.active {
    display: flex;
  }

  /* File Tabs */
  .file-tabs {
    display: flex;
    gap: 0.25rem;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--sl-color-gray-5);
    padding-bottom: 0.5rem;
    flex-shrink: 0;
    overflow-x: auto;
  }

  .file-tab {
    padding: 0.5rem 1rem;
    border: 1px solid var(--sl-color-gray-5);
    border-bottom: none;
    background: var(--sl-color-gray-6);
    color: var(--sl-color-gray-2);
    font-size: 0.75rem;
    font-family: var(--sl-font-mono);
    cursor: pointer;
    border-radius: 0.375rem 0.375rem 0 0;
    transition: all 0.2s ease;
    white-space: nowrap;
  }

  .file-tab:hover {
    background: var(--sl-color-gray-5);
  }

  .file-tab.active {
    background: var(--sl-color-bg);
    border-color: var(--sl-color-accent);
    color: var(--sl-color-accent);
    font-weight: 600;
  }

  /* Code Containers */
  .walkthrough-code-container {
    flex: 1;
    display: none;
    border-radius: 0.5rem;
    overflow-y: auto;
    overflow-x: auto;
    min-height: 0;
  }

  .walkthrough-code-container.active {
    display: flex;
    flex-direction: column;
  }

  .walkthrough-code-container :global(.expressive-code) {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  .walkthrough-code-container :global(.expressive-code figure) {
    flex: 1;
    display: flex;
    flex-direction: column;
    margin: 0;
    min-height: 0;
  }

  .walkthrough-code-container :global(.expressive-code pre) {
    flex: 1;
    margin: 0;
    max-height: none !important;
    min-height: 0;
  }

  /* Code highlighting classes */
  .walkthrough-code-container :global(.ec-line.walkthrough-highlight) {
    background: linear-gradient(90deg, var(--sl-color-accent-low) 0%, transparent 100%);
    border-left: 3px solid var(--sl-color-accent);
  }

  .walkthrough-code-container :global(.ec-line.walkthrough-fade) {
    opacity: 0.4;
    transition: opacity 0.3s ease;
  }

  /* Mobile responsive: stack vertically */
  @media (max-width: 768px) {
    .code-walkthrough {
      grid-template-columns: 1fr;
    }

    .walkthrough-code-panel {
      order: -1;
    }

    .walkthrough-code-panel.sticky {
      position: static;
      height: auto;
      max-height: 600px;
    }

    .walkthrough-code-container :global(.expressive-code pre) {
      max-height: 600px !important;
    }
  }

  /* Smooth scrolling */
  @media (prefers-reduced-motion: no-preference) {
    .walkthrough-code-container {
      scroll-behavior: smooth;
    }
  }

  /* Full width layout */
  :global(.code-walkthrough-wrapper) {
    max-width: none !important;
  }
</style>

<script>
  function initializeWalkthrough() {
    const wrappers = document.querySelectorAll('.code-walkthrough-wrapper')

    wrappers.forEach((wrapper) => {
      const languageButtons = wrapper.querySelectorAll('.language-button')
      const languageContainers = wrapper.querySelectorAll('[data-language-container]')
      const walkthrough = wrapper.querySelector('[data-walkthrough]')

      if (!walkthrough) return

      const stepsContainer = walkthrough.querySelector('[data-walkthrough-steps]')
      if (!stepsContainer) return

      let currentLanguage = languageButtons[0]?.getAttribute('data-language') || 'typescript'
      let activeStepNumber = 0
      let isManualClick = false
      let currentObserver = null

      // Show steps for a specific language and renumber them
      function showStepsForLanguage(language) {
        let displayNumber = 1

        steps.forEach((step) => {
          const stepLanguage = step.element.getAttribute('data-step-language')

          if (stepLanguage === language) {
            step.element.style.display = 'flex'
            // Update the display number
            const displayNumberEl = step.element.querySelector('[data-step-display-number]')
            if (displayNumberEl) {
              displayNumberEl.textContent = displayNumber.toString()
            }
            displayNumber++
          } else {
            step.element.style.display = 'none'
            step.element.classList.remove('active')
          }
        })

        // Return visible steps for the current language
        return steps.filter((s) => s.element.getAttribute('data-step-language') === language)
      }

      // Language switching
      languageButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const language = button.getAttribute('data-language')
          if (!language) return

          currentLanguage = language

          // Update button states
          languageButtons.forEach((btn) => {
            btn.classList.remove('active')
            btn.setAttribute('aria-selected', 'false')
          })
          button.classList.add('active')
          button.setAttribute('aria-selected', 'true')

          // Update language container visibility
          languageContainers.forEach((container) => {
            const containerLang = container.getAttribute('data-language')
            if (containerLang === language) {
              container.classList.add('active')
            } else {
              container.classList.remove('active')
            }
          })

          // Show steps for the new language
          const visibleSteps = showStepsForLanguage(language)

          // Disconnect old observer
          if (currentObserver) {
            currentObserver.disconnect()
          }

          // Set up new observer for visible steps
          setupObserver(visibleSteps)

          // Highlight first step of the new language
          if (visibleSteps.length > 0) {
            setTimeout(() => {
              highlightStep(visibleSteps[0].stepNumber, language)
            }, 100)
          }
        })
      })

      // File tab switching
      wrapper.querySelectorAll('.file-tab').forEach((tab) => {
        tab.addEventListener('click', () => {
          const file = tab.getAttribute('data-file')
          const language = tab.getAttribute('data-language')
          if (!file || !language) return

          switchToFile(language, file)
        })
      })

      // Helper: Switch to a specific file in a language
      function switchToFile(language, filename) {
        const container = wrapper.querySelector(
          `[data-language-container][data-language="${language}"]`,
        )
        if (!container) return

        // Update file tabs
        container.querySelectorAll('.file-tab').forEach((tab) => {
          if (tab.getAttribute('data-file') === filename) {
            tab.classList.add('active')
          } else {
            tab.classList.remove('active')
          }
        })

        // Update code containers
        container.querySelectorAll('[data-code-container]').forEach((codeContainer) => {
          if (codeContainer.getAttribute('data-file') === filename) {
            codeContainer.classList.add('active')
          } else {
            codeContainer.classList.remove('active')
          }
        })
      }

      // Collect all steps with their metadata
      const steps = []
      stepsContainer.querySelectorAll('[data-walkthrough-step]').forEach((stepEl) => {
        const stepNumber = parseInt(stepEl.getAttribute('data-step-number') || '0', 10)
        const stepLanguage = stepEl.getAttribute('data-step-language')
        const fileData = stepEl.getAttribute('data-step-file')

        if (stepNumber > 0 && stepLanguage && fileData) {
          let file
          try {
            file = JSON.parse(fileData)
          } catch (e) {
            console.error('Failed to parse file data:', fileData)
            return
          }

          steps.push({
            element: stepEl,
            stepNumber: stepNumber,
            language: stepLanguage,
            file: file,
          })

          // Make steps clickable
          stepEl.style.cursor = 'pointer'
          stepEl.addEventListener('click', () => {
            isManualClick = true
            stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' })
            highlightStep(stepNumber, stepLanguage)
            setTimeout(() => {
              isManualClick = false
            }, 800)
          })
        }
      })

      if (steps.length === 0) return

      // Parse line range strings like "1-5" or "1-5,8-10,15"
      function parseLineRanges(rangeStr) {
        if (!rangeStr) return []

        const lines = []
        const parts = rangeStr.split(',').map((s) => s.trim())

        parts.forEach((part) => {
          if (part.includes('-')) {
            const [start, end] = part.split('-').map((n) => parseInt(n.trim(), 10))
            if (!isNaN(start) && !isNaN(end)) {
              for (let i = start; i <= end; i++) {
                lines.push(i)
              }
            }
          } else {
            const num = parseInt(part, 10)
            if (!isNaN(num)) {
              lines.push(num)
            }
          }
        })

        return lines
      }

      // Switch to the file for a given step
      function switchToFileForStep(step) {
        const fileInfo = step.file
        const language = step.language

        if (!fileInfo || !fileInfo.file) return

        switchToFile(language, fileInfo.file)

        // Highlight lines after switching file
        setTimeout(() => {
          const container = wrapper.querySelector(
            `[data-code-container][data-language="${language}"][data-file="${fileInfo.file}"]`,
          )
          if (container) {
            highlightLinesInContainer(container, fileInfo.lines)
          }
        }, 50)
      }

      // Highlight code lines in a specific container
      function highlightLinesInContainer(container, linesStr) {
        // Remove previous highlights
        container.querySelectorAll('.ec-line').forEach((line) => {
          line.classList.remove('walkthrough-highlight', 'walkthrough-fade')
        })

        if (!linesStr) return

        // Parse line ranges
        const lineNumbers = parseLineRanges(linesStr)
        let firstHighlightedLine = null

        // Apply highlighting
        container.querySelectorAll('.ec-line').forEach((lineEl) => {
          const lnEl = lineEl.querySelector('.ln')
          if (!lnEl) return

          const lineNum = parseInt(lnEl.textContent || '0', 10)

          if (lineNumbers.includes(lineNum)) {
            lineEl.classList.add('walkthrough-highlight')
            lineEl.classList.remove('walkthrough-fade')

            // Track first highlighted line
            if (!firstHighlightedLine) {
              firstHighlightedLine = lineEl
            }
          } else {
            lineEl.classList.remove('walkthrough-highlight')
            lineEl.classList.add('walkthrough-fade')
          }
        })

        // Scroll the first highlighted line into view
        if (firstHighlightedLine) {
          const scrollContainer = container.closest('.walkthrough-code-container')
          if (scrollContainer) {
            // Get positions
            const containerRect = scrollContainer.getBoundingClientRect()
            const lineRect = firstHighlightedLine.getBoundingClientRect()

            // Calculate scroll offset to center the line in the visible area
            const relativeTop = lineRect.top - containerRect.top
            const scrollOffset = scrollContainer.scrollTop + relativeTop - containerRect.height / 3

            // Smooth scroll to position
            scrollContainer.scrollTo({
              top: Math.max(0, scrollOffset),
              behavior: 'smooth',
            })
          }
        }
      }

      // Highlight code for the active step
      function highlightStep(stepNumber, language) {
        if (activeStepNumber === stepNumber && currentLanguage === language) return

        activeStepNumber = stepNumber

        // Find the step for the current language
        const step = steps.find((s) => s.stepNumber === stepNumber && s.language === language)
        if (!step) return

        // Switch to the file for this step
        switchToFileForStep(step)

        // Update active step indicator (only for steps of the current language)
        steps.forEach((s) => {
          if (s.language === language) {
            if (s.stepNumber === stepNumber) {
              s.element.classList.add('active')
              s.element.setAttribute('aria-current', 'step')
            } else {
              s.element.classList.remove('active')
              s.element.removeAttribute('aria-current')
            }
          }
        })
      }

      // Set up Intersection Observer for scroll synchronization
      const observerOptions = {
        root: null,
        rootMargin: '-20% 0px -50% 0px',
        threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],
      }

      let lastIntersectingStep = null
      let intersectionDebounce = null

      function setupObserver(visibleSteps) {
        lastIntersectingStep = null

        // Track all visible step ratios
        const stepRatios = new Map()

        const observer = new IntersectionObserver((entries) => {
          if (isManualClick) return

          // Update the ratios for all entries
          entries.forEach((entry) => {
            const stepEl = entry.target
            const stepNumber = parseInt(stepEl.getAttribute('data-step-number') || '0', 10)

            if (entry.isIntersecting) {
              stepRatios.set(stepNumber, entry.intersectionRatio)
            } else {
              stepRatios.delete(stepNumber)
            }
          })

          // Clear previous debounce
          clearTimeout(intersectionDebounce)

          // Debounce the selection to prevent flickering
          intersectionDebounce = setTimeout(() => {
            // Find the step with the highest intersection ratio
            let maxRatio = 0
            let selectedStepNumber = null

            stepRatios.forEach((ratio, stepNumber) => {
              if (ratio > maxRatio) {
                maxRatio = ratio
                selectedStepNumber = stepNumber
              }
            })

            // Only update if we have a clear winner and it's different from current
            if (
              selectedStepNumber &&
              selectedStepNumber !== lastIntersectingStep &&
              maxRatio > 0.3
            ) {
              lastIntersectingStep = selectedStepNumber

              // Find the step element to get its language
              const step = visibleSteps.find((s) => s.stepNumber === selectedStepNumber)
              if (step) {
                highlightStep(selectedStepNumber, step.language)
              }
            }
          }, 100)
        }, observerOptions)

        // Observe visible steps
        visibleSteps.forEach((step) => {
          observer.observe(step.element)
        })

        currentObserver = observer
        return observer
      }

      // Initialize: Show steps for the initial language
      const initialVisibleSteps = showStepsForLanguage(currentLanguage)
      setupObserver(initialVisibleSteps)

      // Highlight first step
      if (initialVisibleSteps.length > 0) {
        setTimeout(() => {
          highlightStep(initialVisibleSteps[0].stepNumber, currentLanguage)
        }, 100)
      }
    })
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeWalkthrough)
  } else {
    initializeWalkthrough()
  }
</script>
