This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
apis/
  index.mdx
dev-kit/
  resources/
    ai-assisted-setup.mdx
  index.mdx
  mcp.mdx
directory/
  guides/
    admin-portal.mdx
    group-based-role-assignment.mdx
    launch-checklist.mdx
    scim-protocol.mdx
    user-provisioning-basics.mdx
  code-examples.mdx
  scim-quickstart.mdx
fsa/
  guides/
    app-roles.mdx
    auth-methods.mdx
    automated-user-provisioning.mdx
    enterprise-sso.mdx
    implement-login.mdx
    implement-signup.mdx
    just-in-time-provisioning.mdx
    login-page-branding.mdx
    logout.mdx
    manage-organization.mdx
    manage-session.mdx
    manage-users.mdx
    merge-identities.mdx
    migration-guide.mdx
    organization-switching.mdx
    passwordless.mdx
    social-logins.mdx
    user-invitations.mdx
  reference/
    redirects.mdx
    user-management-settings.mdx
    user-profile.mdx
  data-modelling.mdx
  quickstart.mdx
guides/
  integrations/
    auth-systems/
      auth0.mdx
      aws-cognito.mdx
      firebase.mdx
    scim-integrations/
      azure-scim.mdx
      google-dir-sync.mdx
      index.mdx
      jumpcloud.mdx
      okta-scim.mdx
      onelogin.mdx
    social-connections/
      github.mdx
      gitlab.mdx
      google.mdx
      index.mdx
      linkedin.mdx
      microsoft.mdx
      salesforce.mdx
    sso-integrations/
      azure-ad-saml.mdx
      generic-oidc.mdx
      generic-saml.mdx
      google-saml.mdx
      index.mdx
      jumpcloud-saml.mdx
      microsoft-ad-fs.mdx
      okta-saml.mdx
      onelogin-saml.mdx
      pingidentity-saml.mdx
    index.mdx
  m2m/
    mcp/
      additional-reading.mdx
      oauth.mdx
      overview.mdx
    api-auth-m2m-clients.mdx
    m2m-basics.mdx
    overview.mdx
    scopes.mdx
  passwordless/
    custom-email-provider.mdx
    custom-email-templates.mdx
    email-magiclink-quickstart.mdx
    oidc.mdx
    overview.mdx
    quickstart.mdx
  sso/
    admin-portal.mdx
  authenticate-scalekit-api.mdx
  client-credentials-practices.mdx
  custom-domain.mdx
  email-providers.mdx
  external-ids-and-metadata.mdx
  idtoken-claims.mdx
  setup-scalekit.mdx
  webhooks-best-practices.mdx
m2m/
  quickstart.mdx
reference/
  webhooks/
    directory-events.mdx
    event-object.mdx
  contact-us.mdx
  glossary.mdx
  ui-events.mdx
sso/
  guides/
    add-login-ux-sso.mdx
    authorization-url.mdx
    idp-init-sso.mdx
    launch-checklist.mdx
    okta-sso-test.mdx
    sso-basics.mdx
    sso-user-attributes.mdx
    test-sso.mdx
    user-profile-details.mdx
  reference/
    redirects.mdx
    sso-integration-errors.mdx
  quickstart.mdx
  social-logins-quickstart.mdx
index.mdx

================================================================
Files
================================================================

================
File: apis/index.mdx
================
---
title: "Scalekit API Reference"
description: "Complete reference for all Scalekit API endpoints"
tableOfContents: false
template: splash
slug: apis
next: false
prev: false
head:
  - tag: title
    content: Scalekit API Reference
---
import ScalarReference from '@/components/ScalarReference.vue'
import ApiSearchIndex from '@/components/ApiSearchIndex.astro'

<ScalarReference client:only="vue" />

<div style="display: none;">
    <div class="api-container">
      <ApiSearchIndex />
    </div>
</div>

================
File: dev-kit/resources/ai-assisted-setup.mdx
================
---
title: AI assisted setup
description: "Learn how to use AI assisted setup to create a new project in Scalekit."
sidebar:
  label: AI assisted setup
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
tableOfContents: true
next: false
---

import { VideoPlayer } from 'starlight-videos/components'
import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';


Scalekit provides LLM-friendly capabilities that speed up implementation and guide you through integration steps. Use this guide to configure your preferred AI tools with first-class context awareness of the Scalekit platform.


## Configure code editors for Scalekit documentation

In-code editor chat features are powered by models that understand your codebase and project context. These models search the web for relevant information to help you. However, they may not always have the latest information. Follow the instructions below to configure your code editors to explicitly index for up-to-date information.


### Set up Cursor

<VideoPlayer link="https://youtu.be/oMMG1k_9fmU" />

To enable Cursor to access up-to-date Scalekit documentation:

1. Open Cursor settings (Cmd/Ctrl + ,)
2. Navigate to **Indexing & Docs** section
3. Click on **Add**
4. Add `https://docs.scalekit.com/llms-full.txt` to the indexable URLs
5. Click on **Save**

Once configured, use `@Scalekit Docs` in your chat to ask questions about Scalekit features, APIs, and integration guides. Cursor will search the latest documentation to provide accurate, up-to-date answers.

### Use Windsurf

![](@/assets/docs/dev-kit/ai-assisted-setup/windsurf.png)

Windsurf enables `@docs` mentions within the Cascade chat to search for the best answers to your questions.


<Tabs>
  <TabItem label="Full Documentation">
    ```
    @docs:https://docs.scalekit.com/llms-full.txt
    <your question here>
    ```
    Costs more tokens.
  </TabItem>
  <TabItem label="Specific Section">
    ```
    @docs:https://docs.scalekit.com/your-specific-section-or-file
    <your question here>
    ```
    Costs less tokens.
  </TabItem>
  <TabItem label="Let AI decide">
    ```
    @docs:https://docs.scalekit.com/llms.txt
    <your question here>
    ```
    Costs tokens as per the model decisions.
  </TabItem>
</Tabs>


## Use AI assistants

Assistants like **Anthropic Claude**, **Ollama**, **Google Gemini**, **Vercel v0**, **OpenAI's ChatGPT**, or your own models can help you with Scalekit projects.

<VideoPlayer link="https://youtu.be/ZDAI32I6s-I" description="AI assistants" />

<Aside type="note" title="Need help with a specific AI tool?">

  Don't see instructions for your favorite AI assistant? We'd love to add support for more tools! [Raise an issue](https://github.com/scalekit-inc/developer-docs/issues) on our GitHub repository and let us know which AI tool you'd like us to document.
</Aside>

================
File: dev-kit/index.mdx
================
---
title: Scalekit reference documentation
description: "Accelerate your build with the Scalekit Dev Kit. Get instant access to SDKs, API references, sample apps, and other developer tools."
tableOfContents: false
---
import { Card, CardGrid } from '@astrojs/starlight/components'
import { LinkCard, LinkButton } from '@astrojs/starlight/components'
import { ShowcaseText, ShowcaseCTA } from 'starlight-showcases'
import SimpleList from '@/components/ui/SimpleList.astro';
import Footer from '@/components/templates/_footer.mdx'

Welcome to the Scalekit reference documentation! This section provides comprehensive technical information to help you integrate and use Scalekit effectively in your applications.

These pages contain the technical descriptions of our APIs, SDKs, webhooks, and events.

<CardGrid>

  <div>
    ## REST APIs

    See how to [authenticate your requests](https://docs.scalekit.com/apis) to the Scalekit API.
    <SimpleList>
      - [Organizations API](https://docs.scalekit.com/apis/#tag/organizations)
      - [Users API](https://docs.scalekit.com/apis/#tag/users)
      - [Directory API](https://docs.scalekit.com/apis/#tag/directory)
      - [Connections API](https://docs.scalekit.com/apis/#tag/connection)
    </SimpleList>
    <LinkButton href="https://docs.scalekit.com/apis" variant='secondary'>View all APIs &rarr;</LinkButton>
  </div>

  <div>
    ## SDKs

    Use our official SDKs for <a href="https://github.com/scalekit-inc/scalekit-sdk-node" target="_blank" rel="noopener noreferrer">Node.js</a>, <a href="https://github.com/scalekit-inc/scalekit-sdk-python" target="_blank" rel="noopener noreferrer">Python</a>, <a href="https://github.com/scalekit-inc/scalekit-sdk-go" target="_blank" rel="noopener noreferrer">Go</a>, and <a href="https://github.com/scalekit-inc/scalekit-sdk-java" target="_blank" rel="noopener noreferrer">Java</a>. We also have community-maintained SDKs for <a href="https://github.com/pawan1793/scalekit-php-sdk" target="_blank" rel="noopener noreferrer">PHP</a>.

    ---

<Card title="Portal events" icon="seti:html">
    UI events that you can use to handle the admin portal actions

    [View reference](/reference/admin-portal/ui-events/)
  </Card>
</div>

<Card title="Webhooks" icon="seti:puppet">
    Detailed documentation for our webhooks

    [View Documentation](/reference/webhooks/event-object/)
  </Card>


</CardGrid>

<Footer />

================
File: dev-kit/mcp.mdx
================
---
title: Scalekit MCP Server
description: "Learn how to use the Scalekit MCP Server to manage your users, organizations, and applications."
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: 'Scalekit MCP Server'
prev: false
next: false
---

Scalekit Model Context Protocol (MCP) server provides comprehensive tools for managing environments, organizations, users, connections, and workspace operations. Built for developers who want to connect their AI tools to Scalekit context and capabilities based on simple natural language queries.

This MCP server enables AI assistants to interact with Scalekit's identity and access management platform through a standardized set of tools. It provides secure, OAuth-protected access to manage environments, organizations, users, authentication connections, and more.

## Features

- Environment management and configuration
- Organization and user management
- Workspace member administration
- OIDC connection setup and management
- MCP server registration and configuration
- Role and scope management
- Admin portal link generation

## Configuration

The Scalekit MCP server can be configured to support OAuth for compatible clients.

If your MCP Client doesn't support OAuth based authorization for MCP Servers, you can still use the Scalekit MCP server with the mcp-remote acting as a local proxy to add OAuth support.

### Using OAuth (VS Code version 1.101 or greater)

```json
{
  "servers": {
    "scalekit": {
      "type": "http",
      "url": "https://mcp.scalekit.com/"
    }
  }
}
```

### Using mcp-remote proxy

```json
{
  "mcpServers": {
    "scalekit": {
      "command": "npx",
      "args": ["-y", "mcp-remote", "https://mcp.scalekit.com/"]
    }
  }
}
```

Based on your MCP Host, configuration instructions to add Scalekit as an MCP Server can be found below:

### Claude Desktop

Configure the Claude app to use the MCP server:

1. Open the Claude Desktop app, go to Settings, then Developer
2. Click Edit Config
3. Open the claude_desktop_config.json file
4. Copy and paste the server config to your existing file, then save
5. Restart Claude

```json
{
  "mcpServers": {
    "scalekit": {
      "command": "npx",
      "args": ["-y", "mcp-remote", "https://mcp.scalekit.com/"]
    }
  }
}
```

### Cursor

Configure Cursor to use the MCP server:

1. Open Cursor, go to Settings, then Cursor Settings
2. Select MCP on the left
3. Click Add "New Global MCP Server" at the top right
4. Copy and paste the server config to your existing file, then save
5. Restart Cursor

```json
{
  "mcpServers": {
    "scalekit": {
      "command": "npx",
      "args": ["-y", "mcp-remote", "https://mcp.scalekit.com/"]
    }
  }
}
```

### Windsurf

Configure Windsurf to use the MCP server:

1. Open Windsurf, go to Settings, then Developer
2. Click Edit Config
3. Open the windsurf_config.json file
4. Copy and paste the server config to your existing file, then save
5. Restart Windsurf

```json
{
  "mcpServers": {
    "scalekit": {
      "command": "npx",
      "args": ["-y", "mcp-remote", "https://mcp.scalekit.com/"]
    }
  }
}
```

## Authentication for MCP Server

Scalekit MCP server uses OAuth2.1 based authentication. As soon as you register Scalekit MCP Server in your MCP Host, your MCP Host will initiate an OAuth authorization workflow so that the MCP Client can get appropriate tokens to securely communicate with Scalekit's MCP Server.

:::tip
If you are building your own MCP Server and would like to add OAuth based authorization, you can refer to our solution [Auth for MCP Servers](https://docs.scalekit.com/guides/mcp/oauth).
:::

## Github

We have made the source code for the Scalekit MCP server available on [Github](https://github.com/scalekit-inc/mcp). You can also find all available tools and descriptions in our Github repo.

- Feel free to go through the code and raise an issue if you find any bugs or have any questions.
- If you have suggestions for new tools, please raise a PR or open an issue.

================
File: directory/guides/admin-portal.mdx
================
---
title: Admin Portal
description: "Learn how to use Scalekit's Admin Portal to simplify SSO and SCIM configuration for your enterprise customers, with both no-code and embedded options."
sidebar:
  label: "Admin Portal"
prev: false
next: false
---

import { LinkButton, Aside, Steps, Tabs, TabItem, CardGrid } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import { LinkCard } from '@astrojs/starlight/components';

The Admin Portal simplifies the process of connecting your application to the identity or directory providers used by enterprise organizations.

By offering a self-service portal for your customers, you can minimize the need for extensive back-and-forth communication. Scalekit hosts and manages the Admin Portal entirely, providing two flexible integration options — No-Code and Embedded portals.

## No-Code Admin Portal

A portal will show up for your customers to configure SSO settings by accessing a shareable link. This portal contains the configuration settings that lets your customers setup a connection to their identity provider.

To create and share a link for the Admin Portal, follow these steps:

<Steps>
1. Log in to your [Scalekit Dashboard](https://app.scalekit.com).
2. Navigate to the "Organizations" tab.
3. Select the organization you want to provide access to.
4. Click "Generate Link" to create a new, shareable Admin Portal link.
</Steps>
![Integrate via Shareable Link](@/assets/docs/home/admin-portal/1-admin-portal-v2.png)

```http title="Example" wrap showLineNumbers=false
https://your-app.scalekit.dev/magicLink/2cbe56de-eec4-41d2-abed-90a5b82286c4_p
```

The **link expires in 7 days** but can be revoked at any time from the dashboard for security purposes. You can share the link through communication channels such as email, Slack, or other preferred methods.

{/* ![Integrate via Shareable Link](@/assets/docs/common/admin-portal-2.png) */}

<Aside type="caution">
Be cautious when sharing the link, as anyone with access to it can view and update the organization's connection settings
</Aside>

### Customize the Admin Portal

Customizing your admin portal ensures that the interface aligns with your application's brand identity. Follow this guide to update your custom domain, upload your logo, adjust colors, and set a favicon—all of which create a seamless user experience.

Personalize your admin portal further by matching it to your brand. The following elements can be customized:

- **Logo**: Upload and display your company logo.
- **Colors**: Adjust the accent color to harmonize with your brand palette.
- **Favicon**: Set a favicon that represents your brand identity.

These customization options help ensure that the admin portal feels like an integrated extension of your application.

## Embedded Admin Portal

Users can do the connection setup right from your application by rendering Scalekit-hosted admin portal as a inline frame (iframe). This approach allows easy discovery & convenient access to the portal without the need for external links or separate portals.

Generate the embeddable portal link when page loads or refreshes and inject the `src` of the `<iframe>`, at your app's runtime. This ensure secure programmatic access.

<InstallSDK />

Use the **Generate Portal Link API** to create a unique, embeddable Admin Portal link specific to an organization.

<Tabs syncKey="tech-stack">
  <TabItem value="nodejs" label="Node.js">

    ```javascript
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      process.env.ENVIRONMENT_URL,
      process.env.CLIENT_ID,
      process.env.CLIENT_SECRET,
    );

    async function generatePortalLink(orgID) {
      const link = await scalekit.organization.generatePortalLink(orgID);
      console.log(JSON.stringify(link, null, 2));
    }
    ```

  </TabItem>

  <TabItem value="python" label="Python">

    ```python
    from scalekit import Scalekit

    scalekit = Scalekit(
        environment_url=os.environ.get("ENVIRONMENT_URL"),
        client_id=os.environ.get("CLIENT_ID"),
        client_secret=os.environ.get("CLIENT_SECRET")
    )

    def generate_portal_link(org_id):
        link = scalekit.organization.generate_portal_link(org_id)
        print(json.dumps(link, indent=2))
    ```

  </TabItem>

  <TabItem value="go" label="Go">

    ```go
    import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/scalekit/sdk-go"
    )

    func generatePortalLink(orgID string) {
        sc := scalekit.New(
            os.Getenv("ENVIRONMENT_URL"),
            os.Getenv("CLIENT_ID"),
            os.Getenv("CLIENT_SECRET"),
        )

        ctx := context.Background()
        link, err := sc.Organization.GeneratePortalLink(ctx, orgID)
        if err != nil {
            panic(err)
        }

        jsonData, _ := json.MarshalIndent(link, "", "  ")
        fmt.Println(string(jsonData))
    }
    ```

  </TabItem>

  <TabItem value="java" label="Java">

    ```java
    import com.scalekit.client.Scalekit;
    import com.scalekit.client.models.Link;
    import com.scalekit.client.models.Feature;

    import java.util.Arrays;

    public class PortalLinkGenerator {
        public static void main(String[] args) {
            Scalekit client = new Scalekit(
                System.getenv("ENVIRONMENT_URL"),
                System.getenv("CLIENT_ID"),
                System.getenv("CLIENT_SECRET")
            );

            Link portalLink = client
                .organizations()
                .generatePortalLink(
                    "org_12345",
                    Arrays.asList(Feature.sso, Feature.dir_sync)
                );

            System.out.println(portalLink.getLocation());
        }
    }
    ```

  </TabItem>
</Tabs>

The API will return a JSON object containing the `location` property, which is the URL to the Admin Portal.

```json title="Generate Portal Link (Response Object)" {3}
{
  "id": "8930509d-68cf-4e2c-8c6d-94d2b5e2db43",
  "location": "https://random-subdomain.scalekit.dev/magicLink/8930509d-68cf-4e2c-8c6d-94d2b5e2db43",
  "expireTime": "2024-10-03T13:35:50.563013Z"
}
```

Access the `location` property and set it as the `src` attribute of an iframe in your web pages at runtime. Ensure your domain is listed as one of the Redirect URIs in the **Scalekit Dashboard > API Config**

```html title="Render admin portal in iframe (example)" {3-9} wrap
<body>
  <h1>Admin Portal (Embed)</h1>
  <iframe
    src="https://random-subdomain.scalekit.dev/magicLink/8930509d-68cf-4e2c-8c6d-94d2b5e2db43"
    width="100%"
    height="600px"
    frameborder="0"
    allow="clipboard-write"
  >
  </iframe>
</body>
```

For example, if your application has a "Settings" page for your users, this page can allow them to configure connection with their IdP right within from your app.

{/* ![Integrate via API](@/assets/docs/common/admin-portal-3.png) */}

<Aside type="note">
1. The programmatically generated link is designed for one-time use and expires after 1 minute. Once activated in iframe, the IT admin can configure SSO for an extended period. The session remains active until the setup is complete.
2. The embedded portal session times out after 6 hours, requiring administrators to complete the configuration within this period.
</Aside>

The Admin Portal can be customized to match your brand's logo and colors. Refer to the [customize Admin Portal guide](/guides/sso/admin-portal/#customize-the-admin-portal) for more information.

<CardGrid>

<LinkCard
  title="SCIM integrations"
  description="Administrator guides to set up SCIM integrations"
  href="/guides/integrations/scim-integrations/"
/>


<LinkCard
  title="Portal events"
  description="Listen to the browser events emitted from the embedded admin portal"
  href="/reference/admin-portal/ui-events/"
/>

</CardGrid>

================
File: directory/guides/group-based-role-assignment.mdx
================
---
title: 'Group-based role assignment'
description: "Learn how to automate user role assignments in your application by mapping directory provider groups to application roles using Scalekit."
sidebar:
  label: 'Automatically assign roles'
prev:
  label: 'SCIM provisioning quickstart'
  link: '/directory/scim/quickstart/'
next:
  label: 'Roles configuration on Admin Portal'
  link: '/directory/guides/admin-portal'
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';


Manually assigning roles to users in your application can consume significant time for administrators. This becomes especially challenging in large enterprises where access requirements change frequently. Scalekit automates this process by enabling administrators to create workflows that automatically update your app with the correct user roles.

## How group-based role assignment works

Organization administrators commonly manage varying access levels by grouping users based on their specific access requirements. For example, if you develop an application similar to GitHub with roles like maintainer, writer, and viewer, customer administrators can create user groups for each role within their directory provider.

![SCIM user provisioning flow directory to Scalekit to your B2B app](@/assets/docs/home/automatically-assign-roles/gbra-1.png)

Scalekit notifies your application when administrators create groups or add users to groups. This enables you to take necessary actions such as creating or modifying user roles as directed by the organization's administrator.

Scalekit delivers normalized information regardless of which directory provider your customers use. This eliminates the need for you to transform data across different providers. Users can belong to multiple groups and may receive multiple roles in your application, depending on your role-mapping logic.

## Set up automatic role assignment

To enable administrators to map groups to roles in your app, complete these steps:

1. Go to the Scalekit dashboard
2. Select "SCIM Provisioning"
3. Switch to the "Role assignment" tab
4. Register your app's roles

![How Scalekit works](@/assets/docs/home/automatically-assign-roles/automatically-assign-roles-4.png)

The first role you create becomes the default role automatically. Users who don't belong to any specific group receive this role when you create their accounts. To change the default role, navigate to the role settings, click the "..." menu next to your preferred role, select "Edit," and toggle the "Set as default role" option.

Choose clear display names and descriptions for your roles. This helps customers understand and align with the access levels in the admin portal.

![](@/assets/docs/automatically-assign-roles/mapping/1.png)

### Connect organization groups to app roles

After you create the roles, they reflect the roles in your app. Users receive role assignments based on the groups they belong to.

You can set up this mapping in two ways:

1. Set up mapping in the Scalekit dashboard on behalf of organization administrators. Select the 'Organization' and go to 'SCIM Provisioning' tab.
2. Share the [admin portal link](/directory/guides/admin-portal#no-code-admin-portal) with organization administrators so they can set up the mapping themselves

Scalekit automatically displays mapping options in both the Scalekit dashboard and the admin portal. This allows administrators to connect organization groups to app roles.

![](@/assets/docs/automatically-assign-roles/mapping/2.png)

## Handle role update events

Scalekit continuously monitors updates from your customers' directory providers and sends event payloads to your application through a registered webhook endpoint. To set up these endpoints and manage subscriptions, note the 'Webhooks' option in the Scalekit dashboard.

Listen for the `organization.directory.user_updated` event to determine a user's role from the payload. Scalekit automatically includes a role property relevant to your app, based on the role information you configured in the Scalekit dashboard.


<Tabs>
  <TabItem label="Node.js">
    ```javascript title="Create a webhook endpoint for role updates"
    // Webhook endpoint
    app.post('/webhook', async (req, res) => {
      // Extract event data
      const event = req.body;
      const { email, name, roles } = event.data;
      console.log('Admin added user to Viewer Group -> Scalekit informs Your App\n');

      // Destructure role_name from roles array
      const roleName = roles.length > 0 ? roles[0].role_name : null;
      console.log('Role name received:', roleName);

      // Logic to update user role and permissions
      await assignRole(roleName, email);
      console.log('App updated access for user:', email);

      res.status(201).json({
        message: 'Role assigned',
      });
    });
    ```
  </TabItem>

  <TabItem label="Python">
    ```python title="Create a webhook endpoint for role updates"
    from fastapi import FastAPI, Request

    app = FastAPI()

    @app.post("/webhook")
    async def api_webhook(request: Request):
        # Parse request body
        body = await request.body()
        payload = json.loads(body.decode())

        # Extract user data
        user_roles = payload['data']['roles']
        user_email = payload['data']['email']

        print("User Roles:", str(roles))
        print("User email:", str(email))

        # Business logic to assign role
        await assign_role(roles[0], email)

        return JSONResponse(
            status_code=201,
            content=''
        )
    ```
  </TabItem>

  <TabItem label="Java">
    ```java title="Create a webhook endpoint for role updates"
    @PostMapping("/webhook")
    public String webhook(@RequestBody String body, @RequestHeader Map<String, String> headers) {
      ObjectMapper mapper = new ObjectMapper();

      try {
        JsonNode node = mapper.readTree(body);
        JsonNode roles = node.get("data").get("roles");
        String email = node.get("data").get("email").asText();

        System.out.println(roles);
        System.out.println(email);
        // Add role to user

      } catch (IOException e) {
        return "error";
      }

      return "ok";
    }
    ```
  </TabItem>

  <TabItem label="Go">
    ```go title="Create a webhook endpoint for role updates"
    mux.HandleFunc("POST /webhook", func(w http.ResponseWriter, r *http.Request) {
        // Read request body
        bodyBytes, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        // Parse webhook payload
        var body struct {
            Data map[string]interface{} `json:"data"`
        }

        err = json.Unmarshal(bodyBytes, &body)
        if err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }

        // Extract user data
        roles := body.Data["roles"]
        email := body.Data["email"]

        fmt.Println("Roles: ", roles)
        fmt.Println("Email: ", email)

        w.WriteHeader(http.StatusOK)
    })
    ```
  </TabItem>
</Tabs>

Refer to all the [directory webhooks](/reference/webhooks/directory-events/) you can subscribe.

================
File: directory/guides/launch-checklist.mdx
================
---
title: Production launch checklist
description: "A comprehensive checklist to ensure your Scalekit integration is production-ready, covering environment variables, security, webhooks, and more."
sidebar:
  label: "Launch checklist"
prev: false
next: false
tableOfContents: false
---

import { Steps } from "@astrojs/starlight/components"
import CheckItem from '@components/ui/CheckItem.astro';

As you prepare to deploy your Scalekit integration to production, it's crucial to verify that all configurations are optimized for security and user experience.

The following checklists help ensure your implementation is production-ready and efficient.

As you prepare to deploy SCIM Provisioning, verify that all configurations are optimized for security and user experience. The following checklist helps ensure your implementation is production-ready and efficient.

<Steps>

1. <CheckItem iconName="approve-check-circle"> **Use appropriate environment variables** </CheckItem>

    Switch from development to production credentials, including the client ID, client secret, and environment URL.

2. <CheckItem iconName="approve-check-circle"> **Secure the client secret** </CheckItem>

    Your client secret is akin to a key to your application. Secure it with the utmost care. Go through our [best practices guide](/guides/client-credentials-practices/) to learn how to manage the client secrets safely and securely.

3. <CheckItem iconName="approve-check-circle"> **Configure webhooks** </CheckItem>

    Setup webhooks for receiving real-time updates on user and group changes. Follow our [webhook security guide](/guides/webhooks-best-practices/) to learn how to secure your webhooks.

4. <CheckItem iconName="approve-check-circle"> **Test provisioning flows** </CheckItem>

    Ensure that you have implemented and tested all possible SCIM Provisioning workflows such as:

    - User provisioning
    - User de-provisioning
    - User profile update
    - Group membership changes
    - Role assignments

5. <CheckItem iconName="approve-check-circle"> **Finalize branding & theming** </CheckItem>

    For a consistent user experience, ensure your branding (logo, colors) are added to the Admin Portal.

6. <CheckItem iconName="approve-check-circle"> **Review Admin Portal URL** </CheckItem>

    Customize the Admin Portal URL to match your domain (for example, `https://admin.hero-saas.app`) for a seamless brand experience. Also, remember to update `.env` file post CNAME configuration. Read [customizing the Admin Portal](/directory/guides/admin-portal) on how to match your brand.

7. <CheckItem iconName="approve-check-circle"> **Graceful error handling** </CheckItem>

    Test thoroughly across all possible edge cases, including incomplete, invalid, or duplicate data.

</Steps>

================
File: directory/guides/scim-protocol.mdx
================
---
title: SCIM overview
description: 'Comprehensive guide to the SCIM (System for Cross-domain Identity Management) protocol. Learn about core components, resources, schemas, and real-world implementation scenarios for identity management across cloud applications.'
sidebar:
  label: 'SCIM protocol'
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

System for Cross-domain Identity Management (SCIM) is an
<a href="https://datatracker.ietf.org/doc/html/rfc7643#section-2" target="_blank">open standard API specification</a> designed
to manage identities across cloud applications easily and scalably. The specification suite builds
upon experience with existing schemas and deployments, emphasizing:

- Simplicity of development and integration
- Application of existing authentication, authorization, and privacy models

Its intent is to reduce the cost and complexity of user management operations by providing:

- A common user schema
- An extension model; e.g., enterprise user
- Binding documents to provide patterns for exchanging this schema using HTTP

## SCIM protocol: Key components

SCIM is a HTTP based protocol and uses structured
<a href="https://datatracker.ietf.org/doc/html/rfc7159" target="_blank">JSON</a> payloads to exchange resource information
between the SCIM client and service provider. To identify the SCIM protocol resources, the
`application/scim+json` media type is used.

### SCIM service provider

SCIM service provider is any business application that provisions users and groups by synchronizing
the changes made in a SCIM client, including creates, updates, and deletes. The synchronization
enables end users to have seamless access to the business application for which they're assigned,
with up-to-date profiles and permissions.

Scalekit acts as the SCIM service provider on your behalf and integrates with your customer's
identity providers or directory providers (e.g. Okta, Azure AD, Google Workspace, etc.) to provision
users and groups.

### SCIM client

SCIM client facilitates provisioning, or managing user lifecycle events, through SCIM endpoints
exposed by the SCIM service provider. Identity providers and HRMS act as very popular SCIM clients
as they are treated as the source of truth for user identity data.

Some of the most common SCIM clients are <a href="https://www.okta.com" target="_blank">Okta</a>,
<a href="https://www.microsoft.com/en-in/security/business/identity-access/microsoft-entra-id" target="_blank">Microsoft Entra ID (aka Azure AD)</a>.

### SCIM endpoints

SCIM endpoints are the entry points to the SCIM API. They are the endpoints that the SCIM client
will call to provision users and groups.

The following are the most popular SCIM endpoints that any SCIM service provider should support:

- `/Users`
- `/Groups`

### SCIM methods

As SCIM is built on top of REST, SCIM methods are the HTTP methods that are used to perform CRUD
operations on the SCIM resources. The following are the most common SCIM methods:

- GET
- POST
- PUT
- PATCH
- DELETE

### SCIM authentication

SCIM uses OAuth 2.0 bearer token authentication to authenticate requests to the SCIM API. The token
is a string that is used to authenticate the SCIM API requests to the SCIM service provider. The
token is passed in the HTTP Authorization header using the Bearer scheme.

## SCIM resources

SCIM resources are the core building blocks of the SCIM protocol. They represent entities such as
users, groups, and organizational units. Each resource has a set of attributes that describe the
entity.

While SCIM user resource has the basic attributes of a user like email address, phone number, and
name, it is extensible by defining new JSON schemas that a service provider can choose to implement.
An enterprise user is an example of a SCIM user extension resource. Enterprise user resource has
attributes such as employee number, department, and manager which are valuable for enterprise
implementation of user management using SCIM v2.

```json title="Example SCIM user representation"
{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "bjensen",
  "name": {
    "givenName": "Barbara",
    "familyName": "Jensen"
  },
  "emails": [
    {
      "value": "bjensen@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "entitlements": [
    {
      "value": "Employee",
      "type": "role"
    }
  ]
}
```

### SCIM schema

SCIM schema is the core of the SCIM protocol. It is a JSON schema that defines the structure of the
SCIM resources. The following are the most common SCIM schemas:

- <a href="https://datatracker.ietf.org/doc/html/rfc7643#section-4.1" target="_blank">Core SCIM user schema</a>
- <a href="https://datatracker.ietf.org/doc/html/rfc7643#section-4.3" target="_blank">Enterprise user schema</a>
- <a href="https://datatracker.ietf.org/doc/html/rfc7643#section-4.2" target="_blank">Group schema</a>

## Putting everything together

Now that you have a high level understanding of the SCIM protocol and different components involved,
let's put everything together to take a scenario of how SCIM protocol facilitates user provisioning
from an identity provider to a SCIM service provider like Scalekit.

### Scenario: New employee onboarding

1. ACME Inc. hires a new employee, John Doe.
2. ACME Inc. adds John Doe to their Okta directory.
3. Okta send a SCIM `POST /Users` request to a pre-registered SCIM service
   provider (your B2B application) with John Doe's information as per the SCIM protocol.
4. You authenticate the request using the OAuth 2.0 bearer token authentication & validate the
   request payload.
5. You provision John Doe as a new user in your B2B application using the user payload.

### Scenario: Employee termination

1. ACME Inc. terminates John Doe's employment.
2. ACME Inc. removes John Doe from their Okta directory.
3. Okta send a SCIM `DELETE /Users/john.doe` request to a pre-registered SCIM
   service provider (your B2B application) as per the SCIM protocol.
4. You authenticate the request using the OAuth 2.0 bearer token authentication & validate the
   request payload.
5. You deactivate John Doe as an existing user in your B2B application using the user payload.

### Scenario: Employee transfer

1. ACME Inc. transfers John Doe to a different department.
2. ACME Inc. updates John Doe's information in their Okta directory.
3. Okta send a SCIM `PATCH /Users/john.doe` request to a pre-registered SCIM
   service provider (your B2B application) as per the SCIM protocol.
4. You authenticate the request using the OAuth 2.0 bearer token authentication & validate the
   request payload.
5. You update John Doe's information in your B2B application using the user payload.

```http title="SCIM create user request"
POST /Users HTTP/1.1
Host: yourapp.scalekit.com/directory/dir_12442/scim/v2
Accept: application/scim+json
Content-Type: application/scim+json
Authorization: Bearer YOUR_SCIM_API_TOKEN

{
    "schemas":["urn:ietf:params:scim:schemas:core:2.0:User"],
    "userName":"bjensen",
    "externalId":"bjensen",
    "name":{
        "formatted":"Ms. Barbara J Jensen III",
        "familyName":"Jensen",
        "givenName":"Barbara"
    }
}
```

## Scalekit's SCIM implementation

Scalekit's SCIM implementation is built upon the principles of simplicity, security, and
scalability. It provides a normalized implementation of the SCIM protocol across different identity
providers & directory providers. This allows you to focus on integrating with Scalekit's API & leave
the complexities of SCIM protocol implementation to us. While not all directory providers implement
SCIM or support all SCIM features, Scalekit aims to abstract these complexities & provide a seamless
experience for provisioning users and groups.

### Webhooks

Scalekit supports webhooks as a mechanism to send real-time updates to your application about user
provisioning and deprovisioning events to your application as and when there are changes detected in
your customer's SCIM compliant directory providers.

We also normalize the webhook payloads across different directory providers to ensure that you can
focus on building your application without having to worry about the nuances of each directory
provider's SCIM implementations.

<Aside type="tip">
Refer to our <a href="/dev-kit/webhooks/event-object/">Webhooks</a> documentation to
learn more on how you can use webhooks to listen for changes in the directory and update the user's
roles in your application.
</Aside>

================
File: directory/guides/user-provisioning-basics.mdx
================
---
title: Understanding SCIM Provisioning
description: 'Learn the fundamentals of SCIM Provisioning and its importance for B2B SaaS applications. Discover how automated user lifecycle management can enhance security, improve efficiency, and meet enterprise requirements.'
sidebar:
  label: 'Understand SCIM'
---

import { Aside, LinkButton } from '@astrojs/starlight/components';

#### The business case for implementing SCIM

Scaling organizations utilize a growing array of applications to support their
employees' productivity. To efficiently and securely manage access to these applications,
organization administrators employ Directory Providers. These providers automate
crucial workflows, such as granting access to new employees or revoking access for departing staff.

Directory providers, like Entra ID (formerly Azure Active Directory), serve as the authoritative
source for user information and access rights. Organizations expect your application to accommodate
their directory provider requirements. Consequently, you must design systems capable of interfacing
with various directory providers used by their customers.

Scalekit serves as an intermediary component in your B2B application architecture, providing a
streamlined interface to access user information programmatically and in real-time.

![User onboarding flow across your app, Scalekit, and directory providers](@/assets/docs/guides/scim-basics/basics.png)

This solution allows your application to:

1. Automatically determine user roles (e.g., admin, member)
2. Retrieve user access permissions
3. Tailor the user experience accordingly and securely

By integrating Scalekit, you can meet enterprise requirements without diverting focus from your core
product development. This approach significantly reduces the engineering effort and time typically
required to implement compatibility with various directory providers.

Explore the compelling reasons to implement SCIM Provisioning in your B2B SaaS app:

<Aside type="tip">
- Automates user lifecycle management, eliminating the need for manual user creation, updates, and
  deletions. This reduces administrative overhead and the potential for human error.
- Enhances security by ensuring prompt revocation of user access when employees leave an
  organization.
- Improves user experience by allowing new employees to gain immediate access to necessary
  applications without waiting for manual account creation. This leads to a smoother onboarding
  process.
- Reduces IT workload by eliminating the need for IT administrators to manually manage user accounts
  across multiple systems. This frees up time for more strategic tasks.
- Ensures user information consistency across the identity provider (IdP) and the B2B application,
  reducing discrepancies and potential security risks.
- Scales to handle increased user numbers as organizations grow, without requiring additional manual
  effort.
- Helps organizations meet various compliance requirements related to user access and data
  protection by maintaining accurate and up-to-date user records.
- Allows for mapping of custom attributes via SCIM, enabling B2B applications to sync specialized
  user data that may be unique to their use case.
</Aside>

Implementing SCIM allows you to offer a more attractive, enterprise-grade solution.

## Next steps

Now that you understand the importance of directories and how implementing SCIM Provisioning can
step up your app to enterprise-grade status, it's time to put this knowledge into action. Here are
some suggested next steps:

1. Dive into our [Quickstart](/directory/scim/quickstart/) guide to learn how to set up SCIM Provisioning for
   your app. This practical guide will walk you through the implementation process step-by-step.
2. Start small by simulating directory events. This hands-on approach allows you to test and
   familiarize yourself with the system without affecting live data.
3. Explore our sample apps to picture all the moving components in a typical app.

<Aside type="note">
Take it one step at a time, and don't hesitate to refer back to our documentation as you progress.
Your efforts will result in a more secure, efficient, and attractive solution for your enterprise
customers. Happy syncing!
</Aside>

================
File: directory/code-examples.mdx
================
---
title: Explore sample apps
description: "Explore sample apps for building an Admin Portal and integrating webhooks. Find code examples to streamline SCIM provisioning and user management."
sidebar:
  label: 'Code examples'
prev: false
next: false
---

import { Aside, LinkButton } from '@astrojs/starlight/components';

Whether you're building an Admin Portal or implementing webhooks, we've got you
covered with practical samples and upcoming language-specific examples.

### Admin Portal

Our [admin portal](/directory/guides/admin-portal) sample demonstrates key features and functionality for
administrative users. It showcase how the admin portal can be integrated with your application to
provide efficient and seamless way for IT admins to configure SCIM Provisioning.

<LinkButton href="https://github.com/scalekit-developers/nodejs-example-apps/tree/main/embed-admin-portal-sample" target="_blank" rel="noopener">
  Check out the sample app
</LinkButton>

### NextJS webhook demo

This sample application built with NextJS illustrates the implementation and usage of webhooks in a
real-world scenario. It provides a practical example of how to integrate webhook functionality into
your projects.

<LinkButton href="https://github.com/scalekit-developers/nextjs-example-apps/tree/main/webhook-events" target="_blank" rel="noopener">
  Check out the sample app
</LinkButton>

================
File: directory/scim-quickstart.mdx
================
---
title: Getting started with SCIM
description: "Learn how to automate user provisioning with SCIM. This guide provides a quickstart for using Scalekit's Directory API and webhooks to sync user data."
sidebar:
  label: "Quickstart"
slug: "directory/scim/quickstart"
prev: false
next: false
---

import { LinkButton, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';


Enterprises need to automatically provision and de-provision employee access to applications to ensure security. Scalekit simplifies this process by providing a single interface to your app, abstracting the complexities of various directory providers.

With [SCIM Provisioning](/directory/guides/user-provisioning-basics) from Scalekit, you can:

- Use **webhooks** to listen for events from your customers' directory providers (e.g., user
  updates, group changes)
- Use **REST APIs** to list users, groups, and directories on demand


  ![SCIM Quickstart](@/assets/docs/common/scim-chart.png)



Scalekit enables you to sync user accounts with the latest data in the directory provider. This
allows you to:

- Create accounts for new hires during onboarding
- Deactivate accounts when employees depart
- Adjust access levels as employees change roles

<Steps>

1. ### User provisioning with Scalekit's directory API

    Scalekit's directory API allows you to fetch information about users, groups, and directories
    associated with an organization on-demand. This is useful for scenarios like running cron jobs to
    sync user and group data. In this guide, we'll demonstrate how to use the list users in a directory
    API to retrieve a list of users in a specific directory.

    Before you begin, ensure that your organization has a directory set up in Scalekit.

    Before diving in, ensure you have:

    1. A Scalekit account
    2. An organization with a configured directory
    3. Access to the Scalekit dashboard

    #### Setting up the SDK

    Scalekit offers language-specific SDKs for fast SSO integration. Use the installation instructions
    below for your technology stack:

    <InstallSDK />

    Navigate to the API config tab in the Scalekit dashboard to obtain your credentials. Store your
    credentials securely in a `.env` file:

    ```shell title=".env"
    SCALEKIT_ENVIRONMENT_URL='https://b2b-app-dev.scalekit.com'
    SCALEKIT_CLIENT_ID='<CLIENT_ID_FROM_SCALEKIT_DASHBOARD>'
    SCALEKIT_CLIENT_SECRET='<SECRET_FROM_SCALEKIT_DASHBOARD>'
    ```

    Initialize the SDK with your API credentials and make your first API call to list organizations.

    <Tabs syncKey="tech-stack">
    <TabItem value="curl" label="cURL">

    ```bash
    curl -L 'https://$ENV_URL/api/v1/organizations?page_size=5' \
    -H 'Authorization: Bearer <ACCESS_TOKEN>'
    ```

    </TabItem>

    <TabItem value="nodejs" label="Node.js">

    ```javascript
    import { ScalekitClient } from '@scalekit-sdk/node';

    const scalekit = new ScalekitClient(
      process.env.SCALEKIT_ENVIRONMENT_URL,
      process.env.SCALEKIT_CLIENT_ID,
      process.env.SCALEKIT_CLIENT_SECRET,
    );

    const { organizations } = await scalekit.organization.listOrganization({
      pageSize: 5,
    });

    console.log(`Name of the a organization: ${organizations[0].display_name}`);
    ```

    </TabItem>

    <TabItem value="python" label="Python">

    ```python
    from scalekit import ScalekitClient

    # Initialize the SDK client
    scalekit_client = ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>'
    )

    org_list = scalekit_client.organization.list_organizations(page_size='100')

    print(f'Organisation details: {org_list[0]}')
    ```

    </TabItem>

    <TabItem value="go" label="Go">

    ```go
    sc := scalekit.NewScalekitClient(
      <SCALEKIT_ENVIRONMENT_URL>,
      <SCALEKIT_CLIENT_ID>,
      <SCALEKIT_CLIENT_SECRET>
    )

    organization, err := sc.Organization.GetOrganization(
      ctx,
      organizationId
    )
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java
    import com.scalekit.ScalekitClient;

    ScalekitClient scalekitClient = new ScalekitClient(
      "<SCALEKIT_ENVIRONMENT_URL>",
      "<SCALEKIT_CLIENT_ID>",
      "<SCALEKIT_CLIENT_SECRET>"
    );

    ListOrganizationsResponse organizations = scalekitClient.organizations().listOrganizations(5, "");
    ```

    </TabItem>
    </Tabs>

2. ### Working with directories

    #### Retrieving a directory

    To begin syncing user and group data, first retrieve the directory associated with your
    organization:

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript
    // Get directory using organization ID and directory ID
    const { directory } = await scalekit.directory.getDirectory('<organization_id>', '<directory_id>');

    // Get directory using organization ID
    const { directory } =
      await scalekit.directory.getPrimaryDirectoryByOrganizationId('<organization_id>');
    ```

    </TabItem>

    <TabItem value="python" label="Python">

    ```python
    # Get directory using organization ID and directory ID
    directory = scalekit_client.directory.get_directory(
      organization_id='<organization_id>', directory_id='<directory_id>'
    )

    # Get directory using organization ID
    primary_directory = scalekit_client.directory.get_primary_directory_by_organization_id(
      organization_id='<organization_id>'
    )
    ```

    </TabItem>

    <TabItem value="go" label="Go">

    ```go
    // Get directory using organization ID and directory ID
    directory, err := sc.Directory().GetDirectory(ctx, organizationId, directoryId)

    // Get directory using organization ID
    directory, err := sc.Directory().GetPrimaryDirectoryByOrganizationId(ctx, organizationId)
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java
    // Get directory using organization ID and directory ID
    Directory directory = scalekitClient.directories().getDirectory("<directoryId>", "<organizationId>");

    // Get directory using organization ID
    Directory directory = scalekitClient.directories().getPrimaryDirectoryByOrganizationId("<organizationId>");
    ```

    </TabItem>
    </Tabs>

    #### Listing users in a directory

    Fetch users within a specific directory:

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript
    const { users } = await scalekit.directory.listDirectoryUsers('<organization_id>', '<directory_id>');
    //  users[0].email has the email of the first user in the directory
    ```

    </TabItem>

    <TabItem value="python" label="Python">

    ```python
    directory_users = scalekit_client.directory.list_directory_users(
      organization_id='<organization_id>', directory_id='<directory_id>'
    )
    ```

    </TabItem>

    <TabItem value="go" label="Go">

    ```go
    options := &ListDirectoryUsersOptions{
        PageSize: 10,
        PageToken: "",
    }

    directoryUsers,err := sc.Directory().ListDirectoryUsers(ctx, organizationId, directoryId, options)
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java
    var options = ListDirectoryResourceOptions.builder()
      .pageSize(10)
      .pageToken("")
      .includeDetail(true)
      .build();

    ListDirectoryUsersResponse usersResponse = scalekitClient
      .directories()
      .listDirectoryUsers(directory.getId(), organizationId, options);
    ```

    </TabItem>
    </Tabs>

    **Example Use Case**: When setting up a new customer account, you can use this function to
    automatically connect to their directory and start syncing user data.

    #### Listing groups

    Retrieve groups within a directory:

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript
    const { groups } = await scalekit.directory.listDirectoryGroups(
      '<organization_id>',
      '<directory_id>',
    );
    ```

    </TabItem>

    <TabItem value="python" label="Python">

    ```python
    directory_groups = scalekit_client.directory.list_directory_groups(
      directory_id='<directory_id>', organization_id='<organization_id>'
    )
    ```

    </TabItem>

    <TabItem value="go" label="Go">

    ```go
    options := &ListDirectoryGroupsOptions{
        PageSize: 10,
        PageToken:"",
    }

    directoryGroups, err := sc.Directory().ListDirectoryGroups(ctx, organizationId, directoryId, options)
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java
    var options = ListDirectoryResourceOptions.builder()
      .pageSize(10)
      .pageToken("")
      .includeDetail(true)
      .build();

    ListDirectoryGroupsResponse groupsResponse = scalekitClient
      .directories()
      .listDirectoryGroups(directory.getId(), organizationId, options);
    ```

    </TabItem>
    </Tabs>

    **Example Use Case**: You can use this function to implement role-based access control in your
    application, assigning permissions based on the groups a user belongs to.

    Scalekit's Directory API provides a simple way to fetch user and group information on-demand. Refer
    to our <a href="https://docs.scalekit.com/apis" target="_blank" rel="noopener noreferrer">API reference</a> and [examples](/directory/code-examples/) to explore more
    capabilities.

3. ### Realtime user provisioning with webhooks

    #### Create a webhook endpoint

    To receive realtime events from directory providers, create a webhook endpoint and register it in the Scalekit dashboard. The secret to verify the webhook payload will be available in the Scalekit dashboard (&rarr;   _Webhooks_) after the endpoint is registered.

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript
    app.post('/webhook', async (req, res) => {
      // Parse the JSON body of the request
      const event = req.body;
      const { email, name } = event.data;
      const headers = req.headers;
      const secret = process.env.SCALEKIT_WEBHOOK_SECRET;

      try {
        // Verify the webhook payload using the secret, headers, and event data
        await scalekit.verifyWebhookPayload(secret, headers, event);
      } catch (error) {
        // Return a 400 response if the signature is invalid
        return res.status(400).json({ error: 'Invalid signature' });
      }

      // Call a function to perform business logic
      await createUserAccount(email, name);

      // Return a JSON response with a status code of 201
      res.status(201).json({ message: 'User account created' });
    });
    ```

    </TabItem>

    <TabItem value="python" label="Python">

    ```python
    from fastapi import FastAPI, Request

    app = FastAPI()

    @app.post("/webhook")
    async def api_webhook(request: Request):
        headers = request.headers
        body = await request.json()

        print(
            scale.verify_webhook_payload(
                secret='<secret>', headers=headers, payload=json.dumps(body).encode('utf-8')
            )
        )
        # business logic to create user account
        await create_user_account(email, name);

        response = JSONResponse(status_code=201, content='')
        return response
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java
    @PostMapping("/webhook")
    public String webhook(@RequestBody String body, @RequestHeader Map<String, String> headers) {
      String secret = "<WEBHOOK SECRET>";
      boolean valid = scalekit.webhook().verifyWebhookPayload(secret, headers, body.getBytes());
      if (!valid) {
        return "error";
      }
      ObjectMapper mapper = new ObjectMapper();
      try {
        JsonNode node = mapper.readTree(body);
        String object = node.get("object").asText();
        JsonNode data = node.get("data");
        System.out.println("Object: " + object);
        System.out.println("Data: " + data);
        //business logic on data goes here
      } catch (IOException e) {
        return "error";
      }
      return "ok";
    }
    ```

    </TabItem>

    <TabItem value="go" label="Go">

    ```go
    webhookSecret := os.Getenv("SCALEKIT_WEBHOOK_SECRET")
    mux.HandleFunc("POST /webhook", func(w http.ResponseWriter, r *http.Request) {
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }
        headers := map[string]string{
            "webhook-id":        r.Header.Get("webhook-id"),
            "webhook-signature": r.Header.Get("webhook-signature"),
            "webhook-timestamp": r.Header.Get("webhook-timestamp"),
        }
        _, err = sc.VerifyWebhookPayload(webhookSecret, headers, body)
        if err != nil {
            http.Error(w, err.Error(), http.StatusUnauthorized)
            return
        }
        w.WriteHeader(http.StatusOK)
    })
    ```

    </TabItem>
    </Tabs>

    In this example, the endpoint URL is `https://www.your-app.app/api/webhook/user-access`

    When the endpoint receives an HTTP POST request with event data, it extracts the name and email from
    the payload and calls `createUserAccount()` to perform the necessary business
    logic — in this case, creating a user account.

    #### Register webhook endpoint

    First, navigate to the "Webhooks" tab in the Scalekit Dashboard. Click on the "+Add Endpoint" button and enter the endpoint URL along with a meaningful description. Finally, select the desired event types, for example `organization.directory.user_created`, to subscribe to the relevant events.

    Click "Create" Once registered, the webhook endpoint will start receiving event payloads from the directory providers.

    Refer to the <a href="https://docs.scalekit.com/apis" target="_blank" rel="noopener noreferrer">API reference</a> for the list of all available event types and
    [setting up webhooks](/reference/webhooks/directory-events) to explore testing webhooks with test endpoints.

    #### Receive event payloads

    Scalekit sends event payloads to your app for consumption and standardizes the payload structure
    across different directory providers your customers may use.Since we subscribed to user events,
    let's log an example of a new hire gaining access to your app when Scalekit sends a user creation
    event.

    See [Webhook events](/reference/webhooks/event-object/) for the list of all available event types.

    You have now successfully created and registered a webhook endpoint, allowing your app to receive
    real-time events to automate user provisioning.

    <Aside type="note">
    We attempt to deliver a message using an exponential backoff retry policy until we receive a successful 200/201 response code from your servers.
    Each webhook message is attempted based on the following schedule, where each attempt period is after the previous failed attempt:

    - Immediately
    - 5 seconds
    - 5 minutes
    - 30 minutes
    - 2 hours
    - 5 hours
    - 10 hours
    - 10 hours
    </Aside>

</Steps>

================
File: fsa/guides/app-roles.mdx
================
---
title: "Assign application roles to users"
description: "Learn how to define, assign, and manage user roles in Scalekit for granular access control."
sidebar:
  label: "Roles"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
---
import { Tabs, TabItem, Badge, Aside, LinkCard } from '@astrojs/starlight/components';

B2B applications often require different levels of access for different users. Roles are a powerful way to manage these permissions and ensure that users can only access the features and data appropriate for them.

For example, you might have roles like:
- **Admin**: Can access all features, including billing and user management.
- **Editor**: Can create and edit content, but cannot manage users or settings.
- **Viewer**: Can only view content, but cannot make any changes.

Scalekit provides a flexible role-based access control (RBAC) system that allows you to define custom roles and assign them to users, helping you build a secure and scalable application.

## How roles work

By default, Scalekit provides two roles: `admin` and `member`. When the first user signs up and creates an organization, they are automatically assigned the `admin` role. Any subsequent users who join the organization are assigned the `member` role by default.

## Managing roles

You can manage roles, including creating custom ones, from the Scalekit dashboard:

1.  Navigate to **User Management** > **Roles**.
2.  You will see a list of existing roles. Click **+ Add Roles** to create a new role.
3.  For each new role, you can define a **Display Name**, **Name**, and **Description**. The **Name** is what you will receive in the token and use in your application to control access.

![](@/assets/docs/fsa/user-management/1-roles-v3.png)

<LinkCard
  title="Integrate with Scalekit"
  href="/fsa/quickstart/"
  description="Follow our quickstart guide to integrate Scalekit into your application and start managing user roles."
/>

You can change the default role for both the organization creator and new members at any time in the **User Management → Roles** section of the dashboard.

## Accessing user roles

Once a user is authenticated, their assigned roles are included in the `idToken` and `accessToken`. You can use this information in your application's backend to control access to different resources.

The `roles` claim in the tokens contains the role key as **name** (not the display name). For example, if you create a role with the key `"editor"` and display name `"Content Editor"`, the token will contain `"editor"` in the roles array.

While the `roles` claim is an array, Scalekit currently supports a single role per user within an organization.

Here's an example of a decoded `idToken` containing the `roles` claim:

<Tabs>
<TabItem label="ID Token (decoded)" value="idToken">
```json
{
  "amr": [
    "conn_123456789012345678"
  ],
  "at_hash": "QwertyUioP",
  "aud": [
    "skc_987654321098765432"
  ],
  "azp": "skc_987654321098765432",
  "c_hash": "A1b2C3d4E5",
  "client_id": "skc_987654321098765432",
  "email": "john.doe@example.com",
  "email_verified": true,
  "exp": 1753441845,
  "family_name": "Doe",
  "given_name": "John",
  "iat": 1750849845,
  "iss": "http://example.localhost:8889",
  "name": "John Doe",
  "oid": "org_987654321098765432",
  "roles": [
    "member"
  ],
  "sid": "ses_987654321098765432",
  "sub": "usr_987654321098765432"
}
```
</TabItem>
<TabItem label="Access Token (decoded)" value="accessToken">
```json
{
  "aud": [
    "skc_987654321098765432"
  ],
  "client_id": "skc_987654321098765432",
  "exp": 1750850145,
  "iat": 1750849845,
  "iss": "http://example.localhost:8889",
  "jti": "tkn_987654321098765432",
  "nbf": 1750849845,
  "roles": [
    "member"
  ],
  "sid": "ses_987654321098765432",
  "sub": "usr_987654321098765432",
  "xuid": "john.doe"
}
```
</TabItem>
</Tabs>

With the role information readily available in the tokens, you can implement fine-grained access control in your application logic.

================
File: fsa/guides/auth-methods.mdx
================
---
title: "Authentication methods"
description: "Learn how to configure various authentication methods in Scalekit, including passwordless, social logins, and enterprise SSO, to provide flexible and secure access for your users."
sidebar:
  label: "Overview"
tableOfContents: false
next: false
prev:
  label: "Quickstart"
  link: "/fsa/quickstart/"
---
import { CardGrid, LinkCard, Badge } from '@astrojs/starlight/components';

Authentication is how a user proves their identity before your application grants access. In B2B scenarios the stakes are higher: one user can belong to multiple organizations, each with its own security policy. Scalekit lets you offer several authentication methods so every organization—and every user—can sign in the way that works best for them.

- **Multiple sign-in options**: Offer passwordless, social logins, or enterprise SSO so users can choose their preferred method.
- **Admin-enforced policies**: Organization administrators restrict members to specific methods (for example, SSO-only for employees). <Badge type="note" text="Coming soon" />
- **Bring-your-own login page**: Embed your own UI while Scalekit handles the secure identity verification flow behind the scenes.
- **Progressive rollout**: Enable additional methods without deploying new code—turn features on or off from the Scalekit dashboard.

Choose from the following options:

<CardGrid>

  <LinkCard
    title="Passwordless"
    href="/fsa/guides/passwordless/"
    description="Users sign in using verification code (OTP) or a secure magic link sent to their email."
  />

  <LinkCard
    title="Social logins"
    href="/fsa/guides/social-logins/"
    description="Users sign in using their existing accounts from popular social media platforms like Google or GitHub."
  />
  <LinkCard
    title="Enterprise SSO"
    href="/fsa/guides/enterprise-sso/"
    description="Users sign in with their organization's Single Sign-On (SSO) credentials."
  />

</CardGrid>

================
File: fsa/guides/automated-user-provisioning.mdx
================
---
title: Automated user provisioning
description: Automatically provision users when they sign up using social logins and passwordless authentication
sidebar:
  label: 'Automated user provisioning'
  badge: 'Soon'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: 'JIT Provisioning'
  link: '/fsa/guides/just-in-time-provisioning/'
next:
  label: 'Organization switching'
  link: '/fsa/guides/organization-switching/'
---

import { Steps, Aside, LinkCard, Badge } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

Automated user provisioning allows users to be automatically added to organizations when they sign up using non-SSO authentication methods such as social logins (Google, GitHub, Microsoft) or passwordless authentication. Unlike JIT provisioning which works with SSO connections, this feature provides an organization switcher interface where users can join organizations based on their email domain.

## Introduction

Automated user provisioning is particularly useful for applications that support multiple authentication methods and want to provide seamless organization membership for users authenticating through social providers or passwordless methods.

{/* TODO: Add illustration showing automated user provisioning flow */}

When a user signs up or signs in using social logins or passwordless authentication, Scalekit can automatically:

1. **Match email domains** - Check if the user's email domain matches configured allowed domains for an organization
2. **Present organization options** - Show the user available organizations they can join through an organization switcher
3. **Enable user choice** - Allow users to select which organization to join or create a new one
4. **Create organization membership** - Automatically add the user to their selected organization

This process provides flexibility for users who may work across multiple organizations or need to create their own workspace.

## Enabling automated user provisioning

Automated user provisioning must be configured for each organization by setting allowed email domains. You can configure this through the Scalekit Dashboard or programmatically using the API.

### Enable via Dashboard <Badge type="note" text="Coming soon" />

<Steps>

1. Log in to your [Scalekit Dashboard](https://app.scalekit.com).
2. Navigate to **Organizations** and select the organization.
3. Go to **Settings** and find the **Automated Provisioning** section.
4. Configure the allowed email domains for automatic provisioning.

</Steps>

### Enable via API

You can also configure automated user provisioning programmatically using the Scalekit API:

<InstallSDK />

```javascript title="Configure allowed domains"
// Coming soon - API to configure allowed email domains
```

## Supported authentication methods

Automated user provisioning works with the following authentication methods:

- **Social logins** - Google, Microsoft, GitHub, LinkedIn, and other social providers
- **Passwordless authentication** - Magic link and OTP-based authentication

Users authenticate with their preferred method and are then presented with organization options based on their email domain.

## What's next?

- Learn about [organization switching](/fsa/guides/organization-switching/) capabilities for users who belong to multiple organizations
- Explore [JIT provisioning](/fsa/guides/just-in-time-provisioning/) for SSO-based workflows
- Set up [social logins](/fsa/guides/social-logins/) for your application

================
File: fsa/guides/enterprise-sso.mdx
================
---
title: Enterprise SSO
description: How to configure enterprise SSO for your application
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: "Enterprise SSO"
prev:
  label: "Social logins"
  link: "/fsa/guides/social-logins/"
next:
  label: "Admin Portal"
  link: "/guides/sso/admin-portal/"
---
import { Steps, Tabs, TabItem, Aside, LinkCard, Badge } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Enterprise SSO allows users to sign in to your application using their organization's identity provider (IdP), such as Okta, Azure AD, or Google Workspace. This provides a secure and seamless authentication experience for your enterprise customers.

![How Scalekit connects your application to enterprise identity providers](@/assets/docs/sso-quickstart/how-scalekit-connects.png)

This guide shows you how to enable enterprise SSO for your customers.

This guide shows you how to enable each passwordless login method. You should complete the [quickstart guide](/fsa/quickstart/) before following this guide, as it covers building a sign-in page that combines Scalekit's hosted UI.

## Onboard your enterprise customer

To enable SSO for a customer, you first need to create an Organization for them in Scalekit. Once the organization is created, you can provide them access to the Admin Portal where they can configure their own IdP settings.

Scalekit provides two flexible ways to give your customers access to the Admin Portal:

**Option 1: Shareable Link (No-Code)**
1. Log in to your [Scalekit Dashboard](https://app.scalekit.com).
2. Navigate to the "Organizations" tab and create a new organization for your customer.
3. Select the organization and click "Generate Link" to create a shareable Admin Portal link.
4. Share this link with your customer's IT admin through email, Slack, or other communication channels.

**Option 2: Embedded Portal**
You can also embed the Admin Portal directly within your application using an iframe, allowing customers to configure their SSO settings without leaving your app.

Your customer can then use either approach to access a self-service portal and set up their SSO connection.

![Admin Portal Link Generation](@/assets/docs/home/admin-portal/1-admin-portal-v2.png)

Once they have configured their IdP, the connection will be active for their organization and will appear in your list of enterprise connections.

![Enterprise Connections UI](@/assets/docs/fsa/auth-methods/enterpise-sso-1.png)

<Aside type="note" title="Testing SSO Integration">
  During development, you don't need to manually configure each identity provider your customers might use. Scalekit provides an IdP simulator that helps you test the SSO flow easily. Learn more about [testing your SSO integration](/sso/guides/test-sso/).
</Aside>

## Organization domain verification

When you verify organization domains, users can sign in directly through their organization's identity provider from the sign-in page. Scalekit uses the domain part of their email address (for example, `@megacorp.org`) to automatically redirect them to the correct identity provider for authentication. Also called Home Realm Discovery.

**Organization admins** can verify domains through the [admin portal](/guides/sso/admin-portal/). Once verified, any user with an email address from that domain can use SSO.

1. **DNS verification**: Add a DNS TXT record to prove domain ownership. The Admin Portal guides you through each step of adding the record. Once you add the record correctly, Scalekit automatically completes the verification. <Badge type="note" text="Coming soon" />
2. **Manual verification**: Request domain verification through the Scalekit Dashboard. This method is suitable when you have already verified domain ownership through other means.

## What's next?

- Learn more about the [Admin Portal](/guides/sso/admin-portal/) and its customization options.
- [Customize the login page](/fsa/guides/login-page-branding/) to match your brand's design and style.
- Explore our [SSO integration guides](/guides/integrations/sso-integrations/) for specific identity provider configurations.

================
File: fsa/guides/implement-login.mdx
================
---
title: "Implement user login"
description: "Learn how to integrate Scalekit to handle user login, covering multiple authentication methods, organization policies, and secure session creation."
sidebar:
  label: "Implement login"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
next: false
---
import { Card, CardGrid, Steps, TabItem, Tabs, Aside, LinkCard } from '@astrojs/starlight/components';
import CheckItem from '@/components/ui/CheckItem.astro';
import { InstallSDKSection, EnvSection, RedirectAuthPageSection, RetrieveUserDetailsSection, CreateSessionSection } from '@components/templates';

log in is how users access your application after verifying their identity. For B2B applications, log in involves additional complexity as users may belong to multiple organizations and each organization may have different authentication requirements.

Here are some common log in use cases:

- **Multiple authentication methods**: Users can choose different authentication methods to log in, such as passwordless, their choice of social login, or enterprise SSO.
- **Organization-enforced policies**: Organization administrators can enforce log in policies, such as requiring specific authentication method for certain users or authenticating users through their identity provider.
- **Cross-organization access**: A user can log in to access multiple organizations or workspaces within your application.
- **Invitation-based access**: A user signs in for the first time after accepting an email invitation to join an organization.
- **Enterprise SSO integration**: Users authenticate through their corporate identity provider (e.g., Okta, Azure AD) instead of traditional username/password.

Scalekit helps you implement all such signup flows while handling the complexity of user management and authentication.


<div>
   **Before you begin**
  <CheckItem iconName="external">
     [Set up your Scalekit account](https://app.scalekit.com/ws/signup)
  </CheckItem>
  <CheckItem iconName="github">
     [Clone a sample application from GitHub](https://github.com/scalekit-developers/nodejs-example-apps/tree/main/expressjs-loginbox-authn)
  </CheckItem>
</div>

Let's get started!

<Steps>
 1. ## Install the Scalekit SDK

    <InstallSDKSection />

    Copy your API credentials from the Scalekit dashboard's API Config section and set them as environment variables.
    ```bash
    SCALEKIT_ENVIRONMENT_URL='<YOUR_ENVIRONMENT_URL>'
    SCALEKIT_CLIENT_ID='<ENVIRONMENT_CLIENT_ID>'
    SCALEKIT_CLIENT_SECRET='<ENVIRONMENT_CLIENT_SECRET>'
    ```

    Create a new Scalekit client instance.
    <EnvSection />

  2. ## Redirect to the login page
       Generate the authorization URL to redirect users to the Scalekit-hosted login page. To get a `refreshToken` for session management, ensure you include `offline_access` in the scopes.

      <Tabs syncKey="tech-stack">
        <TabItem value="curl" label="cURL">
          ```sh
          curl -G -v --location "<SCALEKIT_ENVIRONMENT_URL>/oauth/authorize" \
          --data-urlencode 'grant_type=authorization_code' \
          --data-urlencode "organization_id={organization_id}" \
          --data-urlencode "response_type=code" \
          --data-urlencode "scope=openid profile" \
          --data-urlencode 'redirect_uri=https://your-app.com/callback' \
          --data-urlencode "client_id={client_id}" \
          --data-urlencode "state=random_state_value"
          ```
        </TabItem>
        <TabItem value="node" label="Node.js">
          ```javascript title="Express.js" wrap "authorizationUrl" ins={3} {"Redirect user to Scalekit's authentication page":8}
          const redirectUri = 'http://localhost:3000/api/callback';
          const options = {
            scopes: ['openid', 'profile', 'email', 'offline_access'],
          };

          const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);


          res.redirect(authorizationUrl);
          ```
          <Aside type="note">
        Pass `prompt: 'login'` as an option to explicitly to force the log in flow even if they are already logged in.
      </Aside>
        </TabItem>
        <TabItem value="python" label="Python">
          ```python title="Flask"
          from scalekit import AuthorizationUrlOptions

          redirect_uri = 'http://localhost:3000/api/callback'
          options = AuthorizationUrlOptions()
          options.scopes = ['openid', 'profile', 'email', 'offline_access']

          authorization_url = scalekit.get_authorization_url(redirect_uri, options)

          # For web frameworks like Flask/Django:
          # return redirect(authorization_url)
          ```
          <Aside type="note">
        Pass `prompt='login'` as an option to explicitly to force the log in flow even if they are already logged in.
      </Aside>
        </TabItem>
        <TabItem value="go" label="Go">
          ```go title="Gin"
          redirectUri := "http://localhost:3000/api/callback"
          options := scalekit.AuthorizationUrlOptions{
              Scopes: []string{"openid", "profile", "email", "offline_access"},
          }

          authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)
          if err != nil {
              // handle error appropriately
              panic(err)
          }

          // For web frameworks like Gin:
          // c.Redirect(http.StatusFound, authorizationUrl.String())
          ```
          <Aside type="note">
        Pass `Prompt: "login"` as an option to explicitly to force the log in flow even if they are already logged in.
      </Aside>
        </TabItem>
        <TabItem value="java" label="Java">
          ```java title="Spring"
          import com.scalekit.internal.http.AuthorizationUrlOptions;
          import java.net.URL;
          import java.util.Arrays;

          String redirectUri = "http://localhost:3000/api/callback";
          AuthorizationUrlOptions options = new AuthorizationUrlOptions();
          options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));

          URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
          ```
          <Aside type="note">
        Pass `options.setPrompt("login")` as an option to explicitly to force the log in flow even if they are already logged in.
      </Aside>
        </TabItem>
      </Tabs>


     This will redirect the user to Scalekit's hosted sign-in page.



3. ## Handle user authentication
      Users can now log in using their preferred method. Scalekit handles the authentication details based on your configuration.

      ![](@/assets/docs/fsa/quickstart/1.png)

      <LinkCard
        title="Configure Authentication Methods"
        href="/fsa/guides/auth-methods/"
        description="Learn how to enable and customize passwordless, social, and enterprise SSO login options."
      />

4. ## Retrieve user profile
      After identity verification, Scalekit triggers a callback to your `redirect_uri` with an authorization code. Exchange this code to get the user's profile.

      <RetrieveUserDetailsSection />

      The `authResult` contains the user's profile and the necessary tokens to create a session.

      <details>
      <summary>View ID token in `authResult`</summary>
      ```json title="ID Token (decoded JWT) example" showLineNumbers=false
        {
          "amr": [
            "conn_123456789012345678"
          ],
          "at_hash": "QwertyUioP",
          "aud": [
            "skc_987654321098765432"
          ],
          "azp": "skc_987654321098765432",
          "c_hash": "A1b2C3d4E5",
          "client_id": "skc_987654321098765432",
          "email": "john.doe@example.com",
          "email_verified": true,
          "exp": 1753441845,
          "family_name": "Doe",
          "given_name": "John",
          "iat": 1750849845,
          "iss": "http://example.localhost:8889",
          "name": "John Doe",
          "oid": "org_987654321098765432",
          "roles": [
            "member"
          ],
          "sid": "ses_987654321098765432",
          "sub": "usr_987654321098765432"
        }
        ```
      </details>

4. ## Create a user session
      With the user's identity verified, you can now establish a session. This typically involves storing the tokens securely and using them to manage the user's authenticated state.

      <CreateSessionSection />

</Steps>

## What's next?

You have successfully implemented the login flow. Now you can:
- [Manage user sessions](/fsa/guides/manage-session/) to handle token refreshes and expirations.
- [Implement a secure logout flow](/fsa/guides/logout/).
- Explore the normalized [user profile schema](/fsa/reference/user-profile/).

================
File: fsa/guides/implement-signup.mdx
================
---
title: "Implement user sign up"
description: "Learn how to handle new user signups with Scalekit, either through the managed UI or programmatically via API."
sidebar:
  label: "Set up user sign up"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
next: false
---
import { Card, CardGrid, Steps, TabItem, Tabs, Aside, LinkCard, LinkButton } from '@astrojs/starlight/components';
import { InstallSDKSection, EnvSection, RedirectAuthPageSection, RetrieveUserDetailsSection, UserProfileSection, CreateUserMembershipSection, CreateOrganizationSection } from '@components/templates';

Signup is the first step in a user's journey with your application. For B2B applications, each user may be associated with an organization. A user can belong to one or more organizations.

Here are some common signup use cases:

- **New user and organization**: The first user to sign up creates a new organization and becomes its administrator.
- **Joining an existing organization**: An existing user can join another organization or workspace within your application.
- **Invitation-based signup**: A new user signs up by accepting an email invitation and is automatically added to the inviting organization.
- **Automatic organization joining**: A user with a corporate email (e.g., `jane.doe@acme.com`) signs up and is prompted to join the existing "ACME Inc." organization.
- **User provisioning via identity provider**: A user account is created programmatically through an enterprise identity provider (e.g., Okta, Azure AD). The user first logs in via SSO instead of a traditional signup.

Scalekit helps you implement all such signup flows while handling the complexity of user management and authentication.



## Sign up with Scalekit's hosted signup page

You can direct users to Scalekit's managed signup page by adding the `prompt: 'create'` parameter when generating the authorization URL. This is the simplest way to implement a signup flow.

<Steps>
 1. ### Install the Scalekit SDK

    <InstallSDKSection />

    Copy your API credentials from the Scalekit dashboard's API Config section and set them as environment variables.
    ```bash
    SCALEKIT_ENVIRONMENT_URL='<YOUR_ENVIRONMENT_URL>'
    SCALEKIT_CLIENT_ID='<ENVIRONMENT_CLIENT_ID>'
    SCALEKIT_CLIENT_SECRET='<ENVIRONMENT_CLIENT_SECRET>'
    ```

    Create a new Scalekit client instance after initializing the environment variables.
    <EnvSection />
  2. ### Redirect the user to the sign up page
       Generate the authorization URL by passing a [registered](/fsa/reference/redirects) _callback URL_ and _scopes_ to the Scalekit SDK.
       <RedirectAuthPageSection />
     This will redirect the user to Scalekit's managed sign-in page.

3. ### Allow users to sign up
      Users can now sign in or sign up using their [preferred authentication methods](/fsa/guides/auth-methods). Each authentication method is managed by Scalekit to successfully verify the user's identity.

      <LinkCard
        title="Configure authentication methods"
        href="/fsa/guides/auth-methods/"
        description="Enable passwordless, social, or enterprise SSO to customize the signup experience."
      />

4. ## Retrieve user profile after identity verification
      Scalekit triggers a callback to your registered _callback URL_ with an authorization code. Exchange the code to get the user's profile information.
      <RetrieveUserDetailsSection />

      The `authenticateWithCode` method returns an object containing the user's profile information (`user` object) and `idToken` (JWT).
      <UserProfileSection />

      You can [decode the `idToken`](https://authplay.io/pg/token-explorer) to access user information like email, name, and profile verification status directly from the token claims.
</Steps>

After the user signs up, they are redirected back to your application, and you can proceed to [create a session](/fsa/guides/implement-login/#create-a-user-session).

================
File: fsa/guides/just-in-time-provisioning.mdx
================
---
title: Just-in-time provisioning
description: Automatically provision users when they sign in through SSO for the first time
sidebar:
  label: "JIT Provisioning"
  badge: "Soon"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: "Manage organizations"
  link: "/fsa/guides/manage-organization/"
next:
  label: "Automated user provisioning"
  link: "/fsa/guides/automated-user-provisioning/"

---

import { Steps, Aside, LinkCard, Badge } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

Just-in-time (JIT) provisioning automatically creates users and organization memberships when they sign in through SSO for the first time. This feature allows users to access your application without requiring manual invitations from IT administrators. For example, users don't need to remember separate credentials or go through additional signup steps - they just sign in through their familiar SSO portal. Your app signs them up instantly.

## Introduction

JIT provisioning is particularly useful for enterprise customers who want to provide seamless access to your application for their employees while maintaining security and control through their identity provider.

{/* TODO: Add illustration showing JIT provisioning flow */}


When a user signs in through SSO for the first time, Scalekit automatically:

1. **Detects the verified domain** - Scalekit checks if the user's email domain matches a verified domain in the organization
2. **Creates the user account** - A new user profile is created using information from the identity provider
3. **Establishes membership** - The user is automatically added as a member of the organization
4. **Completes authentication** - The user is signed in and redirected to your application

This process happens seamlessly in the background, providing immediate access without manual intervention.

## Enabling JIT provisioning

JIT provisioning must be enabled for each organization that wants to use this feature. You can enable it through the Scalekit Dashboard or programmatically using the API.

### Enable via Dashboard <Badge type="note" text="Coming soon" />

<Steps>

1. Log in to your [Scalekit Dashboard](https://app.scalekit.com).
2. Navigate to **Organizations** and select the organization.
3. Go to **Settings** and find the **JIT Provisioning** section.
4. Toggle the setting to enable JIT provisioning for this organization.

</Steps>

### Enable via API

You can also enable JIT provisioning programmatically using the Scalekit API:

<InstallSDK />

```javascript title="Enable JIT provisioning"
// Coming soon - API to enable JIT provisioning
```

## Domain verification requirement

JIT provisioning only works for users whose email domains have been verified by the organization. This ensures that only legitimate members of the organization can automatically gain access to your application.

**Organization admins** can verify domains through the [admin portal](/guides/sso/admin-portal/). Once verified, any user with an email address from that domain can use JIT provisioning when signing in through SSO.

<Aside type="note">
Learn more about [domain verification](/fsa/guides/enterprise-sso/#organization-domain-verification) in the Enterprise SSO guide.
</Aside>



{/*

TODO: Uncomment after invite-only signup is published + reviewed

## Guest users

JIT provisioning has limitations for guest users whose email domains have not been verified by the organization:

- **Contractors and external users** with unverified email domains cannot use JIT provisioning
- These users must be [manually invited](/fsa/guides/invite-only-signup/) to join the organization before they can sign in through SSO
- This ensures security by preventing unauthorized users from automatically gaining access

*/}




## What's next?

- Learn about [Automated User Provisioning](/fsa/guides/automated-user-provisioning/) for non-SSO authentication methods
- Explore [Enterprise SSO](/fsa/guides/enterprise-sso/) setup and configuration
- Set up [organization switching](/fsa/guides/organization-switching/) for users who belong to multiple organizations

================
File: fsa/guides/login-page-branding.mdx
================
---
title: "Customize the login page"
description: "Learn how to customize the look and feel of your Scalekit-managed login page to match your brand."
sidebar:
  label: "Brand your login page"
prev:
  label: "Social logins"
  link: "/fsa/guides/social-logins/"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
tableOfContents: false
---
import { Aside } from '@astrojs/starlight/components';

Create a consistent and branded authentication experience for your users by customizing the Scalekit-managed login page. You can modify various elements to align the page with your application's look and feel.

![Customizing the login page in the Scalekit dashboard](@/assets/docs/fsa/branded-login-page.png)

From the **Customization** section in your Scalekit dashboard, you can adjust the following settings:

-   **Logo**: Upload your company's logo to be displayed on the sign-in box.
-   **Favicon**: Set a custom favicon for the browser tab.
-   **Border Radius**: Adjust the roundness of the login box corners (e.g., Small, Medium, Large).
-   **Logo Position**: Choose whether your logo appears inside or outside the main login box.
-   **Logo Alignment**: Align your logo to the left, center, or right.
-   **Header Text Alignment**: Align the main header text ("Login to your account") to the left, center, or right.
-   **Social Login Placement**: Control the positioning of social login buttons.
-   **And many more**: Additional customization options are available on-request to fine-tune your login page's appearance.

<Aside type="tip" title="Private Beta">
These customization features are currently in private beta. Please [contact our support team](/support/contact-us/) to have them enabled for your account.
</Aside>

================
File: fsa/guides/logout.mdx
================
---
title: "Secure logout"
description: "Learn how to securely log out users from your application and invalidate their sessions with Scalekit."
sidebar:
  label: "Implement logout"
prev:
  label: "Manage sessions"
  link: "/fsa/guides/manage-session/"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
---

import { Aside, Badge, Steps, Tabs, TabItem, Card } from '@astrojs/starlight/components';

Securely logging a user out is a critical part of session management. A complete logout process involves two main actions:
1.  **Clearing the application session**: Removing session tokens from your application's storage (e.g., browser cookies and backend database).
2.  **Invalidating the Scalekit session**: Informing Scalekit to end the user's session on its servers.


## User-initiated logout

This is the standard flow where a user clicks a "Logout" button in your application.

![](@/assets/docs/fsa/logout/1.png)

<Steps>
1. #### Create a logout endpoint
   Your application should have an endpoint, like `/logout`, that handles the logout logic.

2. #### Clear the application session
   First, clear all session data stored by your application. This includes the `accessToken` from cookies and the `refreshToken` from your database.

    <Tabs syncKey="tech-stack">
      <TabItem label="Node.js">
        ```javascript title="Express.js"
        // A function to clear session data
        async function clearSessionData(res, userId) {
          // Clear the access token cookie
          res.clearCookie('accessToken');

          // Remove the refresh token from your database
          await db.deleteRefreshToken(userId);
        }

        app.get('/logout', (req, res) => {
          // Assuming you have the user's ID from a verified session
          const userId = req.user.id;
          const idToken = req.cookies.idToken; // Or retrieve from session
          clearSessionData(res, userId);

          // Proceed to invalidate the Scalekit session...
        });
        ```
      </TabItem>
      <TabItem label="Python">
        ```python title="Flask"
        from flask import Flask, session, request, redirect, make_response
        from scalekit import LogoutUrlOptions

        app = Flask(__name__)

        @app.route('/logout')
        def logout():
            user_id = session.get('user_id')
            id_token = request.cookies.get('idToken')
            post_logout_redirect_uri = 'http://localhost:3000/login'

            # Clear local session data
            response = make_response()
            clear_session_data(response, user_id)

            # Generate the Scalekit logout URL
            logout_url = scalekit.get_logout_url(
                LogoutUrlOptions(
                    id_token_hint=id_token,
                    post_logout_redirect_uri=post_logout_redirect_uri
                )
            )

            # Redirect to Scalekit to complete the logout
            return redirect(logout_url)
        ```
      </TabItem>
      <TabItem label="Go">
        ```go title="Gin"
        func logoutHandler(c *gin.Context) {
            userID := c.GetString("user_id")
            idToken, _ := c.Cookie("idToken")
            postLogoutRedirectURI := "http://localhost:3000/login"

            // Clear local session data
            if err := clearSessionData(c, userID); err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }

            // Generate the Scalekit logout URL
            logoutURL, err := scalekit.GetLogoutUrl(LogoutUrlOptions{
                IdTokenHint: idToken,
                PostLogoutRedirectUri: postLogoutRedirectURI,
            })
            if err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }

            // Redirect to Scalekit to complete the logout
            c.Redirect(http.StatusFound, logoutURL.String())
        }
        ```
      </TabItem>
      <TabItem label="Java">
        ```java title="Spring Boot"
        // A function to clear session data
        private void clearSessionData(HttpServletResponse response, String userId) {
            // Clear the access token cookie
            Cookie cookie = new Cookie("accessToken", null);
            cookie.setMaxAge(0);
            cookie.setPath("/");
            response.addCookie(cookie);

            // Remove the refresh token from your database
            db.deleteRefreshToken(userId);
        }

        @GetMapping("/logout")
        public void logout(HttpServletRequest request, HttpServletResponse response) {
            // Assuming you have the user's ID from a verified session
            String userId = (String) request.getSession().getAttribute("user_id");
            String idToken = Arrays.stream(request.getCookies())
                .filter(c -> c.getName().equals("idToken"))
                .findFirst()
                .map(Cookie::getValue)
                .orElse(null);

            clearSessionData(response, userId);

            // Proceed to invalidate the Scalekit session...
        }
        ```
      </TabItem>
    </Tabs>

3. #### Invalidate the Scalekit session
   After clearing your local session, redirect the user to the Scalekit logout endpoint. This will invalidate their session on Scalekit's servers and then redirect them back to your application.

   The Scalekit logout endpoint signature is:

   ```text showLineNumbers=false wrap
   {SCALEKIT_ENV_URL}/oidc/logout?id_token_hint={idToken}&post_logout_redirect_uri={postLogoutRedirectUri}
   ```

   - Replace `{SCALEKIT_ENV_URL}` with your Scalekit environment URL (e.g., `https://app.scalekit.com`).
   - `{idToken}` is the user's ID token.
   - `{postLogoutRedirectUri}` is the URL to redirect to after logout (must be registered in Scalekit).

    <Tabs syncKey="tech-stack">
      <TabItem label="Node.js">
        ```javascript title="Express.js"
        app.get('/logout', (req, res) => {
          const userId = req.user.id;
          const idTokenHint = req.cookies.idToken;
          const postLogoutRedirectUri = 'http://localhost:3000/login';

          // Clear local session data
          clearSessionData(res, userId);

          // Generate the Scalekit logout URL
          const logoutUrl = scalekit.getLogoutUrl({
            idTokenHint,
            postLogoutRedirectUri
          });

          // Redirect to Scalekit to complete the logout
          res.redirect(logoutUrl);
        });
        ```
      </TabItem>
      <TabItem label="Python">
        ```python title="Flask"
        from flask import session, request, redirect, make_response
        from scalekit import LogoutUrlOptions

        @app.route('/logout')
        def logout():
            user_id = session.get('user_id')
            id_token = request.cookies.get('idToken')
            post_logout_redirect_uri = 'http://localhost:3000/login'

            # Clear local session data
            response = make_response()
            clear_session_data(response, user_id)

            # Generate the Scalekit logout URL
            logout_url = scalekit.get_logout_url(
                LogoutUrlOptions(
                    id_token_hint=id_token,
                    post_logout_redirect_uri=post_logout_redirect_uri
                )
            )

            # Redirect to Scalekit to complete the logout
            return redirect(logout_url)
        ```
      </TabItem>
      <TabItem label="Go">
        ```go title="Gin"
        func logoutHandler(c *gin.Context) {
            userID := c.GetString("user_id")
            idToken, _ := c.Cookie("idToken")
            postLogoutRedirectURI := "http://localhost:3000/login"

            // Clear local session data
            if err := clearSessionData(c, userID); err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }

            // Generate the Scalekit logout URL
            logoutURL, err := scalekit.GetLogoutUrl(LogoutUrlOptions{
                IdTokenHint: idToken,
                PostLogoutRedirectUri: postLogoutRedirectURI,
            })
            if err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }

            // Redirect to Scalekit to complete the logout
            c.Redirect(http.StatusFound, logoutURL.String())
        }
        ```
      </TabItem>
      <TabItem label="Java">
        ```java title="Spring Boot"
        @GetMapping("/logout")
        public void logout(HttpServletRequest request, HttpServletResponse response) throws IOException {
            String userId = (String) request.getSession().getAttribute("user_id");
            String idToken = Arrays.stream(request.getCookies())
                .filter(c -> c.getName().equals("idToken"))
                .findFirst()
                .map(Cookie::getValue)
                .orElse(null);
            String postLogoutRedirectUri = "http://localhost:3000/login";

            // Clear local session data
            clearSessionData(response, userId);

            // Generate the Scalekit logout URL
            LogoutUrlOptions options = new LogoutUrlOptions();
            options.setIdTokenHint(idToken);
            options.setPostLogoutRedirectUri(postLogoutRedirectUri);
            // options.setState(state);  // optional

            URL logoutUrl = scalekit.authentication().getLogoutUrl(options);

            // Redirect to Scalekit to complete the logout
            response.sendRedirect(logoutUrl.toString());
        }
        ```
      </TabItem>
    </Tabs>

    The post logout redirect URI is the destination to which the user will be redirected after logging out. For example, take them to website landing page or a login page again. This must be [registered post-login URL](/fsa/reference/redirects/) in the Scalekit dashboard.


</Steps>

## IdP-initiated logout <Badge text="Coming Soon" />

For enterprise customers using SSO, an administrator might initiate logout directly from their Identity Provider's (IdP) dashboard (e.g., Okta). Scalekit supports this flow by notifying your application to terminate the user's session.

<Aside>
  Your application must expose a webhook endpoint to receive logout notifications from Scalekit.
</Aside>

When this feature is available, the flow will be as follows:
1.  An IdP administrator initiates a logout.
2.  The IdP sends a logout request to Scalekit.
3.  Scalekit calls a pre-configured webhook endpoint on your application.
4.  Your application receives the request, identifies the user, and clears their session data, effectively logging them out.

<Card title="Contact Support" icon="slack">
    This feature is currently available upon request. [Contact our support team](/support/contact-us) to have this feature enabled for your account.
</Card>

## Backchannel logout <Badge text="Coming Soon" />

Consider a scenario where a organization or a workspace uses multiple applications that all authenticate through Scalekit: a project management tool, a document sharing platform, and a team chat application. When a user logs out from one application, they expect to be logged out from all applications automatically for security reasons.

Backchannel logout enables this coordinated logout across multiple applications. Instead of relying on users to manually log out from each application, the system automatically terminates all related sessions.

<Aside>
  Your application must expose a backchannel logout endpoint to receive logout notification from Scalekit.
</Aside>

The flow will be as follows:
1.  A user logs out from one of your applications.
2.  Scalekit identifies all applications sharing the same user session.
3.  Scalekit sends a logout notification to each application's registered backchannel logout endpoint.
4.  Each application receives the notification, validates it, and terminates the user's session.

This ensures that logging out from one application automatically logs the user out from all connected applications, providing a seamless and secure experience.

<Card title="Contact Support" icon="slack">
    This feature is currently in development. [Contact our support team](/support/contact-us) to learn more about backchannel logout capabilities.
</Card>

================
File: fsa/guides/manage-organization.mdx
================
---
title: Create and manage organizations
description: Create and manage organizations in Scalekit, configure settings, and enable enterprise features.
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: "Create and manage organizations"
prev: false
next:
  label: "Manage users"
  link: "/fsa/reference/user-profile/"
---
import { Tabs, TabItem, Aside, Badge, LinkCard } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Organizations are the foundation of your B2B application, representing your customers and their teams. In Scalekit, organizations serve as multi-tenant containers that isolate user data, configure authentication methods, and manage enterprise features like Single Sign-On (SSO) and directory synchronization.

This guide shows you how to create and manage organizations programmatically and through the Scalekit dashboard.

## Understanding organizations

Users can belong to multiple organizations with the same identity. This is common in products like Notion, where users collaborate across multiple workspaces.

<Aside type="note">
  You can [customize](/fsa/reference/user-management-settings/#organization-meta-name) the terminology to match your product. Organizations can be relabeled as "Workspaces," "Teams," or any term that makes sense for your users.
</Aside>

## Create an organization

Organizations can be created automatically during user sign-up or programmatically through the API. When users sign up for your application, Scalekit creates a new organization and adds the user to it automatically.


For more control over the organization creation process, create organizations programmatically:

<InstallSDK />

<Tabs syncKey="tech-stack">
<TabItem label="Node.js" value="nodejs">
```javascript title="Create organization"
const organization = await scalekit.organization.createOrganization('Acme Corporation', {
  externalId: 'acme-corp-123',
  metadata: {
    plan: 'enterprise',
    industry: 'technology'
  }
});

console.log('Organization created:', organization.id);
```
</TabItem>
<TabItem label="Python" value="python">
```python title="Create organization"
from scalekit.v1.organizations.organizations_pb2 import CreateOrganization

organization = scalekit_client.organization.create_organization(
    CreateOrganization(
        display_name='Acme Corporation',
        external_id='acme-corp-123',
        metadata={
            'plan': 'enterprise',
            'industry': 'technology'
        }
    )
)

print(f'Organization created: {organization.id}')
```
</TabItem>
<TabItem label="Go" value="go">
```go title="Create organization"
organization, err := scalekitClient.Organization.CreateOrganization(
    ctx,
    "Acme Corporation",
    scalekit.CreateOrganizationOptions{
        ExternalId: "acme-corp-123",
        Metadata: map[string]interface{}{
            "plan": "enterprise",
            "industry": "technology",
        },
    },
)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Organization created: %s\n", organization.ID)
```
</TabItem>
<TabItem label="Java" value="java">
```java title="Create organization"
import java.util.Map;
import java.util.HashMap;

Map<String, Object> metadata = new HashMap<>();
metadata.put("plan", "enterprise");
metadata.put("industry", "technology");

CreateOrganization createOrg = CreateOrganization.newBuilder()
    .setDisplayName("Acme Corporation")
    .setExternalId("acme-corp-123")
    .putAllMetadata(metadata)
    .build();

Organization organization = scalekitClient.getOrganization().create(createOrg);
System.out.println("Organization created: " + organization.getId());
```
</TabItem>
</Tabs>

**External ID**: An optional field to associate the organization with an ID from your system. This is useful for linking Scalekit organizations with records in your own database.

## Update organization details

Organization administrators often need to make changes after the initial setup. Typical examples include:

* Renaming the organization after a corporate re-brand.
* Uploading or replacing the company logo shown on your dashboard or invoices.
* Storing metadata your application needs at runtime—such as a billing plan identifier, Stripe customer ID, or internal account reference.

<Tabs syncKey="tech-stack">
<TabItem label="Node.js" value="nodejs">
```javascript title="Update organization"
const updatedOrganization = await scalekit.organization.updateOrganization(
  'org_12345',
  {
    displayName: 'Acme Corporation Ltd',
    metadata: {
      plan: 'enterprise',
      paymentMethod: 'stripe',
      customField: 'custom-value'
    }
  }
);
```
</TabItem>
<TabItem label="Python" value="python">
```python title="Update organization"

updated_organization = scalekit_client.organization.update_organization(
    organization_id='org_12345',
    organization= UpdateOrganization(
            display_name='Acme Corporation Ltd',
            metadata={
                'plan': 'enterprise',
                'payment_method': 'stripe',
                'custom_field': 'custom-value'
            }
        )
)
```
</TabItem>
<TabItem label="Go" value="go">
```go title="Update organization"
metadata := map[string]interface{}{
    "plan": "enterprise",
    "payment_method": "stripe",
    "custom_field": "custom-value",
}

updatedOrganization, err := scalekitClient.Organization.UpdateOrganization(
    ctx,
    "org_12345",
    scalekit.UpdateOrganizationOptions{
        DisplayName: "Acme Corporation Ltd",
        Metadata: metadata,
    },
)
```
</TabItem>
<TabItem label="Java" value="java">
```java title="Update organization"
Map<String, Object> metadata = new HashMap<>();
metadata.put("plan", "enterprise");
metadata.put("payment_method", "stripe");
metadata.put("custom_field", "custom-value");

Organization updatedOrganization = scalekitClient.getOrganization()
    .updateOrganization("org_12345", UpdateOrganizationRequest.builder()
        .displayName("Acme Corporation Ltd")
        .metadata(metadata)
        .build());
```
</TabItem>
</Tabs>

**Metadata**: Store additional information about the organization, such as subscription plans, payment methods, or any custom data relevant to your application.

## Configure organization features

Enable enterprise features for your organizations to support authentication methods like SSO and user provisioning through SCIM.

<Tabs syncKey="tech-stack">
<TabItem label="Node.js" value="nodejs">
```javascript title="Enable organization features"
const settings = {
  features: [
    {
      name: 'sso',
      enabled: true,
    },
    {
      name: 'dir_sync',
      enabled: true,
    },
  ],
};

await scalekit.organization.updateOrganizationSettings(
  'org_12345',
  settings
);
```
</TabItem>
<TabItem label="Python" value="python">
```python title="Enable organization features"
settings = {
    "features": [
        {"name": "sso", "enabled": True},
        {"name": "dir_sync", "enabled": True}
    ]
}

scalekit_client.organization.update_organization_settings(
    'org_12345',
    settings
)
```
</TabItem>
<TabItem label="Go" value="go">
```go title="Enable organization features"
settings := map[string]interface{}{
    "features": []map[string]interface{}{
        {"name": "sso", "enabled": true},
        {"name": "dir_sync", "enabled": true},
    },
}

err := scalekitClient.Organization.UpdateOrganizationSettings(
    ctx,
    "org_12345",
    settings
)
```
</TabItem>
<TabItem label="Java" value="java">
```java title="Enable organization features"
Map<String, Object> settings = new HashMap<>();
settings.put("features", Arrays.asList(
    new HashMap<String, Object>() {{
        put("name", "sso");
        put("enabled", true);
    }},
    new HashMap<String, Object>() {{
        put("name", "dir_sync");
        put("enabled", true);
    }}
));

scalekitClient.getOrganization().updateOrganizationSettings(
    "org_12345",
    settings
);
```
</TabItem>
</Tabs>


### Admin Portal access (self-serve configuration)

Enterprise customers usually want to manage SSO and directory sync on their own, without involving your support team. Scalekit provides an **Admin Portal** that you can surface to IT administrators in two ways:

1. **Generate a shareable link** and send it via email or chat.
2. **Embed the portal** inside your own settings page with an `<iframe>`.

Both approaches give administrators a sandboxed interface to configure SSO (SAML/OIDC) connections, SCIM provisioning, and other security settings.

<Tabs syncKey="tech-stack">
<TabItem label="Node.js" value="nodejs">
```javascript title="Generate Admin Portal link"
const portalLink = await scalekit.organization.generatePortalLink('org_12345');

// Present this URL to the organization's IT admin or load it in an iframe
console.log('Admin Portal URL:', portalLink.url);
```
</TabItem>
<TabItem label="Python" value="python">
```python title="Generate Admin Portal link"
portal_link = scalekit_client.organization.generate_portal_link('org_12345')
print(f'Admin Portal URL: {portal_link.url}')
```
</TabItem>
<TabItem label="Go" value="go">
```go title="Generate Admin Portal link"
portalLink, err := scalekitClient.Organization.GeneratePortalLink(ctx, "org_12345")
if err != nil {
    log.Fatal(err)
}
fmt.Println("Admin Portal URL:", portalLink.URL)
```
</TabItem>
<TabItem label="Java" value="java">
```java title="Generate Admin Portal link"
PortalLink portalLink = scalekitClient.getOrganization().generatePortalLink("org_12345");
System.out.println("Admin Portal URL: " + portalLink.getUrl());
```
</TabItem>
</Tabs>

For advanced customization options, see the [Admin Portal guide](/guides/sso/admin-portal/).

### Configure SSO and SCIM from the dashboard

As an alternative to the Admin Portal, you can configure SSO and SCIM directly from the Scalekit dashboard. This approach is useful when you want to set up these features for your customers without sharing admin portal access.

#### Set up SSO configuration

Configure Single Sign-On to connect your customer's identity provider with Scalekit. From the organization's settings page in the dashboard, you can set up SSO connections.

To configure SSO:

1. **Configure user attributes** by mapping attributes from the identity provider to user profiles in Scalekit.
2. **Enter identity provider configuration** with metadata from your customer's IdP, including Entity ID, ACS URL, and X.509 certificate.
3. **Assign users and groups** to specify which users and groups can use this SSO connection.
4. **Test SSO** by performing a test login to ensure the connection works correctly.
5. **Enable connection** once you've verified the configuration is working.

For step-by-step guides on configuring specific identity providers, see [SSO integrations](/guides/integrations/sso-integrations/).

#### Set up SCIM configuration

Configure SCIM provisioning to allow your customers to provision and manage users and groups automatically from their directory provider.

To set up SCIM:

1. **Generate SCIM endpoint** and provide this URL to your customer for configuration in their directory provider.
2. **Create bearer token** and share this rotatable token with your customer for secure authentication.
3. **Monitor synced users and groups** to verify which users and groups are being synced after the connection is active.

For detailed configuration guides with specific providers, see [SCIM integrations](/guides/integrations/scim-integrations/) to automate user and group management.

<LinkCard
  title="Group-based role assignment"
  href="/directory/guides/group-based-role-assignment"
  description="Learn how to assign roles to users based on their group memberships from the directory provider."
/>

## Organization specific policies

Configure advanced authentication and access control policies to meet your organization's security requirements.

### Authentication methods <Badge type="note" text="Coming soon" />

Organization admins will be able to configure which authentication methods are available to their organization members. For example, they can restrict access to only enterprise SSO for enhanced security, or allow a combination of SSO and passwordless authentication for flexible user access.

### Session settings <Badge type="note" text="Coming soon" />

Organization admins will be able to configure session settings for all their organization members. They can set session timeout, idle timeout, and other session-related settings that align with their organization's security policies and compliance requirements.

## What's next?

- [Manage users](/fsa/reference/user-profile/) to create, update, and delete user accounts within organizations
- [Enable Enterprise SSO](/fsa/guides/enterprise-sso/) to configure single sign-on for your customers
- [Set up SCIM provisioning](/directory/scim/quickstart/) to automate user and group management

================
File: fsa/guides/manage-session.mdx
================
---
title: 'Manage user sessions'
description: 'Learn how to manage user sessions, including storing tokens and refreshing them when they expire.'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: 'Handle user sessions'
prev:
  label: 'Implement sign-in'
  link: '/fsa/guides/implement-login/'
next:
  label: 'Logout'
  link: '/fsa/guides/logout/'
---

import {
  Steps,
  Tabs,
  TabItem,
  Aside,
  Card,
} from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

User sessions determine how long users stay signed in to your application. After users successfully authenticate, you receive session tokens that manage their access. These tokens control session duration, multi-device access, and cross-product authentication within your company's ecosystem.

Scalekit provides session management capabilities out of the box. Your application receives an `access_token` and `refresh_token` in the authentication response. This guide shows you how to store these tokens securely and refresh them before they expire.

![User session management flow diagram showing how access tokens and refresh tokens work together](../../../../assets/docs/fsa/user-management/1-handle-user-sessions.png)


<Aside type='note'>
  Include `offline_access` in the list of scopes sent during the authorization
  request to Scalekit to receive a `refresh_token`. This token allows you to get
  new access tokens without requiring users to sign in again.
</Aside>

<Steps>
1. ### Store session tokens securely

   After [successful user authentication](/fsa/guides/implement-login/), your application receives session tokens in the response object.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="Express.js"
     const authResult = await scalekit.authenticateWithCode(
       code, redirectUri
     );
     // authResult contains user profile and session tokens
     const { user, accessToken, refreshToken, expiresIn } = authResult;
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="Flask"
     auth_result = scalekit_client.authenticate_with_code(
       code=code,
       redirect_uri=redirect_uri
     )
     # auth_result contains user profile and session tokens
     user = auth_result.user
     access_token = auth_result.access_token
     refresh_token = auth_result.refresh_token
     expires_in = auth_result.expires_in
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="Gin"
     authResult, err := scalekitClient.AuthenticateWithCode(
       code,
       redirectUri,
     )
     if err != nil {
       // Handle error
     }
     // authResult contains user profile and session tokens
     user := authResult.User
     accessToken := authResult.AccessToken
     refreshToken := authResult.RefreshToken
     expiresIn := authResult.ExpiresIn
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Spring"
     AuthResult authResult = scalekitClient.authentication().authenticateWithCode(
       code,
       redirectUri
     );
     // authResult contains user profile and session tokens
     User user = authResult.getUser();
     String accessToken = authResult.getAccessToken();
     String refreshToken = authResult.getRefreshToken();
     int expiresIn = authResult.getExpiresIn();
     ```
     </TabItem>
   </Tabs>

   Store each token based on its security requirements:
   - **Access Token**: Store in a secure, HTTP-only cookie to prevent XSS attacks. This token has a short lifespan and provides access to protected resources.
   <details>
   <summary>View decoded access token</summary>
   ```json title="Access Token (decoded JWT) example" showLineNumbers=false
    {
      "aud": [
        "skc_987654321098765432"
      ],
      "client_id": "skc_987654321098765432",
      "exp": 1750850145,
      "iat": 1750849845,
      "iss": "http://example.localhost:8889",
      "jti": "tkn_987654321098765432",
      "nbf": 1750849845,
      "roles": [
        "member"
      ],
      "sid": "ses_987654321098765432",
      "sub": "usr_987654321098765432",
      "xuid": "john.doe"
    }
    ```
   </details>
   - **Refresh Token**: Store in your backend database or secure server-side storage. This long-lived token generates new access tokens.

   Here's how to set secure cookies:

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="Express.js" wrap ins={12-17}
     import cookieParser from 'cookie-parser';
     // Configure cookie parser middleware
     app.use(cookieParser());
     // After receiving the authResult from scalekit.authenticateWithCode()
     const { accessToken, expiresIn, refreshToken, user } = authResult;
     // Store the refresh token in your database
     await db.saveRefreshToken(user.id, refreshToken);
     // Set the access token as a secure cookie
     res.cookie('accessToken', accessToken, {
       maxAge: (expiresIn - 60) * 1000, // Convert to milliseconds, subtract 60s buffer
       httpOnly: true,
       secure: process.env.NODE_ENV === 'production',
       sameSite: 'strict'
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="Flask" wrap ins={16-24}
     from flask import Flask, make_response
     import os
     app = Flask(__name__)
     # After receiving the auth_result from scalekit.authenticate_with_code()
     access_token = auth_result.access_token
     expires_in = auth_result.expires_in
     refresh_token = auth_result.refresh_token
     user = auth_result.user
     # Store the refresh token in your database
     db.save_refresh_token(user.id, refresh_token)
     # Set the access token as a secure cookie
     response = make_response()
     response.set_cookie(
       'accessToken',
       access_token,
       max_age=(expires_in - 60) * 1000,  # Convert to milliseconds, subtract 60s buffer
       httponly=True,
       secure=os.environ.get('FLASK_ENV') == 'production',
       samesite='Strict'
     )
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="Gin" wrap ins={18-25}
     import (
       "net/http"
       "os"
       "time"
       "github.com/gin-gonic/gin"
     )
     // After receiving the authResult from scalekit.AuthenticateWithCode()
     accessToken := authResult.AccessToken
     expiresIn := authResult.ExpiresIn
     refreshToken := authResult.RefreshToken
     user := authResult.User
     // Store the refresh token in your database
     db.SaveRefreshToken(user.ID, refreshToken)
     // Set the access token as a secure cookie
     c.SetCookie(
       "accessToken",
       accessToken,
       (expiresIn-60)*1000, // Convert to milliseconds, subtract 60s buffer
       "/",
       "",
       os.Getenv("GIN_MODE") == "release",
       true, // httpOnly
     )
     c.SetSameSite(http.SameSiteStrictMode)
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Spring" wrap ins={18-24}
     import javax.servlet.http.Cookie;
     import javax.servlet.http.HttpServletResponse;
     import org.springframework.core.env.Environment;
     @Autowired
     private Environment env;
     // After receiving the authResult from scalekit.authenticateWithCode()
     String accessToken = authResult.getAccessToken();
     int expiresIn = authResult.getExpiresIn();
     String refreshToken = authResult.getRefreshToken();
     User user = authResult.getUser();
     // Store the refresh token in your database
     db.saveRefreshToken(user.getId(), refreshToken);
     // Set the access token as a secure cookie
     Cookie cookie = new Cookie("accessToken", accessToken);
     cookie.setMaxAge((expiresIn - 60) * 1000); // Convert to milliseconds, subtract 60s buffer
     cookie.setHttpOnly(true);
     cookie.setSecure("production".equals(env.getActiveProfiles()[0]));
     cookie.setPath("/");
     response.addCookie(cookie);
     ```
     </TabItem>
   </Tabs>

   Configure session settings from your [Scalekit dashboard's Session Configuration](/fsa/reference/user-management-settings) to control session lifetimes and security policies.

2. ### Verify the access token

   Create middleware to protect your application routes. This middleware validates the access token on every request to secured endpoints.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" wrap showLineNumbers=true
     async function verifyToken(req, res, next) {
       const { accessToken } = req.cookies;
       if (!accessToken) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       try {
         // Validate the token using Scalekit SDK (returns boolean)
         const isValid = await scalekit.validateAccessToken(accessToken);
         if (!isValid) {
           // Token is expired or invalid - attempt to refresh
           return handleTokenRefresh(req, res, next);
         }
         next();
       } catch (error) {
         // Validation failed - attempt to refresh
         return handleTokenRefresh(req, res, next);
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" wrap showLineNumbers=true
     from flask import request, jsonify
     from functools import wraps
     def verify_token(f):
         @wraps(f)
         def decorated_function(*args, **kwargs):
             access_token = request.cookies.get('accessToken')
             if not access_token:
                 return jsonify({'error': 'Authentication required'}), 401
             try:
                 // Validate the token using Scalekit SDK (returns boolean)
                 is_valid = scalekit.validate_access_token(access_token)
                 if not is_valid:
                     // Token is expired or invalid - attempt to refresh
                     return handle_token_refresh(f, *args, **kwargs)
                 // Token valid – proceed to view
                 return f(*args, **kwargs)
             except Exception:
                 // Validation threw error – attempt to refresh
                 return handle_token_refresh(f, *args, **kwargs)
         return decorated_function
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" wrap showLineNumbers=true
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func VerifyToken() gin.HandlerFunc {
       return func(c *gin.Context) {
         accessToken, err := c.Cookie("accessToken")
         if err != nil || accessToken == "" {
           c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
           c.Abort()
           return
         }
         // Validate the token using Scalekit SDK (returns bool)
         isValid, err := scalekit.ValidateAccessToken(accessToken)
         if err != nil || !isValid {
           // Token is expired or invalid - attempt to refresh
           handleTokenRefresh(c)
           return
         }
         // Token valid – proceed
         c.Next()
       }
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" wrap showLineNumbers=true
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     import org.springframework.web.servlet.HandlerInterceptor;
     @Component
     public class AuthInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(
         HttpServletRequest request,
         HttpServletResponse response,
         Object handler
       ) throws Exception {
         String accessToken = getCookieValue(request, "accessToken");
         if (accessToken == null) {
           response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
           response.getWriter().write("{\"error\": \"Authentication required\"}");
           return false;
         }
         try {
           // Validate the token using Scalekit SDK (returns boolean)
           boolean isValid = scalekit.validateAccessToken(accessToken);
           if (!isValid) {
             // Token is expired or invalid - attempt to refresh
             return handleTokenRefresh(request, response);
           }
           return true;
         } catch (Exception e) {
           // Validation threw error – attempt to refresh
           return handleTokenRefresh(request, response);
         }
       }
       private String getCookieValue(HttpServletRequest request, String cookieName) {
         Cookie[] cookies = request.getCookies();
         if (cookies != null) {
           for (Cookie cookie : cookies) {
             if (cookieName.equals(cookie.getName())) {
               return cookie.getValue();
             }
           }
         }
         return null;
       }
     }
     ```
     </TabItem>
   </Tabs>

3. ### Refresh expired access tokens

   When access tokens expire, use the refresh token to get new ones. This maintains user sessions without requiring re-authentication.

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="middleware/auth.js" wrap showLineNumbers=true ins={2,10,14-20,23}
     async function handleTokenRefresh(req, res, next) {
       // Get the user ID from the expired token or session storage
       const userId = req.session?.userId || req.user?.id;
       if (!userId) {
         return res.status(401).json({ error: 'Authentication required' });
       }
       // Retrieve the stored refresh token from your database
       const storedRefreshToken = await db.getRefreshToken(userId);
       if (!storedRefreshToken) {
         return res.status(401).json({ error: 'Session expired' });
       }
       try {
         // Get new tokens using the refresh token
         const authResult = await scalekit.refreshAccessToken(storedRefreshToken);
         const { accessToken, expiresIn, refreshToken: newRefreshToken } = authResult;
         // Update the stored refresh token
         await db.saveRefreshToken(userId, newRefreshToken);
         // Set the new access token as a cookie
         res.cookie('accessToken', accessToken, {
           maxAge: (expiresIn - 60) * 1000,
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'strict'
         });
         // Attach user information and continue
         req.user = authResult.user;
         next();
       } catch (error) {
         // Refresh failed - user must sign in again
         res.clearCookie('accessToken');
         return res.status(401).json({ error: 'Session expired. Please sign in again.' });
       }
     }
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="middleware/auth.py" wrap showLineNumbers=true ins={2,10,14-20,23}
     from flask import request, jsonify, make_response
     def handle_token_refresh(f, *args, **kwargs):
         # Get the user ID from the expired token or session storage
         user_id = request.session.get('userId') if hasattr(request, 'session') else getattr(request, 'user', {}).get('id')
         if not user_id:
             return jsonify({'error': 'Authentication required'}), 401
         # Retrieve the stored refresh token from your database
         stored_refresh_token = db.get_refresh_token(user_id)
         if not stored_refresh_token:
             return jsonify({'error': 'Session expired'}), 401
         try:
             # Get new tokens using the refresh token
             auth_result = scalekit.refresh_access_token(stored_refresh_token)
             access_token = auth_result.access_token
             expires_in = auth_result.expires_in
             new_refresh_token = auth_result.refresh_token
             # Update the stored refresh token
             db.save_refresh_token(user_id, new_refresh_token)
             # Set the new access token as a cookie
             response = make_response(f(*args, **kwargs))
             response.set_cookie(
                 'accessToken',
                 access_token,
                 max_age=(expires_in - 60) * 1000,
                 httponly=True,
                 secure=os.environ.get('FLASK_ENV') == 'production',
                 samesite='Strict'
             )
             # Attach user information and continue
             request.user = auth_result.user
             return response
         except Exception:
             # Refresh failed - user must sign in again
             response = make_response(jsonify({'error': 'Session expired. Please sign in again.'}), 401)
             response.set_cookie('accessToken', '', expires=0)
             return response
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="middleware/auth.go" wrap showLineNumbers=true ins={2,10,14-20,23}
     import (
       "net/http"
       "github.com/gin-gonic/gin"
     )
     func handleTokenRefresh(c *gin.Context) {
       // Get the user ID from the expired token or session storage
       userID := getUserIDFromContext(c) // Helper function to get user ID
       if userID == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
         c.Abort()
         return
       }
       // Retrieve the stored refresh token from your database
       storedRefreshToken, err := db.GetRefreshToken(userID)
       if err != nil || storedRefreshToken == "" {
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired"})
         c.Abort()
         return
       }
       // Get new tokens using the refresh token
       authResult, err := scalekit.RefreshAccessToken(storedRefreshToken)
       if err != nil {
         // Refresh failed - user must sign in again
         c.SetCookie("accessToken", "", -1, "/", "", false, true)
         c.JSON(http.StatusUnauthorized, gin.H{"error": "Session expired. Please sign in again."})
         c.Abort()
         return
       }
       // Update the stored refresh token
       db.SaveRefreshToken(userID, authResult.RefreshToken)
       // Set the new access token as a cookie
       c.SetCookie(
         "accessToken",
         authResult.AccessToken,
         (authResult.ExpiresIn-60)*1000,
         "/",
         "",
         os.Getenv("GIN_MODE") == "release",
         true,
       )
       // Attach user information and continue
       c.Set("user", authResult.User)
       c.Next()
     }
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="middleware/AuthInterceptor.java" wrap showLineNumbers=true ins={2,10,14-20,23}
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import javax.servlet.http.Cookie;
     private boolean handleTokenRefresh(HttpServletRequest request, HttpServletResponse response)
         throws Exception {
       // Get the user ID from the expired token or session storage
       String userId = getUserIdFromRequest(request); // Helper method to get user ID
       if (userId == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Authentication required\"}");
         return false;
       }
       // Retrieve the stored refresh token from your database
       String storedRefreshToken = db.getRefreshToken(userId);
       if (storedRefreshToken == null) {
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired\"}");
         return false;
       }
       try {
         // Get new tokens using the refresh token
         AuthResult authResult = scalekit.refreshToken(storedRefreshToken);
         String accessToken = authResult.getAccessToken();
         int expiresIn = authResult.getExpiresIn();
         String newRefreshToken = authResult.getRefreshToken();
         // Update the stored refresh token
         db.saveRefreshToken(userId, newRefreshToken);
         // Set the new access token as a cookie
         Cookie cookie = new Cookie("accessToken", accessToken);
         cookie.setMaxAge((expiresIn - 60) * 1000);
         cookie.setHttpOnly(true);
         cookie.setSecure("production".equals(env.getActiveProfiles()[0]));
         cookie.setPath("/");
         response.addCookie(cookie);
         // Attach user information and continue
         request.setAttribute("user", authResult.getUser());
         return true;
       } catch (Exception e) {
         // Refresh failed - user must sign in again
         Cookie expiredCookie = new Cookie("accessToken", "");
         expiredCookie.setMaxAge(0);
         response.addCookie(expiredCookie);
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.getWriter().write("{\"error\": \"Session expired. Please sign in again.\"}");
         return false;
       }
     }
     ```
     </TabItem>
   </Tabs>

   Apply this middleware to protected routes:

   <Tabs syncKey="tech-stack">
     <TabItem value="node" label="Node.js">
     ```javascript title="app.js"
     // Protect routes that require authentication
     app.get('/dashboard', verifyToken, (req, res) => {
       res.json({ message: `Welcome ${req.user.name}!` });
     });
     app.get('/api/profile', verifyToken, (req, res) => {
       res.json({ user: req.user });
     });
     ```
     </TabItem>
     <TabItem value="py" label="Python">
     ```python title="app.py"
     # Protect routes that require authentication
     @app.route('/dashboard')
     @verify_token
     def dashboard():
         return jsonify({'message': f'Welcome {request.user.name}!'})
     @app.route('/api/profile')
     @verify_token
     def profile():
         return jsonify({'user': request.user})
     ```
     </TabItem>
     <TabItem value="go" label="Go">
     ```go title="main.go"
     // Protect routes that require authentication
     r.GET("/dashboard", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{
         "message": fmt.Sprintf("Welcome %s!", user.Name),
       })
     })
     r.GET("/api/profile", VerifyToken(), func(c *gin.Context) {
       user, _ := c.Get("user")
       c.JSON(http.StatusOK, gin.H{"user": user})
     })
     ```
     </TabItem>
     <TabItem value="java" label="Java">
     ```java title="Controller.java"
     // Protect routes that require authentication
     @GetMapping("/dashboard")
     public ResponseEntity<Map<String, String>> dashboard(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, String> response = new HashMap<>();
       response.put("message", "Welcome " + user.getName() + "!");
       return ResponseEntity.ok(response);
     }
     @GetMapping("/api/profile")
     public ResponseEntity<Map<String, Object>> profile(HttpServletRequest request) {
       User user = (User) request.getAttribute("user");
       Map<String, Object> response = new HashMap<>();
       response.put("user", user);
       return ResponseEntity.ok(response);
     }
     ```
     </TabItem>
   </Tabs>
</Steps>

## Configure session settings

Control user session behavior from your Scalekit dashboard without changing your application code.

![Session Settings Dashboard](@/assets/docs/fsa/session-settings/1.png)

You can control how long users stay signed in and how often they need to log in again. In your Scalekit dashboard, the **Session settings** page lets you set these options:

- **Absolute session timeout**: This is the maximum time a user can stay signed in, no matter what. After this time, they must log in again. For example, if you set it to 30 minutes, users will be logged out after 30 minutes, even if they are still using your app.

- **Idle session timeout**: This is the time your app waits before logging out a user who is not active. If you turn this on, the session will end if the user does nothing for the set time. For example, if you set it to 10 minutes, and the user does not click or type for 10 minutes, they will be logged out.

- **Access token lifetime**: This is how long an access token is valid. When it expires, your app needs to get a new token (using the refresh token) so the user can keep using the app without logging in again. For example, if you set it to 5 minutes, your app will need to refresh the token every 5 minutes.

Shorter timeouts provide better security, while longer timeouts reduce authentication interruptions.

<Aside type="tip" title="Organization-level session settings">
Enable organization administrators to control session settings for their workspace.

[Contact our support team](/support/contact-us/) to activate this feature for your account.

</Aside>

## What's next?

- Learn how to [implement secure user logout](/fsa/guides/logout/) to properly end user sessions.
- Explore [session configuration options](/fsa/reference/user-management-settings) to customize security policies.
- Set up [organization-level authentication policies](/fsa/guides/manage-organization/#organization-specific-policies) for enterprise customers.

================
File: fsa/guides/manage-users.mdx
================
---
title: Manage users
draft: true
description: "Learn how to create, update, and manage users in your B2B application using the Scalekit API, with support for multi-tenant access and role assignments."
sidebar:
  label: 'Manage user accounts'
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: 'Manage organizations'
  link: '/fsa/guides/manage-organization/'
next: false
---

import { Tabs, TabItem, Aside, Badge, Steps } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Managing user accounts in B2B applications involves unique challenges around multi-tenant access, role assignments, and organizational boundaries. Users may belong to multiple organizations, have different roles in each, and require different levels of access to your application's features.

This guide shows you how to manage users programmatically across different scenarios that B2B applications commonly encounter.

## Understanding user management in B2B

User management in B2B applications differs significantly from consumer apps. Consider these common scenarios:

**For Organization Administrators:**

- Invite users to join their organization and assign appropriate roles
- Suspend or deactivate users who leave the company or change roles
- Update user information and role assignments as teams evolve
- View all active and inactive users within their organization
- Enforce authentication policies like SSO for security compliance

**For End Users:**

- Join multiple organizations with the same email address
- Switch between organizations they belong to
- Update their own profile information across organizations
- Accept invitations to join new organizations
- Leave organizations they no longer need access to

Scalekit handles these scenarios by creating separate user records for each organization membership while maintaining identity consistency through email addresses.

## Prerequisites

<Steps>
1. ### Set up your environment

    <CheckItem iconName="forward-slash">
     [Create a Scalekit account](https://app.scalekit.com/ws/signup) and complete the quickstart
    </CheckItem>
    <CheckItem iconName="forward-slash">
     Have at least one organization created in your environment
    </CheckItem>

2.  ### Install the Scalekit SDK

        <InstallSDK />

        Configure your API credentials:
        ```bash
        SCALEKIT_ENVIRONMENT_URL='<YOUR_ENVIRONMENT_URL>'
        SCALEKIT_CLIENT_ID='<ENVIRONMENT_CLIENT_ID>'
        SCALEKIT_CLIENT_SECRET='<ENVIRONMENT_CLIENT_SECRET>'
        ```

        Initialize the Scalekit client:
        ```javascript
        import { Scalekit } from '@scalekit-sdk/node';

        const scalekit = new Scalekit(
          process.env.SCALEKIT_ENVIRONMENT_URL,
          process.env.SCALEKIT_CLIENT_ID,
          process.env.SCALEKIT_CLIENT_SECRET
        );
        ```

</Steps>

## Create and provision users

Users can be added to organizations through multiple methods depending on your application's workflow and security requirements.

### Create a user directly

When you need to create user accounts programmatically—such as during data migrations, bulk imports, or admin-initiated account creation—you can create users directly with their organization membership.

**Scenario**: An HR system integration that automatically creates accounts for new employees in your customer's organization.

```javascript title="Create a user with organization membership"
const newUser = await scalekit.user.createUserAndMembership('org_123', {
  email: 'john.doe@example.com',
  userProfile: {
    firstName: 'John',
    lastName: 'Doe',
  },
  metadata: {
    department: 'Engineering',
    role: 'Developer',
    employeeId: 'EMP-001',
    startDate: '2024-03-20',
  },
  sendInvitationEmail: false, // Set to true to send welcome email
});

console.log('User created:', newUser.user.id);
console.log('Membership created:', newUser.membership.id);
```

**Key parameters:**

- `sendInvitationEmail`: Controls whether Scalekit sends a welcome email to the new user
- `metadata`: Store custom information relevant to your application
- `userProfile`: Basic profile information like name and other attributes

### User sign-ups

The most common way users join organizations is through self-service sign-up flows. This happens when users discover your application and want to create their own accounts.

**Scenario**: A user visits your pricing page, signs up for a trial, and becomes the first member (and owner) of a new organization.

Scalekit automatically handles this during the authentication flow. When users complete sign-up through your application, Scalekit creates both the user and their organization automatically. See the [implement sign-up guide](/fsa/guides/implement-signup/) for detailed integration steps.

### SCIM-based provisioning <Badge type="note" text="Coming soon" />

Enterprise customers can automatically provision and deprovision users through SCIM (System for Cross-domain Identity Management), keeping your application in sync with their source of truth.

**Scenario**: When an employee joins or leaves your customer's company, their access to your application is automatically granted or revoked through their identity provider.

## Manage organization memberships

Users often need different levels of access within organizations, and their roles may change over time as responsibilities evolve.

### Create membership for existing users

**Scenario**: A consultant who already has an user account in your system needs access to a new client's organization.

```javascript title="Add user to organization" wrap
const membership = await scalekit.user.createMembership('org_123', 'user_456', {
  roles: ['member'],
  metadata: {
    joinDate: new Date().toISOString(),
    team: 'Platform',
  },
  sendInvitationEmail: true,
});

console.log('Membership created:', membership.user?.id);
```

### Update membership

**Scenario**: A user's relationship with an organization changes - they move to a different team/organization/workspace, their contract terms are updated, or their access requirements change.

```javascript title="Update user membership"
const updatedMembership = await scalekit.user.updateMembership('org_123', 'user_456', {
  roles: ['member'],
  metadata: {
    team: 'Backend',
    level: 'Senior',
    contractType: 'Full-time',
    accessExpiry: '2024-12-31',
    manager: 'jane.smith@example.com',
  },
});

console.log('Membership updated with new details');
```

### Remove user from organization

**Scenario**:

- An employee leaves the company or a contractor's engagement ends, requiring removal of their access.
- Organization admin chooses to delete the organization from your application's settings.

```javascript title="Remove user membership"
await scalekit.user.deleteMembership('org_123', 'user_456');
console.log('User removed from organization');
```

<Aside type='note'>
  Removing a membership doesn't delete the user's account entirely—they may still belong to other organizations. Use
  `deleteUser` only when you need to remove the user completely.
</Aside>

## List and query users

Organizations need visibility into their user base for auditing, billing, and management purposes.

### List organization users

**Scenario**: An organization admin wants to see all users in their organization for a security audit or to review access permissions.

```javascript title="List users in organization"
const users = await scalekit.user.listOrganizationUsers('org_123', {
  pageSize: 20,
  pageToken: 'next_page_token', // For pagination
});

console.log(`Found ${users.users.length} users`);
users.users.forEach(user => {
  console.log(`${user.email} - ${user.userProfile.firstName} ${user.userProfile.lastName}`);
});

// Handle pagination
if (users.nextPageToken) {
  // Fetch next page of results
}
```

### List users with filtering

**Scenario**: Find all users in a specific department or with certain roles for targeted communications or policy updates.

```javascript title="List users with pagination"
const users = await scalekit.user.listUsers('org_123', {
  pageSize: 10,
  pageToken: 'next_page_token',
});

// Filter by metadata in your application logic
const engineeringUsers = users.users.filter(user => user.metadata.department === 'Engineering');
```

## User deactivation and deletion

Managing user lifecycle includes handling departures, suspensions, and account cleanup.

### Deactivate users

<Badge type='note' text='Coming soon' />

**Scenario**: Temporarily suspend a user's access while investigating a security incident, or when an employee takes extended leave.

Deactivation will preserve user data while preventing access to the organization. This is useful for temporary suspensions where you may need to reactivate the user later.

### Delete users permanently

**Scenario**: Completely remove a user when they've left the company permanently and you need to comply with data retention policies.

```javascript title="Delete user permanently"
await scalekit.user.deleteUser('org_123', 'user_456');
console.log('User deleted permanently');
```

<Aside type='caution'>
  Permanent deletion removes all user data and cannot be undone. Consider deactivation for reversible user management.
</Aside>

## Metadata and external IDs

Store additional information about users to integrate with your existing systems and business logic.

### Using metadata for custom data

**Scenario**: Track user-specific information like department, employee ID, hire date, or application-specific settings.

```javascript title="Create user with metadata"
const userWithMetadata = await scalekit.user.createUserAndMembership('org_123', {
  email: 'sarah.wilson@example.com',
  userProfile: {
    firstName: 'Sarah',
    lastName: 'Wilson',
  },
  metadata: {
    department: 'Sales',
    employeeId: 'EMP-002',
    territory: 'West Coast',
    quota: 150000,
    manager: 'john.doe@example.com',
  },
});
```

### External IDs for system integration

**Scenario**: Link Scalekit users with records in your CRM, HR system, or other business applications.

```javascript title="Update user with external ID"
const updatedUser = await scalekit.user.updateUser('org_123', 'user_456', {
  externalId: 'SALESFORCE-003921', // Link to Salesforce contact
  metadata: {
    crmAccountId: 'ACC-789',
    hubspotContactId: '12345',
  },
});
```

This integration approach maintains consistent user identity across your system architecture while keeping Scalekit as the source of truth for authentication and authorization.

## What's next?

Now that you understand user management, explore related guides:

- [Configure user roles](/fsa/guides/app-roles/) to define and assign permissions within organizations
- [Set up SCIM provisioning](/directory/scim/quickstart/) to automate user lifecycle management
- [Enable Enterprise SSO](/fsa/guides/enterprise-sso/) to streamline authentication for your customers

================
File: fsa/guides/merge-identities.mdx
================
---
title: Merge user identities
description: "Learn how Scalekit automatically merges user identities from different authentication methods, ensuring a single user profile and preventing duplicate accounts."
tableOfContents: true
sidebar:
  label: Merged user identity
next:
  label: Work with user profiles
  link: /fsa/reference/user-profile/
prev: false
---

import { Badge } from '@astrojs/starlight/components';

Users can sign into your application using different authentication methods. For example, a user might authenticate with a passwordless method today and LinkedIn OAuth tomorrow. You want to treat these as the same user, not create separate user accounts for each authentication method.

{ /** TODO: Add a diagram */}

## Link identities

When users prove access to their email inbox through any authentication method, Scalekit treats this as an identity. Scalekit automatically links multiple identities together using the user's email address as the source of truth.

Scalekit requires email verification to prevent security risks. Some identity providers allow users to create accounts with any email address without verification. For example, someone could create a social login account using another person's email address. Without email verification, this creates unauthorized access to accounts.

## Verify organization domains

Organization administrators often enforce security policies for their organization. Your application should respect these policies when signing users into their organization or workspace.

Organization administrators must prove domain ownership to establish trust for their users:

- **Authentication policies**: Scalekit respects the organization's authentication policies such as Multi-factor authentication (MFA) or Single Sign-On (SSO).
- **Email verification**: Users from verified domains don't need to verify their email addresses individually, since the domain administrator already verified domain ownership.



{/** TODO: Add a screenshot of adding verified domains */}

### Link SSO identities

Users can have multiple SSO credentials when they work with different organizations that each require SSO authentication.

When users sign in through an SSO identity provider for the first time, Scalekit checks if their email domain is verified. If verified, Scalekit automatically links the SSO credential to the user's existing account.

{/*

TODO: Uncomment after invite-only signup is published + reviewed

- **Unverified domains**: Scalekit prompts users to verify their email address before linking the SSO credential

Users from unverified domains must receive an [invitation](/fsa/guides/invite-only-signup/) to join the organization before their first SSO sign-in. The invitation process ensures users can access the correct SSO identity provider during authentication.

*/}

================
File: fsa/guides/migration-guide.mdx
================
---
title: "Migrate to Full Stack Authentication"
description: "Step-by-step guide to move user, organization, and auth flows from existing systems to Scalekit."
sidebar:
  label: "Migrate to Full Stack Auth"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
---
import { Aside, Steps, Tabs, TabItem, LinkCard, Badge } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

Migrating authentication is a big job. **But moving to Scalekit pays dividends**: you off-load SSO integrations, SCIM provisioning, session handling, and more—so your team can focus on product. This guide walks you through a **safe, incremental migration** from any existing solution to **Scalekit's full-stack auth platform**.

This migration guide helps you:
- Export user and organization data from your current system
- Import data into Scalekit using APIs or SDKs
- Update your application's authentication flows
- Test and deploy the new authentication system

<Aside type="note" title="Need a hand?">
Our Solutions team has run dozens of successful migrations. [Contact us](/support/contact-us) and we'll craft a smooth cut-over plan together.
</Aside>

<Steps>

1. ## Audit and export your data

   Before you switch to Scalekit, create a comprehensive inventory of your existing setup and export your data:

   **Code audit:**
   - Sign-up and login flows
   - Session middleware and token validation
   - Role-based access control (RBAC) logic
   - Email verification flows
   - Logout and session termination

   **Data export:**
   - User records (emails, names, verification status)
   - Organization/tenant structure
   - Role assignments and permissions
   - Authentication provider configurations (if using SSO)

   **Backup plan:**
   - Export a sample JWT token or session cookie to understand your current format
   - Set up a feature flag to route traffic back to the old system if needed
   - Document your rollback procedure

   The minimal user schema looks like this:

   | **Field** | **Description** | **Status** |
   |-----------|-----------------|------------|
   | `email` | Primary login identifier. | Required |
   | `first_name` | The user's given name. | Optional |
   | `last_name` | The user's family name. | Optional |
   | `email_verified` | Boolean flag. Treated as `false` if omitted. | Optional |

2. ## Import organizations and users

   Transform your exported data to match Scalekit's format. The `external_id` field is crucial—it stores your original primary key, enabling seamless lookups between your system and Scalekit.

   <InstallSDK />

   **Create organizations first:**

   <Tabs syncKey="tech-stack">
   <TabItem label="cURL" value="curl">
   ```bash title="Create an organization"
   curl "$SCALEKIT_ENVIRONMENT_URL/api/v1/organizations" \
     --request POST \
     --header 'Content-Type: application/json' \
     --data '{
       "display_name": "Megasoft Inc",
       "external_id": "org_123",
       "metadata": { "plan": "enterprise" }
     }'
   ```
   </TabItem>
   <TabItem label="Node.js" value="nodejs">
   ```javascript title="Create organizations"
   const organizations = [
     { display_name: "Megasoft Inc", external_id: "org_123", metadata: { plan: "enterprise" } },
     { display_name: "Acme Corp", external_id: "org_456", metadata: { plan: "starter" } }
   ];

   for (const org of organizations) {
     const result = await scalekit.organization.createOrganization(
       org.display_name,
       {
         externalId: org.external_id,
         metadata: org.metadata
       }
     );
     console.log(`Created organization: ${result.id}`);
   }
   ```
   </TabItem>
   <TabItem label="Python" value="python">
   ```python title="Create organizations"
   from scalekit.v1.organizations.organizations_pb2 import CreateOrganization

   organizations = [
     {"display_name": "Megasoft Inc", "external_id": "org_123", "metadata": {"plan": "enterprise"}},
     {"display_name": "Acme Corp", "external_id": "org_456", "metadata": {"plan": "starter"}}
   ]

   for org in organizations:
     result = scalekit_client.organization.create_organization(
       CreateOrganization(
         display_name=org["display_name"],
         external_id=org["external_id"],
         metadata=org["metadata"]
       )
     )
     print(f"Created organization: {result.id}")
   ```
   </TabItem>
   <TabItem label="Go" value="go">
   ```go title="Create organizations"
   organizations := []struct {
     DisplayName string
     ExternalID  string
     Metadata    map[string]interface{}
   }{
     {"Megasoft Inc", "org_123", map[string]interface{}{"plan": "enterprise"}},
     {"Acme Corp", "org_456", map[string]interface{}{"plan": "starter"}},
   }

   for _, org := range organizations {
     result, err := scalekit.Organization.CreateOrganization(
       ctx,
       org.DisplayName,
       scalekit.CreateOrganizationOptions{
         ExternalID: org.ExternalID,
         Metadata:   org.Metadata,
       },
     )
     if err != nil {
       log.Fatal(err)
     }
     fmt.Printf("Created organization: %s\n", result.ID)
   }
   ```
   </TabItem>
   <TabItem label="Java" value="java">
   ```java title="Create organizations"
   List<Map<String, Object>> organizations = Arrays.asList(
     Map.of("display_name", "Megasoft Inc", "external_id", "org_123", "metadata", Map.of("plan", "enterprise")),
     Map.of("display_name", "Acme Corp", "external_id", "org_456", "metadata", Map.of("plan", "starter"))
   );

   for (Map<String, Object> org : organizations) {
     CreateOrganization createOrganization = CreateOrganization.newBuilder()
       .setDisplayName((String) org.get("display_name"))
       .setExternalId((String) org.get("external_id"))
       .putAllMetadata((Map<String, String>) org.get("metadata"))
       .build();

     Organization result = scalekitClient.organizations().create(createOrganization);
     System.out.println("Created organization: " + result.getId());
   }
   ```
   </TabItem>
   </Tabs>

   **Then create users within organizations:**

   <Tabs syncKey="tech-stack">
   <TabItem label="cURL" value="curl">
   ```bash title="Create a user inside an organization"
   curl "$SCALEKIT_ENVIRONMENT_URL/api/v1/organizations/{organization_id}/users" \
     --request POST \
     --header 'Content-Type: application/json' \
     --data '{
       "email": "user@example.com",
       "external_id": "usr_987",
       "membership": {
         "roles": ["admin"],
         "metadata": { "department": "engineering" }
       },
       "user_profile": {
         "first_name": "John",
         "last_name": "Doe",
         "locale": "en-US"
       }
     }'
   ```
   </TabItem>
   <TabItem label="Node.js" value="nodejs">
   ```javascript title="Create users in organizations"
   const { user } = await scalekit.user.createUserAndMembership("org_123", {
     email: "user@example.com",
     externalId: "usr_987",
     metadata: {
       department: "engineering",
       location: "nyc-office"
     },
     userProfile: {
       firstName: "John",
       lastName: "Doe",
     },
   });
   ```
   </TabItem>
   <TabItem label="Python" value="python">
   ```python title="Create users in organizations"
   from scalekit.v1.users.users_pb2 import CreateUser
   from scalekit.v1.commons.commons_pb2 import UserProfile

   user_msg = CreateUser(
     email="user@example.com",
     external_id="usr_987",
     metadata={"department": "engineering", "location": "nyc-office"},
     user_profile=UserProfile(
       first_name="John",
       last_name="Doe"
     )
   )

   create_resp, _ = scalekit_client.user.create_user_and_membership("org_123", user_msg)
   ```
   </TabItem>
   <TabItem label="Go" value="go">
   ```go title="Create users in organizations"
   newUser := &usersv1.CreateUser{
     Email:      "user@example.com",
     ExternalId: "usr_987",
     Metadata: map[string]string{
       "department": "engineering",
       "location":   "nyc-office",
     },
     UserProfile: &usersv1.CreateUserProfile{
       FirstName: "John",
       LastName:  "Doe",
     },
   }

   cuResp, err := scalekit.User().CreateUserAndMembership(ctx, "org_123", newUser, false)
   if err != nil {
     log.Fatal(err)
   }
   ```
   </TabItem>
   <TabItem label="Java" value="java">
   ```java title="Create users in organizations"
   CreateUser createUser = CreateUser.newBuilder()
     .setEmail("user@example.com")
     .setExternalId("usr_987")
     .putMetadata("department", "engineering")
     .putMetadata("location", "nyc-office")
     .setUserProfile(
       CreateUserProfile.newBuilder()
         .setFirstName("John")
         .setLastName("Doe")
         .build())
     .build();

   CreateUserAndMembershipResponse cuResp = scalekitClient.users()
     .createUserAndMembership("org_123", createUser);
   System.out.println("Created user: " + cuResp.getUser().getId());
   ```
   </TabItem>
   </Tabs>

   - **Batch** your imports—run them in parallel for speed but respect rate limits
   - Include `"sendInvitationEmail": false` when creating users to skip invite emails. Scalekit will automatically set the membership status to `active` and mark the email as verified.
   <br/>

3. ## Configure redirects and roles

   The authentication callback URL is necessary for tokens to return safely. However, depending on your application, you may want to add more redirects (such as post-logout URLs, so you can control the user experience and destination after logout). Head to **Settings → Redirects** in the dashboard. Review our [redirect URI guide](/sso/reference/redirects/) for validation rules and wildcard configuration.

   **Set up roles:**
   Define roles in Scalekit to control what actions users can perform in your application. When users log in, Scalekit provides their assigned roles to your application.

   - Create your roles under **User Management → Roles** or via the SDK
   - While importing users, include the `roles` array in the `membership` object. [Read more about roles](/fsa/guides/app-roles/).
   - Need organization-specific roles? [Reach out to discuss](/support/contact-us) your requirements
   <br/>

4. ## Update your application code

   **Replace session middleware:**
   Replace legacy JWT validation with the Scalekit SDK or our **JWKS endpoint**. Verify:
   - Access tokens are accepted across all routes
   - Refresh tokens renew seamlessly
   - Ensure your application's checks use the `roles` claim from Scalekit's tokens ([learn more](/fsa/guides/app-roles/#accessing-user-roles))

   <Aside type="tip">Use our language SDKs for drop-in middlewares in Node, Go, Python, and Java.</Aside>

   **Customize your Login Page:**
   Your application redirects users to a **Scalekit-hosted login page**. Tailor the experience by updating your logo, colours, copy, and legal links in the dashboard.

   **Update secondary flows:**
   - Verify email prompt
   - [Branding (logo, colours, legal copy)](/fsa/guides/login-page-branding/)
   <br />

5. ## Deploy and monitor
   Execute your migration carefully with proper monitoring:

   **Pre-deployment testing:**
   - Test login flows with a few migrated users
   - Verify session management and token validation
   - Check role-based access control

   **Deployment steps:**
   1. Deploy your updated application code
   2. Enable the feature flag to route traffic to Scalekit
   3. Monitor authentication success rates and error logs
   4. Have your rollback plan ready

   **Post-deployment monitoring:**
   - Watch authentication error rates
   - Monitor session creation and validation
   - Check user feedback and support tickets
   - Verify SSO connections work correctly

   <Aside type="tip">Start with a small percentage of users (5-10%) before rolling out to everyone.</Aside>

</Steps>


## Frequently Asked Questions

<details>
<summary>Why can't users log in after migration?</summary>

- Verify callback URLs are registered in Scalekit dashboard
- Check that `external_id` mappings are correct
- Ensure email addresses match exactly between systems
</details>

<details>
<summary>Why is session validation failing?</summary>

- Update JWT validation to use Scalekit's JWKS endpoint
- Verify token expiration and refresh logic
- Check that role claims are read correctly
</details>

<details>
<summary>Why aren't SSO connections working?</summary>

- Confirm organization has SSO enabled in features
- Verify identity provider configuration
- Test with IdP-initiated login
</details>

<Aside type="note" title="Password migration">
Password-based authentication migrations are on the way. If you need to migrate existing passwords, please [contact us](/support/contact-us).
</Aside>

================
File: fsa/guides/organization-switching.mdx
================
---
title: "Implement organization switcher"
description: "Learn how Scalekit handles users who belong to multiple organizations and need to switch between different workspaces."
sidebar:
  label: "Organization switcher"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: "Automated user provisioning"
  link: "/fsa/guides/automated-user-provisioning/"
next: false
---
import { Card, Badge, Steps, TabItem, Tabs, Aside, LinkCard } from '@astrojs/starlight/components';
import CheckItem from '@/components/ui/CheckItem.astro';

Organization switching allows users to access multiple organizations or workspaces within your application. This feature is essential for B2B applications where users may belong to several organizations simultaneously, such as their own company and client organizations they work with.

Common organization switching scenarios include:

- **Personal workspace to corporate workspace**: A user signs up with their organization's email address, creating their personal workspace. Later, when their organization subscribes to your app, a new corporate workspace is created (for example, "AcmeCorp workspace").
- **Multi-organization contractors**: External consultants or contractors who belong to multiple organizations, each with their own SSO authentication policies. These users need to seamlessly switch between different client organizations while maintaining secure access to each workspace.

![](@/assets/docs/fsa/org-switcher/1-switcher.png)


## Default organization switching behavior

When users belong to multiple organizations, Scalekit automatically handles organization switching during the authentication flow:

{/* <!-- TODO: Add a diagram here --> */}

<Steps>

1.  Users click **Sign In** on your application.
2.  Your application redirects users to the sign-in page.
3.  Users authenticate using one of the available sign-in methods.
4.  Scalekit displays a list of organizations that users belong to.
5.  Users select the organization that they want to sign in to.
6.  Users are redirected to the organization's workspace and signed in.

</Steps>

<Aside type="note">
  For organizations with Single Sign-On (SSO) enabled on a verified domain, the sign-in flow is automated. When a user enters their work email address, Scalekit redirects them to their organization's identity provider to sign in. The organization selection step is skipped.
</Aside>

Scalekit provides built-in support for organization switching through the following features:

- **Automatic organization detection**: Scalekit identifies all organizations a user belongs to based on their email domain and invitation status
- **Organization switcher UI**: Users see a list of available organizations when signing in
- **Secure session management**: Each organization maintains its own authentication context and policies

## Control organization switching behavior

After signing in, you can customize the organization switcher's behavior by adding query parameters and redirecting users to organization switcher.

These parameters give you precise control over how users navigate between organizations.

### Display organization switcher

    To show the organization switcher, users first need to authenticate, then they can access the organization switcher. Add the `prompt: 'select_account'` parameter when generating the authorization URL. This forces Scalekit to display a list of organizations the user belongs to, even if they're already signed in.

    <Tabs syncKey="tech-stack">
      <TabItem value="node" label="Node.js">
        ```javascript title="Express.js" wrap "authorizationUrl" ins={4}
        const redirectUri = 'http://localhost:3000/api/callback';
        const options = {
          scopes: ['openid', 'profile', 'email', 'offline_access'],
          prompt: 'select_account'
        };

        const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);

        res.redirect(authorizationUrl);
        ```
      </TabItem>
      <TabItem value="python" label="Python">
        ```python title="Flask" wrap "authorizationUrl" ins={6}
        from scalekit import AuthorizationUrlOptions

        redirect_uri = 'http://localhost:3000/api/callback'
        options = AuthorizationUrlOptions()
        options.scopes = ['openid', 'profile', 'email', 'offline_access']
        options.prompt = 'select_account'

        authorization_url = scalekit.get_authorization_url(redirect_uri, options)
        return redirect(authorization_url)
        ```
      </TabItem>
      <TabItem value="go" label="Go">
        ```go title="Gin" wrap "authorizationUrl" ins={5}
        redirectUri := "http://localhost:3000/api/callback"
        options := scalekit.AuthorizationUrlOptions{
            Scopes: []string{"openid", "profile", "email", "offline_access"},
            Prompt: "select_account",
        }

        authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)
        if err != nil {
            // handle error appropriately
            panic(err)
        }

        c.Redirect(http.StatusFound, authorizationUrl.String())
        ```
      </TabItem>
      <TabItem value="java" label="Java">
        ```java title="Spring" wrap "authorizationUrl" ins={8}
        import com.scalekit.internal.http.AuthorizationUrlOptions;
        import java.net.URL;
        import java.util.Arrays;

        String redirectUri = "http://localhost:3000/api/callback";
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
        options.setPrompt("select_account");

        URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
        ```
      </TabItem>
    </Tabs>

    This will display the organization switcher UI where users can choose which organization to access.

### Switch users directly to a specific organization

To bypass the organization switcher and directly authenticate users into a specific organization, include both the `prompt: 'select_account'` parameter **and** the `organization_id=org_xxxx` parameter:

    <Tabs syncKey="tech-stack">
      <TabItem value="node" label="Node.js">
        ```javascript title="Express.js" wrap "authorizationUrl" ins={4,5}
        const redirectUri = 'http://localhost:3000/api/callback';
        const options = {
          scopes: ['openid', 'profile', 'email', 'offline_access'],
          prompt: 'select_account',
          organizationId: 'org_1233434'
        };

        const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);

        res.redirect(authorizationUrl);
        ```
      </TabItem>
      <TabItem value="python" label="Python">
        ```python title="Flask" wrap "authorizationUrl" ins={6,7}
        from scalekit import AuthorizationUrlOptions

        redirect_uri = 'http://localhost:3000/api/callback'
        options = AuthorizationUrlOptions()
        options.scopes = ['openid', 'profile', 'email', 'offline_access']
        options.prompt = 'select_account'
        options.organization_id = 'org_1233434'

        authorization_url = scalekit.get_authorization_url(redirect_uri, options)
        return redirect(authorization_url)
        ```
      </TabItem>
      <TabItem value="go" label="Go">
        ```go title="Gin" wrap "authorizationUrl" ins={4,5}
        redirectUri := "http://localhost:3000/api/callback"
        options := scalekit.AuthorizationUrlOptions{
            Scopes: []string{"openid", "profile", "email", "offline_access"},
            Prompt: "select_account",
            OrganizationId: "org_1233434",
        }

        authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)
        if err != nil {
            // handle error appropriately
            panic(err)
        }

        c.Redirect(http.StatusFound, authorizationUrl.String())
        ```
      </TabItem>
      <TabItem value="java" label="Java">
        ```java title="Spring" wrap "authorizationUrl" ins={8,9}
        import com.scalekit.internal.http.AuthorizationUrlOptions;
        import java.net.URL;
        import java.util.Arrays;

        String redirectUri = "http://localhost:3000/api/callback";
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));
        options.setPrompt("select_account");
        options.setOrganizationId("org_1233434");

        URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
        ```
      </TabItem>
    </Tabs>

    When you include both parameters, Scalekit will:
- **If the user is already authenticated**: Directly sign them into the specified organization
- **If the user needs to authenticate**: First authenticate the user, then sign them into the specified organization

## Organization switching parameters

Use these parameters to control the organization switching behavior:

| Parameter | Description | Example |
|-----------|-------------|---------|
| `prompt=select_account` | Shows the organization switcher UI | Forces organization selection even for authenticated users |
| `prompt=select_account&organizationId=org_123` | Direct organization access | Bypasses switcher and authenticates directly into the specified organization |

<Aside type="tip">
  The `organizationId` parameter works only when combined with `prompt=select_account`. Using `organizationId` alone will not have the desired effect.
</Aside>

================
File: fsa/guides/passwordless.mdx
================
---
title: Enable passwordless sign in
description: How to configure passwordless authentication for your application
sidebar:
  label: "Passwordless"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev:
  label: "Implement sign up"
  link: "/fsa/guides/implement-signup/"
next: false
---
import { Steps, Tabs, TabItem, Aside, LinkButton, LinkCard } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Passwordless authentication allows your users to sign in without entering a password. Users can authenticate using any of the following methods:

- A verification code (OTP) sent by email.
- A magic link sent by email.
- Both a verification code and a magic link sent by email.

This guide shows you how to enable each passwordless login method. You should complete the [quickstart guide](/fsa/quickstart/) before following this guide, as it covers building a sign-in page that combines Scalekit's hosted UI.

## Configure passwordless login settings

You can modify the passwordless login behavior from the Scalekit dashboard without changing your code.

 ![](@/assets/docs/unlisted/passwordless/1-v2.png)

### Choose a passwordless login method

<Steps>

1. Navigate to the Authentication tab in your Scalekit dashboard environment.
2. Select one of the following options:

    | Method | Description |
    |--------|-------------|
    | Verification code (OTP) | Users receive a one-time code via email that they must enter to sign in. |
    | Magic link | Users receive a secure link via email that they can click to sign in directly. |
    | Verification code and magic link | Users receive both a verification code and a magic link via email, allowing them to choose their preferred method. |

3. Click Save to apply your changes.

</Steps>

### Enable same browser origin enforcement

This setting improves security by requiring users to complete magic link authentication in the same browser where they initiated the sign-in process. This helps prevent phishing attacks where an attacker could use an intercepted magic link on a different device or browser.

To enable this setting, select the **Enforce same browser origin** checkbox in the **Passwordless** section, and click **Save**.

### Enable new passwordless credentials on resend

This setting improves security by generating a new verification code or magic link each time a user asks to resend one. This invalidates the previously sent credential.

To enable this setting, select the **Enable new passwordless credentials on resend** checkbox in the **Passwordless** section, and click **Save**.

### Customize email templates

You can customize the emails sent to users to match your brand, or you can [bring your own email provider](/guides/passwordless/custom-email-provider/) to handle email sends related to passwordless login. Scalekit sends the emails when you use it as your email provider.

<Aside type="tip" title="Private Beta">
These customization features are currently in private beta. Please [contact our support team](/support/contact-us/) to have them enabled for your account.
</Aside>

================
File: fsa/guides/social-logins.mdx
================
---
title: Enable social logins
description: How to configure social logins for your application
sidebar:
  label: "Social logins"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
next:
  label: "Brand your login page"
  link: "/fsa/guides/login-page-branding/"
---
import { Steps, Tabs, TabItem, Aside, LinkCard } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

Social logins allow users to sign in to your application using their existing accounts from providers like Google, Microsoft, and GitHub. Users can authenticate using any of the following methods:

- Direct provider authentication when specifying a provider
- Scalekit's hosted UI displaying all configured social providers
- Combination of multiple social providers based on your configuration

This guide shows you how to enable social login for your application.

![Social Logins Flow](@/assets/docs/common/social-connections/0.png)

This guide shows you how to enable each social login method. You should complete the [quickstart guide](/fsa/quickstart/) before following this guide, as it covers building a sign-in page that combines Scalekit's hosted UI.

## Configure social login settings

You can manage which social providers are available to your users and customize their behavior from the Scalekit dashboard without changing your code.

![Configure a social connection](@/assets/docs/fsa/auth-methods/social-logins-1.png)

### Add social providers

<Steps>

1. Log in to your [Scalekit Dashboard](https://app.scalekit.com).
2. Navigate to **Authentication > Social Logins**.
3. Select a provider and enter the required credentials (typically a Client ID and Client Secret) from your provider's developer console.
4. Save the connection.

</Steps>

Learn how to configure individual [social connection providers](/guides/integrations/social-connections/).

Once configured, the provider will be available on your sign-in page for users to sign into your application.

================
File: fsa/guides/user-invitations.mdx
================
---
title: Invite users
description: "Learn how to build invite-only access for your application using Scalekit, with support for both dashboard-based and programmatic user invitations."
sidebar:
  label: Invite users
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
next:
  label: User management API reference
  link: https://docs.scalekit.com/apis

---
import { Card, CardGrid, Steps, TabItem, Tabs, Aside, LinkCard, LinkButton, Badge } from '@astrojs/starlight/components';
import { InstallSDKSection, EnvSection, RedirectAuthPageSection, RetrieveUserDetailsSection, UserProfileSection, CreateUserMembershipSection, CreateOrganizationSection } from '@components/templates';

Build applications that enable organization owners to invite users to join their organization. Scalekit takes care of sending the invite emails, verifying their email addresses, and creating the user accounts end to end.

Invite-only access is ideal for the following scenarios:

- **Enterprise applications**: Organization admins need to invite team members to join their workspace.
- **B2B SaaS platforms**: You want to restrict access to invited users only
- **Exclusive communities**: Applications that require invitation-based membership.

Scalekit helps you implement invite-only access while handling the complexity of user management and authentication.

For applications where you want to build custom invitation flows in your own UI, Scalekit provides APIs to programmatically invite users. This is ideal when organization admins or workspace owners need to invite team members directly from your application's dashboard.

Common use cases include:

- **Admin dashboards**: Organization admins can invite users from a settings or team management page.
- **Bulk invitations**: Import and invite multiple users at once from CSV files or directory systems.
- **Custom workflows**: Implement approval processes or conditional invitations based on business logic.
- **Integration with existing systems**: Connect invitation flows with your CRM, HR systems, or user directories.

## Inviting Users through the Scalekit Dashboard

The quickest way to get started with user invitations is through the Scalekit Dashboard. Navigate to the Users section and click the "Add User" button to invite new members to your organization. You can specify their email address, assign roles, and customize the invitation settings directly from the UI.

![](@/assets/docs/fsa/user-management/3-ui-user-invite.png)

## Programmatic Invitations with Scalekit SDK

For applications that require custom invitation flows or automated user management, Scalekit provides a comprehensive SDK. This allows you to programmatically invite users, manage invitations, and integrate with your existing systems.

<Steps>
 1. ### Create user invitations

    To invite a user to an organization, create a user membership with their email address and the target organization ID. Scalekit handles sending the invitation email and managing the invitation process.

    <CreateUserMembershipSection />

    **Key parameters:**
    - `email`: The email address of the user to invite (required)
    - `organization_id`: The ID of the organization they're joining (required)
    - `sendActivationEmail`: Set to `true` to automatically send invitation emails (recommended)
    - `roles`: Optional array of roles to assign to the invited user
    - `metadata`: Optional custom data to associate with the membership

    <Aside type="note" title="Customize invitation expiration">
      Configure invitation link expiration periods in **Scalekit Dashboard** → **User Management** → **Settings**.
    </Aside>

 2. ### View invitation response

    When a user is successfully invited, Scalekit returns a user object with membership details. The membership status will be `PENDING_INVITE` until the user accepts the invitation.

    ```json title="Example invitation response"
    {
      "user": {
        "id": "usr_01HTR0ABCXYZ",
        "environmentId": "env_01HTQZ99MMNZ",
        "createTime": "2025-06-19T15:41:22Z",
        "updateTime": "2025-06-19T15:41:22Z",
        "email": "user@example.com",
        "externalId": "crm-user-87425",
        "memberships": [
          {
            "organizationId": "org_xxxxxxxxxxxx",
            "joinTime": "2025-06-19T15:41:22Z",
            "membershipStatus": "ACTIVE",
            "roles": [
              {
                "id": "role_admin",
                "name": "admin"
              }
            ],
            "primaryIdentityProvider": "IDENTITY_PROVIDER_UNSPECIFIED",
            "metadata": {
              "plan": "free",
              "department": "Engineering"
            }
          }
        ],
        "userProfile": {
          "id": "prof_01HTR0PQRMNO",
          "firstName": "John",
          "lastName": "Doe",
          "name": "John Doe",
          "locale": "en",
          "emailVerified": false,
          "phoneNumber": "",
          "metadata": {},
          "customAttributes": {}
        },
        "metadata": {
          "plan": "free",
          "department": "Engineering"
        },
        "lastLogin": null
      }
    }
    ```

    <Aside type="note" title="Membership status tracking">
      Monitor the `membershipStatus` field to track invitation progress:
      - `PENDING_INVITE`: User has been invited but hasn't accepted yet
      - `ACTIVE`: User has accepted the invitation and can access the organization
      - `INVITE_EXPIRED`: Membership has been deactivated
    </Aside>

 3. ### Handle user invitation acceptance

    When invited users click the invitation link in their email, Scalekit redirects them to your application's [registered initiate login endpoint](/fsa/reference/redirects/#understanding-redirect-types). Your application then completes the authentication flow.

    **Set up the initiate login endpoint:**

    1. **Register your endpoint** in the Scalekit dashboard (for example, `https://your-app.com/auth/login/initiate`)

    2. **Handle the redirect** by [constructing an authorization URL](/fsa/quickstart/#redirect-users-to-hosted-login-page) and redirecting the user to Scalekit's hosted login page

    3. **Complete authentication** when the user returns to your callback URL

    **Example endpoint implementation:**

    <Tabs syncKey="tech-stack">
      <TabItem value="node" label="Node.js">
        ```javascript title="Express.js"
        app.get('/auth/login/initiate', (req, res) => {
          const redirectUri = 'http://localhost:3000/api/callback';
          const options = {
            scopes: ['openid', 'profile', 'email', 'offline_access']
          };

          const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);
          res.redirect(authorizationUrl);
        });
        ```
      </TabItem>
      <TabItem value="python" label="Python">
        ```python title="Flask"
        @app.route('/auth/login/initiate')
        def initiate_login():
            redirect_uri = 'http://localhost:3000/api/callback'
            options = AuthorizationUrlOptions()
            options.scopes = ['openid', 'profile', 'email', 'offline_access']

            authorization_url = scalekit.get_authorization_url(redirect_uri, options)
            return redirect(authorization_url)
        ```
      </TabItem>
      <TabItem value="go" label="Go">
        ```go title="Gin"
        func initiateLogin(c *gin.Context) {
            redirectUri := "http://localhost:3000/api/callback"
            options := scalekit.AuthorizationUrlOptions{
                Scopes: []string{"openid", "profile", "email", "offline_access"}
            }

            authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)
            if err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }

            c.Redirect(http.StatusFound, authorizationUrl.String())
        }
        ```
      </TabItem>
      <TabItem value="java" label="Java">
        ```java title="Spring"
        @GetMapping("/auth/login/initiate")
        public ResponseEntity<Void> initiateLogin() {
            String redirectUri = "http://localhost:3000/api/callback";
            AuthorizationUrlOptions options = new AuthorizationUrlOptions();
            options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));

            URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);

            return ResponseEntity.status(HttpStatus.FOUND)
                .header("Location", authorizationUrl.toString())
                .build();
        }
        ```
      </TabItem>
    </Tabs>

    **Authentication flow:**

    ![](@/assets/docs/fsa/user-management/2-email-invite.png)

    When a user accepts an invitation, Scalekit handles the authentication process automatically:

    1. **User clicks invitation link** → Scalekit redirects to your initiate login endpoint
    2. **Your app redirects to Scalekit** → Your initiate login endpoint creates an authorization URL and redirects to Scalekit's login page
    3. **User completes authentication** → Scalekit processes the login and redirects back to your callback URL with an authorization code
    4. **Your app exchanges code for user details** → Your callback endpoint exchanges the authorization code for ID Token and redirects the user to your dashboard
    5. **Decode ID Token for user profile** → Decode the JWT ID Token to access user information like email, name and verification status

    <Aside type="note" title="Automatic email verification">
      Scalekit automatically verifies the user's email address during this process. Experience of the user will be seamless and are logged in to your application instantly.
    </Aside>

</Steps>

#

================
File: fsa/reference/redirects.mdx
================
---
title: "Redirects"
description: "Learn how to configure and validate redirect URLs in Scalekit for secure authentication flows, including callback, login, logout, and back-channel logout endpoints."
sidebar:
  label: "Redirect configurations"
---

import { Aside, Icon } from '@astrojs/starlight/components'

Redirects are registered endpoints in Scalekit that control where users are directed during authentication flows. You must configure these endpoints in the Scalekit dashboard before they can be used.

<Aside type="note">
All redirect URIs must be registered under Authentication settings in your Scalekit dashboard. This is a security requirement to prevent unauthorized redirects.
</Aside>

## Understanding redirect types

Scalekit uses four types of redirect endpoints, each serving a specific purpose in the authentication flow:

### Allowed callback URLs
**Purpose**: Where users are sent after successful authentication to exchange authorization codes and retrieve profile information.

**Example scenario**: A user completes sign-in and Scalekit redirects them to `https://yourapp.com/callback` where your application processes the authentication response.

### Intiate login URL
**Purpose**: Where users are redirected to start the authentication process when they need to sign in.

**Example scenario**: When a user's session expires or they access a protected resource, they're redirected to `https://yourapp.com/login` which then redirects to Scalekit's authentication endpoint.

### Post logout URL
**Purpose**: Where users are sent after successfully signing out of your application.

**Example scenario**: After logging out, users are redirected to `https://yourapp.com/goodbye` to confirm their session has ended.

### Back channel logout URL
**Purpose**: A secure endpoint that receives notifications when an administrator logs out a user, commonly used in Enterprise SSO scenarios.

**Example scenario**: An IT administrator removes a user from their organization's identity provider, and Scalekit sends a logout notification to `https://yourapp.com/api/logout` to terminate the user's session.

## Configure redirect URLs

To configure your redirect URIs:

1. Navigate to **Authentication settings** in your Scalekit dashboard
2. Add your URIs following the validation rules below
3. Save your configuration

## URI validation rules

Your redirect URIs must meet specific requirements that vary between development and production environments:

### Environment-specific requirements

| Validation rule                                                                                                 | Development environment                                                                                                                 | Production environment                         |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| Supported schemes                                                                                               | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `http` <Icon name="approve-check" /> `https`</div>                                     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https`</div> |
| localhost usage                                                                                                       | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> Allowed</div>                                                                                                                 | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Wildcard support (\*)                                                                                           | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> Allowed</div> | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Maximum URI length                                                                                                  | 256 characters                                                                                                                          | 256 characters                                 |
| Query parameters <pre>yourapp.com/callback?query=value</pre>     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                                                                                                                | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Fragment components <pre>`yourapp.com/callback#fragment=value`</pre> | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                                                                                                                | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |

### Use wildcards for development

Wildcards can simplify testing in development environments, but they must follow specific patterns:

| Validation rule                                                                     | Examples                                                                                                                                                                                                          |
| ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Wildcards cannot be used as root-level domains                          | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://*.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://auth-*.acmecorp.com`</div> |
| Only one wildcard character is allowed per URI                                 | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://*.*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div>                                                                            |
| Wildcards must be in the hostname component only     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://acmecorp.*.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div>                                                                  |
| Wildcards must be in the outermost subdomain | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://auth.*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.auth.acmecorp.com`</div>                                                        |

<Aside type="caution">
According to the <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2" target="_blank">OAuth 2.0 specification</a>, redirect URIs must be absolute URIs. For development convenience, Scalekit relaxes this restriction slightly by allowing wildcards in development environments.
</Aside>

================
File: fsa/reference/user-management-settings.mdx
================
---
title: "User management settings"
description: "Configure user management settings, including user attributes and configuration options from the Scalekit dashboard."
sidebar:
  label: "User management settings"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
prev: false
---
import { Tabs, TabItem } from '@astrojs/starlight/components';

User management settings allow you to configure how user data is handled in the environment and what attributes are available for users in your application. These settings are accessible from the **User Management** section in the Scalekit dashboard.

The Configuration tab provides several important settings that control user registration, organization limits, and branding.

![](@/assets/docs/fsa/user-management/2-configuration.png)

### Sign-up for your application

Control whether users can sign up and create new organizations. When enabled, users can register for your application and automatically create a new organization.

### Organization creation limit per user

Define the maximum number of organizations a single user can create. This helps prevent abuse and manage resource usage across your application.

### Invitation expiry

Configure how long user invitation links remain valid. The default setting of **15 days** ensures that invitations don't remain active indefinitely, improving security while giving invitees reasonable time to accept.

### Organization meta name

Customize what you call an "Organization" in your application. This meta name appears throughout all Scalekit-hosted pages. For example, you might call it:
- "Company" for B2B applications
- "Team" for collaboration tools
- "Workspace" for productivity apps
- "Account" for multi-tenant systems

## User attributes

The User Attributes tab allows you to define custom fields that will be available for user profiles. These attributes help you collect and store additional information about your users beyond the standard profile fields.

![](@/assets/docs/fsa/user-management/1-user-profile.png)

When you define custom user attributes, they become part of the user's profile data that your application can access. This allows you to:

- Collect additional information during user registration
- Store application-specific user data
- Personalize user experiences based on these attributes
- Use the data for application logic and user management

================
File: fsa/reference/user-profile.mdx
================
---
title: "Work with user profiles"
description: How to retrieve, update, and work with normalized user profile data in Scalekit
sidebar:
  label: "Work with user profiles"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
prev: false
next: false
---
import { Tabs, TabItem, Aside, Badge, Steps } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import CheckItem from '@/components/ui/CheckItem.astro';

When users authenticate through any method—enterprise SSO, social login, or passwordless—Scalekit normalizes their profile information into a consistent, standardized format. This unified approach eliminates the complexity of handling different data formats from various identity providers.

This guide shows you how to work with user profiles, retrieve profile information, and keep user data current across your application.

## Understanding normalized profiles

Different identity providers return user information in varying formats and structures. For example:
- Google OAuth might return `given_name` and `family_name`
- Active Directory could provide `givenName` and `surname`
- A SAML provider might use `firstName` and `lastName`

Scalekit automatically converts all these variations into a standard format, so your application logic remains consistent regardless of how users authenticate.

**Scenario**: Your application needs to display user names consistently, whether they signed in via Google, Okta SAML, or passwordless email. With Scalekit's normalization, you always access this data the same way.

## Prerequisites

<Steps>
1. ### Set up your environment

    <CheckItem iconName="external">
     [Create a Scalekit account](https://app.scalekit.com/ws/signup) and complete the quickstart
    </CheckItem>
    <CheckItem iconName="forward-slash">
     Have users authenticating through your application
    </CheckItem>

2. ### Install the Scalekit SDK

    <InstallSDK />

    Configure your API credentials:
    ```bash
    SCALEKIT_ENVIRONMENT_URL='<YOUR_ENVIRONMENT_URL>'
    SCALEKIT_CLIENT_ID='<ENVIRONMENT_CLIENT_ID>'
    SCALEKIT_CLIENT_SECRET='<ENVIRONMENT_CLIENT_SECRET>'
    ```

    Initialize the Scalekit client:
    ```javascript
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      process.env.SCALEKIT_ENVIRONMENT_URL,
      process.env.SCALEKIT_CLIENT_ID,
      process.env.SCALEKIT_CLIENT_SECRET
    );
    ```
</Steps>

{ /**
 TODO: Definitely needs the getUser API endpoint sorted to document it
 */}


## Create and access user profile data

User profiles contain both standardized attributes and the original data from identity providers, giving you flexibility in how you use the information.


## Create users

Create new users in your organization with profile information and metadata. Users can be created with or without an existing organization membership.

### Create user with organization membership

**Scenario**: Add a new employee to your organization with their profile information and role assignments.

<Tabs syncKey="tech-stack">
  <TabItem value="node" label="Node.js">
    ```javascript showLineNumbers=false
    const { user } = await scalekit.user.createUserAndMembership("org_123", {
      email: "user@example.com",
      externalId: "ext_12345a67b89c",
      metadata: {
        department: "engineering",
        location: "nyc-office"
      },
      userProfile: {
        firstName: "John",
        lastName: "Doe",
      },
    });
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python showLineNumbers=false
    import os
    from scalekit import ScalekitClient
    from scalekit.v1.users.users_pb2 import CreateUser, CreateUserProfile

    scalekit_client = ScalekitClient(
        env_url=os.getenv("SCALEKIT_ENV_URL"),
        client_id=os.getenv("SCALEKIT_CLIENT_ID"),
        client_secret=os.getenv("SCALEKIT_CLIENT_SECRET"),
    )

    user_obj = CreateUser(
        email="user@example.com",
        external_id="ext_12345a67b89c",
        metadata={"department": "engineering", "location": "nyc-office"},
        user_profile=CreateUserProfile(
            first_name="John",
            last_name="Doe"
        )
    )
    create_resp = scalekit_client.users.create_user_and_membership(organization_id="org_123", user=user_obj)
    ```
  </TabItem>
  <TabItem value="go" label="Go">
    ```go showLineNumbers=false
    newUser := &usersv1.CreateUser{
        Email:      "user@example.com",
        ExternalId: "ext_12345a67b89c",
        Metadata: map[string]string{
            "department": "engineering",
            "location":   "nyc-office",
        },
        UserProfile: &usersv1.CreateUserProfile{
            FirstName: "John",
            LastName:  "Doe",
        },
    }
    cuResp, err := sc.User().CreateUserAndMembership(ctx, "org_123", newUser, false)
    if err != nil { /* handle error */ }
    ```
  </TabItem>
  <TabItem value="java" label="Java">
    ```java showLineNumbers=false
    CreateUser createUser = CreateUser.newBuilder()
        .setEmail("user@example.com")
        .setExternalId("ext_12345a67b89c")
        .putMetadata("department", "engineering")
        .putMetadata("location", "nyc-office")
        .setUserProfile(
            CreateUserProfile.newBuilder()
                .setFirstName("John")
                .setLastName("Doe")
                .build())
        .build();

    CreateUserAndMembershipRequest cuReq = CreateUserAndMembershipRequest.newBuilder()
        .setUser(createUser)
        .build();

    CreateUserAndMembershipResponse cuResp = users.createUserAndMembership("org_123", cuReq);
    System.out.println(cuResp.getUser().getId());
    ```
  </TabItem>
  <TabItem value="curl" label="cURL">
    ```bash showLineNumbers=false
    curl 'https://$SCALEKIT_ENVIRONMENT_URL/api/v1/organizations/{organization_id}/users' \
      --request POST \
      --header 'Content-Type: application/json' \
      --data '{
      "email": "user@example.com",
      "external_id": "ext_12345a67b89c",
      "membership": {
        "metadata": {
          "department": "engineering",
          "location": "nyc-office"
        },
        "roles": "admin"
      },
      "metadata": {
        "department": "engineering",
        "location": "nyc-office"
      },
      "user_profile": {
        "custom_attributes": {
          "department": "engineering",
          "security_clearance": "level2"
        },
        "first_name": "John",
        "last_name": "Doe",
        "locale": "en-US",
        "metadata": {
          "account_status": "active",
          "signup_source": "mobile_app"
        },
        "name": "John Michael Doe",
        "phone_number": "+14155552671"
      }
    }'
    ```
  </TabItem>
</Tabs>


  Most B2B applications create organizations or workspaces to group users together. You'll need to create an organization first before adding users to it by passing `organization_id` to the `createUserAndMembership` method.

  <a href="https://docs.scalekit.com/apis#tag/organizations/POST/api/v1/organizations" target="_blank" rel="noopener">
    Explore Organization APIs →
  </a>

### Get user profile information

**Scenario**: Display a user's profile information in your application's settings page or admin dashboard.

<Tabs syncKey="tech-stack">
  <TabItem value="node" label="Node.js">
    ```javascript showLineNumbers=false
    const { user } = await scalekit.user.getUser("usr_456");
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python showLineNumbers=false
    response = scalekit_client.users.get_user(user_id="usr_456")
    user = response[0].user
    ```
  </TabItem>
  <TabItem value="go" label="Go">
    ```go showLineNumbers=false
    resp, err := sc.User().GetUser(ctx, "usr_456")
    if err != nil { log.Fatal(err) }
    user := resp.User
    ```
  </TabItem>
  <TabItem value="java" label="Java">
    ```java showLineNumbers=false
    GetUserResponse resp = scalekit.users().getUser("usr_456");
    var user = resp.getUser();
    ```
  </TabItem>
</Tabs>

## Update user profiles

Users need to keep their profile information current, and administrators may need to update user details for compliance or organizational changes.

### Update user information

**Scenario**: An organization administrator needs to update a user's department after an internal transfer.

<Tabs syncKey="tech-stack">
  <TabItem value="node" label="Node.js">
    ```javascript
    const updatedUser = await scalekit.user.updateUser("usr_456", {
      userProfile: {
        firstName: "Jane",
        lastName: "Smith", // Updated after marriage
      },
      metadata: {
        department: "Product",            // Transferred departments
        role: "Senior Developer",
        lastUpdated: new Date().toISOString(),
        manager: "john.doe@example.com",
      },
    });

    console.log("User profile updated:", updatedUser.id);
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python
    from datetime import datetime
    from scalekit.v1.users.users_pb2 import UpdateUser, UpdateUserProfile

    update_user = UpdateUser(
        user_profile=UpdateUserProfile(
            first_name="Jane",
            last_name="Smith",
        ),
        metadata={
            "department": "Product",
            "role": "Senior Developer",
            "manager": "john.doe@example.com",
            "lastUpdated": datetime.utcnow().isoformat(),
        },
    )

    response = scalekit_client.users.update_user(user_id="usr_456", user=update_user)
    print("User profile updated!")
    ```
  </TabItem>
  <TabItem value="go" label="Go">
    ```go
    upd := &usersv1.UpdateUser{
        UserProfile: &usersv1.UpdateUserProfile{
            FirstName: "Jane",
            LastName:  "Smith",
        },
        Metadata: map[string]string{
            "department": "Product",
            "role":       "Senior Developer",
            "manager":    "john.doe@example.com",
        },
    }

    resp, err := sc.User().UpdateUser(ctx, "usr_456", upd)
    if err != nil {
        log.Fatalf("update user: %v", err)
    }
    fmt.Println("User profile updated:", resp.User.Id)
    ```
  </TabItem>
  <TabItem value="java" label="Java">
    ```java
    UpdateUser upd = UpdateUser.newBuilder()
        .setUserProfile(UpdateUserProfile.newBuilder()
            .setFirstName("Jane")
            .setLastName("Smith")
            .build())
        .putMetadata("department", "Product")
        .putMetadata("role", "Senior Developer")
        .putMetadata("manager", "john.doe@example.com")
        .build();

    UpdateUserResponse res = users.updateUser(
        "usr_456",
        UpdateUserRequest.newBuilder().setUser(upd).build()
    );
    System.out.println("User profile updated: " + res.getUser().getId());
    ```
  </TabItem>
</Tabs>

### Update user metadata

**Scenario**: Store application-specific information like user preferences, billing details, or custom attributes that enhance your user experience.

<Tabs syncKey="tech-stack">
  <TabItem value="node" label="Node.js">
    ```javascript
    const updatedUser = await scalekit.user.updateUser("usr_456", {
      metadata: {
        theme: "dark",
        timezone: "America/New_York",
        notificationPreferences: {
          email: true,
          slack: false,
          mobile: true,
        },
        lastLoginAt: new Date().toISOString(),
      },
    });

    console.log("User metadata updated");
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python
    from datetime import datetime
    from scalekit.v1.users.users_pb2 import UpdateUser

    update_user = UpdateUser(
        metadata={
            "theme": "dark",
            "timezone": "America/New_York",
            "notificationPreferences": {
                "email": True,
                "slack": False,
                "mobile": True,
            },
            "lastLoginAt": datetime.utcnow().isoformat(),
        },
    )

    response = scalekit_client.users.update_user(user_id="usr_456", user=update_user)
    print("User metadata updated")
    ```
  </TabItem>
  <TabItem value="go" label="Go">
    ```go
    upd := &usersv1.UpdateUser{
        Metadata: map[string]string{
            "theme":      "dark",
            "timezone":   "America/New_York",
            "lastLoginAt": time.Now().Format(time.RFC3339),
        },
    }

    if _, err := sc.User().UpdateUser(ctx, "usr_456", upd); err != nil {
        log.Fatalf("update metadata: %v", err)
    }
    fmt.Println("User metadata updated")
    ```
  </TabItem>
  <TabItem value="java" label="Java">
    ```java
    UpdateUser upd = UpdateUser.newBuilder()
        .putMetadata("theme", "dark")
        .putMetadata("timezone", "America/New_York")
        .putMetadata("lastLoginAt", Instant.now().toString())
        .build();

    users.updateUser(
        "usr_456",
        UpdateUserRequest.newBuilder().setUser(upd).build()
    );
    System.out.println("User metadata updated");
    ```
  </TabItem>
</Tabs>



## User profile structure

Understanding the normalized profile structure helps you work with user data effectively across different authentication methods.

```json title="Sample normalized user profile"
{
  "user": {
    "id": "usr_1234abcd5678efgh",
    "email": "john.doe@acmecorp.com",
    "external_id": "ext_12345a67b89c",
    "create_time": "2025-06-24T12:15:33.784Z",
    "update_time": "2025-06-24T12:15:33.784Z",
    "last_login": "2025-06-24T12:15:33.784Z",
    "user_profile": {
      "id": "usr_profile_1234abcd5678efgh",
      "name": "John Michael Doe",
      "first_name": "John",
      "last_name": "Doe",
      "phone_number": "+14155552671",
      "email_verified": true,
      "locale": "en-US",
      "custom_attributes": {
        "department": "engineering",
        "security_clearance": "level2"
      },
      "metadata": {
        "account_status": "active",
        "signup_source": "mobile_app"
      }
    },
    "metadata": {
      "department": "engineering",
      "location": "nyc-office"
    },
    "memberships": [
      {
        "organization_id": "org_1234abcd5678efgh",
        "name": "Acme Corp",
        "join_time": "2025-06-24T12:15:33.784Z",
        "membership_status": "ACTIVE",
        "primary_identity_provider": "OKTA",
        "metadata": {
          "department": "engineering",
          "location": "nyc-office"
        },
        "roles": [
          {
            "id": "role_123",
            "name": "Developer"
          }
        ]
      }
    ]
  }
}
```

### Standard profile attributes

| Attribute | Data type | Description |
|-----------|-----------|-------------|
| `id` | string | Unique identifier for the user |
| `email` | string | The user's email address |
| `external_id` | string | External identifier for the user |
| `create_time` | string | ISO 8601 timestamp when the user was created |
| `update_time` | string | ISO 8601 timestamp when the user was last updated |
| `last_login` | string | ISO 8601 timestamp of the user's last login |
| `user_profile.name` | string | Full formatted name combining first and last name |
| `user_profile.first_name` | string | The user's first name or given name |
| `user_profile.last_name` | string | The user's last name or surname |
| `user_profile.phone_number` | string | The user's phone number |
| `user_profile.email_verified` | boolean | Whether the email address has been verified |
| `user_profile.locale` | string | User's locale as a BCP 47 language tag (e.g., 'en-US', 'fr') |
| `user_profile.custom_attributes` | object | Custom attributes specific to the user profile |
| `user_profile.metadata` | object | Metadata specific to the user profile |
| `metadata` | object | Custom key-value data specific to your application |

### Membership information

The `memberships` array contains information about the user's organizational memberships and roles.

| Membership attribute | Data type | Description |
|---------------------|-----------|-------------|
| `organization_id` | string | Unique identifier for the organization |
| `name` | string | Name of the organization |
| `join_time` | string | ISO 8601 timestamp when the user joined the organization |
| `membership_status` | string | Status of the membership (e.g., "ACTIVE", "INACTIVE") |
| `primary_identity_provider` | string | Primary identity provider for this membership |
| `metadata` | object | Organization-specific metadata for the user |
| `roles` | array | Array of role objects with `id` and `name` properties |

Now that you understand user profiles, explore related topics:

- [Manage users](/fsa/reference/user-profile/) to learn about creating and managing user accounts
- [Configure user roles](/fsa/guides/app-roles/) to define permissions and access control
- [Implement sign-up](/fsa/guides/implement-signup/) to understand how profiles are created during registration

================
File: fsa/data-modelling.mdx
================
---
title: Model your data
description: "Learn how to map your existing data model to Scalekit's core concepts of Organizations and Users for a successful B2B SaaS application architecture."
sidebar:
  label: "Design your data model"
next:
  label: "Need help to set up?"
  link: "/contact-us"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
---

import {
  CardGrid, Aside, TabItem, Tabs, Card, LinkCard
 } from '@astrojs/starlight/components'

The first step in architecting your application to use Scalekit is mapping your current data model to Scalekit's core entities. This guide outlines key considerations and approaches for a range of existing data models.

Scalekit's B2B data model centers on two first-class API entities: Organizations and Users.

## Scalekit's core concepts

Scalekit organizes your application's data into two main components:

- **Organizations** represent your application's tenants or workspaces. They are the core of Scalekit's multi-tenant architecture. Each organization can contain multiple users who work together.

- **Users** are the people who access your application. Each user:
  - Has a unique email address within the Scalekit environment.
  - Can belong to multiple organizations.
  - Is automatically linked across organizations when using the same email address.
  - Can have different roles in each organization they belong to.

This structure lets you manage access across different teams while keeping user identities consistent.

![](@/assets/docs/fsa/model-your-data/1-k.png)

## Defining your top-level tenant

Your application's top-level tenant is typically your business customer, who pays for your service and owns all the data and resources within their workspace. This tenant maps directly to Scalekit's **Organization** entity. This meta label can be [customized](/fsa/guides/manage-organization/) to _team_, _workspace_, or _account_ to match your product's terminology.

Key characteristics of a top-level tenant include:

<CardGrid>

<Card>
##### Account ownership
- Manages subscriptions or contract terms
- Controls billing and service-level agreements
</Card>

<Card>
##### Access management
- Controls who can access their organization
- Defines user roles and permissions
- Manages security policies
</Card>

<Card>
##### User management
- Adds and removes users
- Updates user information
- Manages authentication methods
</Card>

<Card>
##### Data segregation
- Keeps data isolated
- Maintains security boundaries
- Ensures data privacy and governance
</Card>

</CardGrid>

#### Organization meta label

You can customize this meta label to _team_, _workspace_, or _account_ to match your product's terminology. Navigate to Scalekit Dashboard > User management > Settings and update the "Organization" meta name.


### Extending Organizations

Organizations support custom metadata and external IDs to integrate seamlessly with your existing systems.

#### Custom metadata

Use custom metadata to store additional information like subscription plans, internal customer IDs, or feature flags. This helps you manage organization-specific configurations within Scalekit and can be included in JWT claims for use in your application.

<Tabs>
<TabItem label='Metadata'>
```sh title="Create a new organization with metadata" showLineNumbers=false
curl https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations \
  --request POST \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "metadata": {
    "invoice_email": "invoices@megasoft.com",
    "plan_type": "enterprise"
  }
}'
```
</TabItem>
</Tabs>

#### External IDs
Use external IDs to link Scalekit Organizations with your existing systems, such as a customer ID from your billing platform. This maintains consistent identification across your infrastructure.

<Tabs>
<TabItem label='External IDs'>
```sh title="Create a new organization with an external ID" showLineNumbers=false
curl https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations \
  --request POST \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "external_id": "CUST-12345-MGSFT",
  "metadata": {}
}'
```
</TabItem>
</Tabs>

## Map users to Scalekit identities

In Scalekit, a **User** is a unified profile that can belong to multiple Organizations. While the core user profile is shared, each Organization membership maintains distinct details like roles, status, and metadata. This allows a user to have different roles and permissions in each Organization they are a part of, while maintaining a single identity.

Your approach to mapping users will depend on your current data model.

### Organization memberships

Scalekit tracks how users belong to organizations through a `memberships` property on each User object. This property contains an array of membership objects that define the user's relationship to each organization they belong to.

Each membership object includes these key properties:

- `organization_id`: Identifies which organization the user belongs to
- `roles`: Specifies the user's roles (assigned by your application) within that organization
- `status`: Indicates whether the membership is active, pending invite or invite expired

The memberships property enables users to belong to multiple organizations while maintaining clear role and status information for each relationship.

<details>
<summary>View membership object structure</summary>
```json title="Memberships example" "metadata" "roles" "organization_id"
{
    "memberships": [
      {
        "join_time": "2025-06-27T10:57:43.720Z",
        "membership_status": "ACTIVE",
        "metadata": {
          "department": "engineering",
          "location": "nyc-office"
        },
        "name": "string",
        "organization_id": "org_1234abcd5678efgh",
        "primary_identity_provider": "OKTA",
        "roles": [
          {
            "id": "role_admin",
            "name": "Admin"
          }
        ]
      },
      {
        "join_time": "2025-07-15T14:30:22.451Z",
        "membership_status": "ACTIVE",
        "metadata": {
          "department": "product",
          "location": "sf-office"
        },
        "name": "Jane Smith",
        "organization_id": "org_9876zyxw5432vuts",
        "primary_identity_provider": "GOOGLE",
        "roles": [
          {
            "id": "role_prod_manager",
            "name": "Product Manager"
          }
        ]
      }
    ],
}
```
</details>

### Migrating from a 1-to-1 model

In a 1-to-1 data model, each user is associated with a single organization. The user's identity is tied to that specific organization, and they cannot belong to multiple organizations with the same identity. This model is common in applications that were not originally built with multi-tenancy in mind, or where each customer's data and user base are kept entirely separate.

For example, many traditional enterprise software applications like **Slack**, **QuickBooks**, or **Adobe Creative Suite** use this model - each customer purchases their own license and has their own separate user accounts that cannot be shared across different customer organizations.

<Aside type="note" title="Need help with migration?">
If your application uses a 1-to-1 model and you're looking to migrate, please [contact us](/support/contact-us) for guidance on the best approach for your use case.
</Aside>

### Migrating from a 1-to-many model

If your application allows a single user to be part of multiple organizations, their profile in Scalekit will also be shared across those organizations. While the user's core profile is consistent, each organization membership stores distinct information like roles, status, and metadata.

If you already have a membership table that links users and organizations, you can add the Scalekit `user_id` to that table. When you update a user's profile, the changes will apply across all their organization memberships.

## User deduplication

Scalekit uses the email address as the unique identifier for a User within an Environment. This means:
- Two different Users cannot have the same email address within the same Environment.
- Scalekit automatically consolidates accounts. If a user logs in with an email and password and later uses Google OAuth with the same email, both authentication methods will be linked to the same User record.

Because of this, you may need to merge duplicate user accounts in your system before migrating to Scalekit. Attempting to create two Users with the same email in the same organization or environment will result in an error.

## Linking Scalekit IDs

You should continue to maintain your own user and group tables and link them to Scalekit by storing the `organization_id` and `user_id` in your database. You can also store your internal identifiers as `external_id` or additional `metadata` fields on the corresponding user objects for a two-way reference.

<CardGrid>

<LinkCard title="Refer to User API" href="https://docs.scalekit.com/apis#tag/users/POST/api/v1/memberships/organizations/{organization_id}/users/{id}" description='Add an existing user to an organization and assign them specific roles and permissions.' />

<LinkCard title="Work with user profiles" href="/fsa/reference/user-profile/" description='Learn about user profile attributes and how to manage user information in Scalekit.' />

</CardGrid>

================
File: fsa/quickstart.mdx
================
---
title: Quickstart
description: "Get started with Scalekit's Full Stack Authentication in under 10 minutes. Build a complete authentication flow with hosted login, session management, and more."
sidebar:
  label: "Quickstart"
tableOfContents: true
next:
  label: "Manage users"
  link: "/fsa/data-modelling/"
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
---

import { Card, CardGrid, Steps, TabItem, Tabs, Aside } from '@astrojs/starlight/components';
import CheckItem from '@/components/ui/CheckItem.astro';
import InstallSDK from '@components/templates/_installsdk.mdx'

Get up and running with Scalekit's Full Stack Authentication in under 10 minutes. You'll build a complete authentication flow with hosted login and sign up pages, user session management, and secure logout - all optimized for B2B SaaS applications.

## What you'll build

By the end of this guide, your application will have:

- **Hosted authentication pages** - Let Scalekit handle sign-in/sign-up UI
- **Multi-tenant user management** - Automatic workspace creation and manage users within workspaces
- **Session management** - Secure token handling with automatic refresh
- **Multiple auth methods** - Passwordless, social logins, and enterprise SSO
- **Secure logout** - Complete session invalidation

## How it works

Scalekit handles the complex authentication flow while you focus on your core product:

![Full-Stack Authentication Flow](@/assets/docs/fsa/overview/new-1.png)

1. **User initiates sign-in** - Your app redirects to Scalekit's hosted auth page
2. **Identity verification** - User authenticates via their preferred method
3. **Secure callback** - Scalekit returns user profile and session tokens
4. **Session creation** - Your app establishes a secure user session
5. **Protected access** - User can access your application's features

## Before you begin

- <a href="https://app.scalekit.com/ws/signup" target="_blank">Signup for a Scalekit account</a>
- Copy your API credentials from the Scalekit dashboard's API Config section
- Register your redirect URLs in the Scalekit Dashboard under Redirects section

<Aside type="tip">
  Redirect URL in code must exactly match what you configured in the Scalekit dashboard. Mismatched URLs are the most common integration issue.
</Aside>

Let's get started!

<Steps>
 1. ## Install the Scalekit SDK

    <InstallSDK />

    Copy your API credentials from the Scalekit dashboard's API Config section and set them as environment variables.
    ```bash
    SCALEKIT_ENVIRONMENT_URL='<YOUR_ENVIRONMENT_URL>'
    SCALEKIT_CLIENT_ID='<ENVIRONMENT_CLIENT_ID>'
    SCALEKIT_CLIENT_SECRET='<ENVIRONMENT_CLIENT_SECRET>'
    ```

    Create a new Scalekit client instance after initializing the environment variables.
    <Tabs syncKey="tech-stack">
      <TabItem value="nodejs" label="Node.js">
      ```javascript title="utils/auth.js"
      import { Scalekit } from '@scalekit-sdk/node';

      export let scalekit = new Scalekit(
        process.env.SCALEKIT_ENVIRONMENT_URL,
        process.env.SCALEKIT_CLIENT_ID,
        process.env.SCALEKIT_CLIENT_SECRET
      );
      ```
      </TabItem>
      <TabItem value="python" label="Python">
      ```python title="utils/auth.py"
      from scalekit import ScalekitClient
      import os

      scalekit = ScalekitClient(
          os.environ.get('SCALEKIT_ENVIRONMENT_URL'),
          os.environ.get('SCALEKIT_CLIENT_ID'),
          os.environ.get('SCALEKIT_CLIENT_SECRET')
      )
      ```
      </TabItem>
      <TabItem value="go" label="Go">
      ```go title="utils/auth.go"
      package main

      import (
          "os"
          "github.com/scalekit-inc/scalekit-sdk-go"
      )

      scalekit := scalekit.NewScalekitClient(
          os.Getenv("SCALEKIT_ENVIRONMENT_URL"),
          os.Getenv("SCALEKIT_CLIENT_ID"),
          os.Getenv("SCALEKIT_CLIENT_SECRET"),
      )
      ```
      </TabItem>
      <TabItem value="java" label="Java">
      ```java title="utils/Auth.java"
      import com.scalekit.ScalekitClient;

      public class Auth {
          public ScalekitClient createScalekitClient() {
              return new ScalekitClient(
                  System.getenv("SCALEKIT_ENVIRONMENT_URL"),
                  System.getenv("SCALEKIT_CLIENT_ID"),
                  System.getenv("SCALEKIT_CLIENT_SECRET")
              );
          }
      }
      ```
      </TabItem>
    </Tabs>
2. ## Redirect users to hosted login page
       Generate the authorization URL by passing a [registered callback URL](/fsa/reference/redirects) and scopes to the Scalekit SDK.
        <Tabs syncKey="tech-stack">
        <TabItem value="curl" label="cURL">
            ```sh wrap
            curl -G -v --location "<SCALEKIT_ENVIRONMENT_URL>/oauth/authorize" \
            --data-urlencode 'grant_type=authorization_code' \
            --data-urlencode "organization_id={organization_id}" \
            --data-urlencode "response_type=code" \
            --data-urlencode "scope=openid profile" \
            --data-urlencode 'redirect_uri=https://your-app.com/callback' \
            --data-urlencode "client_id={client_id}" \
            --data-urlencode "state=random_state_value"
            ```
        </TabItem>
        <TabItem value="node" label="Node.js">
        ```javascript title="Express.js"
        const redirectUri = '<http://localhost:3000/api/callback>';
        const options = {
          scopes: ['openid', 'profile', 'email', 'offline_access']
        };

        const authorizationUrl = scalekit.getAuthorizationUrl(redirectUri, options);

        res.redirect(authorizationUrl);
        ```
        </TabItem>
        <TabItem value="python" label="Python">
        ```python title="Flask"
        from scalekit import AuthorizationUrlOptions

        redirect_uri = 'http://localhost:3000/api/callback'
        options = AuthorizationUrlOptions(
            scopes=['openid', 'profile', 'email', 'offline_access']
        )

        authorization_url = scalekit.get_authorization_url(redirect_uri, options)

        # For web frameworks like Flask/Django:
        # return redirect(authorization_url)
        ```
        </TabItem>
        <TabItem value="go" label="Go">
        ```go title="Gin"
        redirectUri := "http://localhost:3000/api/callback"
        options := scalekit.AuthorizationUrlOptions{
            Scopes: []string{"openid", "profile", "email", "offline_access"}
        }

        authorizationUrl, err := scalekit.GetAuthorizationUrl(redirectUri, options)
        if err != nil {
            // handle error appropriately
            panic(err)
        }

        // For web frameworks like Gin:
        // c.Redirect(http.StatusFound, authorizationUrl.String())
        ```
        </TabItem>
        <TabItem value="java" label="Java">
        ```java title="Spring"
        import com.scalekit.internal.http.AuthorizationUrlOptions;
        import java.net.URL;
        import java.util.Arrays;

        String redirectUri = "http://localhost:3000/api/callback";
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        options.setScopes(Arrays.asList("openid", "profile", "email", "offline_access"));

        URL authorizationUrl = scalekit.authentication().getAuthorizationUrl(redirectUri, options);
        ```
        </TabItem>
        </Tabs>

     This will redirect the user to Scalekit's managed sign-in page.

3. ## Handle Authentication Callback

      After users authenticate, Scalekit redirects them back to your registered callback URL with an authorization code. Exchange this code to get the user's profile and session tokens:
      <Tabs syncKey="tech-stack">
        <TabItem value="curl" label="cURL">
        ```sh wrap
        curl -v --location "<SCALEKIT_ENVIRONMENT_URL>/oauth/token" \
        --header 'Content-Type: application/x-www-form-urlencoded' \
        --data-urlencode 'grant_type=authorization_code' \
        --data-urlencode "code={authorization_code}" \
        --data-urlencode 'redirect_uri=https://your-app.com/callback' \
        --data-urlencode "client_id={client_id}" \
        --data-urlencode "client_secret={client_secret}"
        ```
        </TabItem>
        <TabItem value="node" label="Node.js">
        ```javascript collapse={22-26}
        import scalekit from '@/utils/auth.js'
        const redirectUri = '<http://localhost:3000/api/callback>';

        // Get the authorization code from the scalekit initiated callback
        app.get('/api/callback', async (req, res) => {
          const { code, error, error_description } = req.query;

          if (error) {
            return res.status(401).json({ error, error_description });
          }

          try {
            // Exchange the authorization code for a user profile
            const authResult = await scalekit.authenticateWithCode(
              code, redirectUri
            );

            const { user } = authResult;

            // "user" object contains the user's profile information
            // Next step: Create a session and log in the user
            res.redirect('/dashboard/profile');
          } catch (err) {
            console.error('Error exchanging code:', err);
            res.status(500).json({ error: 'Failed to authenticate user' });
          }
        });
        ```
        </TabItem>
        <TabItem value="python" label="Python">
        ```python collapse={1-6, 29-32}
        from flask import Flask, request, redirect, jsonify
        from scalekit import ScalekitClient, CodeAuthenticationOptions

        app = Flask(__name__)
        # scalekit imported from your auth utils

        redirect_uri = 'http://localhost:3000/api/callback'

        @app.route('/api/callback')
        def callback():
            code = request.args.get('code')
            error = request.args.get('error')
            error_description = request.args.get('error_description')

            if error:
                return jsonify({'error': error, 'error_description': error_description}), 401

            try:
                # Exchange the authorization code for a user profile
                options = CodeAuthenticationOptions()
                auth_result = scalekit.authenticate_with_code(
                    code, redirect_uri, options
                )

                user = auth_result.user

                # "user" object contains the user's profile information
                # Next step: Create a session and log in the user
                return redirect('/dashboard/profile')
            except Exception as err:
                print(f'Error exchanging code: {err}')
                return jsonify({'error': 'Failed to authenticate user'}), 500
        ```
        </TabItem>
        <TabItem value="go" label="Go">
        ```go collapse={1-9}
        package main

        import (
            "log"
            "net/http"
            "os"
            "github.com/gin-gonic/gin"
            "github.com/scalekit-inc/scalekit-sdk-go"
        )

        // Create Scalekit client instance
        var scalekitClient = scalekit.NewScalekitClient(
            os.Getenv("SCALEKIT_ENVIRONMENT_URL"),
            os.Getenv("SCALEKIT_CLIENT_ID"),
            os.Getenv("SCALEKIT_CLIENT_SECRET"),
        )

        const redirectUri = "http://localhost:3000/api/callback"

        func callbackHandler(c *gin.Context) {
            code := c.Query("code")
            errorParam := c.Query("error")
            errorDescription := c.Query("error_description")

            if errorParam != "" {
                c.JSON(http.StatusUnauthorized, gin.H{
                    "error": errorParam,
                    "error_description": errorDescription,
                })
                return
            }

            // Exchange the authorization code for a user profile
            options := scalekit.AuthenticationOptions{}
            authResult, err := scalekitClient.AuthenticateWithCode(
                code, redirectUri, options,
            )

            if err != nil {
                log.Printf("Error exchanging code: %v", err)
                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "Failed to authenticate user",
                })
                return
            }

            user := authResult.User

            // "user" object contains the user's profile information
            // Next step: Create a session and log in the user
            c.Redirect(http.StatusFound, "/dashboard/profile")
        }
        ```
        </TabItem>
        <TabItem value="java" label="Java">
        ```java collapse={1-10, 40-47} wrap
        import com.scalekit.ScalekitClient;
        import com.scalekit.internal.http.AuthenticationOptions;
        import com.scalekit.internal.http.AuthenticationResponse;
        import org.springframework.web.bind.annotation.*;
        import org.springframework.web.servlet.view.RedirectView;
        import org.springframework.http.ResponseEntity;
        import org.springframework.http.HttpStatus;
        import java.util.HashMap;
        import java.util.Map;

        @RestController
        public class CallbackController {

            private final String redirectUri = "http://localhost:3000/api/callback";

            @GetMapping("/api/callback")
            public Object callback(
                @RequestParam(required = false) String code,
                @RequestParam(required = false) String error,
                @RequestParam(name = "error_description", required = false) String errorDescription
            ) {
                if (error != null) {
                   // handle error
                }

                try {
                    // Exchange the authorization code for a user profile
                    AuthenticationOptions options = new AuthenticationOptions();
                    AuthenticationResponse authResult = scalekit
                        .authentication()
                        .authenticateWithCode(code,redirectUri,options);

                    var user = authResult.getIdTokenClaims();

                    // "user" object contains the user's profile information
                    // Next step: Create a session and log in the user
                    return new RedirectView("/dashboard/profile");

                } catch (Exception err) {
                    // Handle exception (e.g., log error, return error response)
                }
            }
        }
        ```
        </TabItem>
      </Tabs>

      The `authenticateWithCode` method returns an object containing the user's profile information (`user` object) and session tokens including `idToken`, `accessToken` and `refreshToken`.

      <Tabs syncKey="auth-result">
        <TabItem value="curl" label="cURL">
        ```sh title="cURL response"
        {
        "access_token": "eyJhImtpZCI6InNu2NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "Bearer",
        "expires_in": 86399,
        "scope": "openid profile",
        "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6InNuIsInR5cCI6IkpXVCJ9..."
        }
        ```
        </TabItem>
        <TabItem value="authResult" label="authResult">
        ```js
        {
          user: {
            email: "john.doe@example.com",
            emailVerified: true,
            givenName: "John",
            name: "John Doe",
            id: "usr_74599896446906854"
          },
          idToken: "eyJhbGciO..",
          accessToken: "eyJhbGciOi..",
          refreshToken: "rt_8f7d6e5c4b3a2d1e0f9g8h7i6j..",
          expiresIn: 299
        }
        ```
        </TabItem>
        <TabItem value="idToken" label="ID token (decoded)">
        ```json
        {
          "at_hash": "ec_jU2ZKpFelCKLTRWiRsg",
          "aud": [
            "skc_58327482062864390"
          ],
          "azp": "skc_58327482062864390",
          "c_hash": "6wMreK9kWQQY6O5R0CiiYg",
          "client_id": "skc_58327482062864390",
          "email": "john.doe@example.com",
          "email_verified": true,
          "exp": 1742975822,
          "family_name": "Doe",
          "given_name": "John",
          "iat": 1742974022,
          "iss": "https://scalekit-z44iroqaaada-dev.scalekit.cloud",
          "name": "John Doe",
          "oid": "org_59615193906282635",
          "sid": "ses_65274187031249433",
          "sub": "usr_63261014140912135"
        }
        ```
        </TabItem>
      </Tabs>

      You can [decode the `idToken`](https://authplay.io/pg/token-explorer) to access user information like email, name, and profile verification status directly from the token claims.

4. ## Create and manage user sessions

      Now that you've the entire user's profile details including their email address, verification status, create a secure session by storing the session tokens. Use encrypted HTTP-only cookies for the access token and securely store the refresh token:
      <Tabs syncKey="tech-stack">
        <TabItem value="node" label="Node.js">
        ```javascript ins={1,3}
        import cookieParser from 'cookie-parser';
        // Set cookie parser middleware
        app.use(cookieParser());

        // encrypt the accessToken using a secure encryption algorithm
        const encryptedAccessToken = encrypt(authResult.accessToken);

        // setting up accessToken as HTTP-only cookie
        res.cookie('accessToken', encryptedAccessToken, {
          maxAge: (authResult.expiresIn - 60) * 1000,
          httpOnly: true,
          secure: true,
          path: '/',
          sameSite: 'strict'
        });

        // Store the refreshToken in a secure place
        ```
        </TabItem>

        <TabItem value="python" label="Python">
        ```python
        from flask import Flask, make_response
        from cryptography.fernet import Fernet
        import os

        # Cookie parsing is built-in with Flask's request object
        app = Flask(__name__)

        # encrypt the accessToken using a secure encryption algorithm
        key = os.environ.get('ENCRYPTION_KEY')  # Store securely
        cipher_suite = Fernet(key)
        encrypted_access_token = cipher_suite.encrypt(authResult['accessToken'].encode()).decode()

        // setting up accessToken as HTTP-only cookie
        response = make_response()
        response.set_cookie(
            'accessToken',
            encrypted_access_token,
            max_age=(authResult['expiresIn'] - 60) * 1000,
            httponly=True,
            secure=True,
            path='/',
            samesite='Strict'
        )

        // Store the refreshToken in a secure place
        ```
        </TabItem>

        <TabItem value="go" label="Go">
        ```go
        import (
            "crypto/aes"
            "crypto/cipher"
            "net/http"
            "os"
        )

        // encrypt the accessToken using a secure encryption algorithm
        key := []byte(os.Getenv("ENCRYPTION_KEY"))
        block, _ := aes.NewCipher(key)
        gcm, _ := cipher.NewGCM(block)
        encryptedAccessToken, _ := encrypt(authResult.AccessToken)

        // setting up accessToken as HTTP-only cookie
        cookie := &http.Cookie{
            Name:     "accessToken",
            Value:    encryptedAccessToken,
            MaxAge:   (authResult.ExpiresIn - 60) * 1000,
            HttpOnly: true,
            Secure:   true,
            Path:     "/",
            SameSite: http.SameSiteStrictMode,
        }
        http.SetCookie(w, cookie)

        // Store the refreshToken in a secure place
        ```
        </TabItem>

        <TabItem value="java" label="Java">
        ```java
        import javax.crypto.Cipher;
        import javax.crypto.SecretKey;
        import javax.servlet.http.Cookie;
        import javax.servlet.http.HttpServletResponse;
        import java.util.Base64;




        // setting up accessToken as HTTP-only cookie
        String encryptedRefreshToken = encrypt(authResult.getAccessToken());
        Cookie accessTokenCookie = new Cookie("accessToken", encryptedAccessToken);
        accessTokenCookie.setMaxAge((authResult.getExpiresIn() - 60) * 1000);
        accessTokenCookie.setHttpOnly(true);
        accessTokenCookie.setSecure(true);
        accessTokenCookie.setPath("/");
        response.addCookie(accessTokenCookie);

        // setting up refreshToken as HTTP-only cookie
        String encryptedRefreshToken = encrypt(authResult.getRefreshToken());
        Cookie refreshTokenCookie = new Cookie("refreshToken", encryptedRefreshToken);
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setSecure(true);
        refreshTokenCookie.setPath("/");
        response.addCookie(refreshTokenCookie);

        // Store the refreshToken in a secure place
        ```
        </TabItem>
      </Tabs>

      This sets browser cookies with the session tokens. Every request to your backend needs to verify the `accessToken` to ensure the user is authenticated. If expired, use the `refreshToken` to get a new access token.

      <Tabs syncKey="tech-stack">
        <TabItem value="node" label="Node.js">
        ```javascript wrap ins={15,24}
        // Middleware to verify and refresh tokens if needed
        const verifyToken = async (req, res, next) => {
          try {
            // Get access token from cookie
            const accessToken = req.cookies.accessToken;

            // Decrypt the accessToken using the same encryption algorithm
            const decryptedAccessToken = decrypt(accessToken);

            if (!accessToken) {
              return res.status(401).json({ message: 'No access token provided' });
            }

            // Use Scalekit SDK to validate the token
            const isValid = await scalekit.validateAccessToken(decryptedAccessToken);

            if (!isValid) {
              // Use stored refreshToken to get a new access token
               const {
                    user,
                    idToken,
                    accessToken,
                    refreshToken: newRefreshToken,
              } = await scalekit.refreshAccessToken(refreshToken);

              // Store the new refresh token
              // Update the cookie with the new access token
            }
            next();
        };

        // Example of using the middleware to protect routes
        app.get('/dashboard', verifyToken, (req, res) => {
          // The user object is now available in req.user
          res.json({
            message: 'This is a protected route',
            user: req.user
          });
        });
        ```
        </TabItem>
        <TabItem value="python" label="Python">
        ```python wrap
        from functools import wraps
        from flask import request, jsonify, make_response

        def verify_token(f):
            """Decorator to verify and refresh tokens if needed"""
            @wraps(f)
            def decorated_function(*args, **kwargs):
                try:
                    # Get access token from cookie
                    access_token = request.cookies.get('accessToken')

                    if not access_token:
                        return jsonify({'message': 'No access token provided'}), 401

                    # Decrypt the accessToken using the same encryption algorithm
                    decrypted_access_token = decrypt(access_token)

                    # Use Scalekit SDK to validate the token
                    is_valid = scalekit.validate_access_token(decrypted_access_token)

                    if not is_valid:
                        # Get stored refresh token
                        refresh_token = get_stored_refresh_token()

                        if not refresh_token:
                            return jsonify({'message': 'No refresh token available'}), 401

                        # Use stored refreshToken to get a new access token
                        token_response = scalekit.refresh_access_token(refresh_token)

                        # Python SDK returns dict with access_token and refresh_token
                        new_access_token = token_response.get('access_token')
                        new_refresh_token = token_response.get('refresh_token')

                        # Store the new refresh token
                        store_refresh_token(new_refresh_token)

                        # Update the cookie with the new access token
                        encrypted_new_access_token = encrypt(new_access_token)
                        response = make_response(f(*args, **kwargs))
                        response.set_cookie(
                            'accessToken',
                            encrypted_new_access_token,
                            httponly=True,
                            secure=True,
                            path='/',
                            samesite='Strict'
                        )

                        return response

                    # If the token was valid we just invoke the view as-is
                    return f(*args, **kwargs)

                except Exception as e:
                    return jsonify({'message': f'Token verification failed: {str(e)}'}), 401

            return decorated_function

        # Example of using the decorator to protect routes
        @app.route('/dashboard')
        @verify_token
        def dashboard():
            return jsonify({
                'message': 'This is a protected route',
                'user': getattr(request, 'user', None)
            })
        ```
        </TabItem>
        <TabItem value="go" label="Go">
        ```go wrap
        import (
            "context"
            "net/http"
        )

        func verifyToken(next http.HandlerFunc) http.HandlerFunc {
            return func(w http.ResponseWriter, r *http.Request) {
                // Get access token from cookie
                cookie, err := r.Cookie("accessToken")
                if err != nil {
                    http.Error(w, `{"message": "No access token provided"}`, http.StatusUnauthorized)
                    return
                }

                accessToken := cookie.Value

                // Decrypt the accessToken
                decryptedAccessToken, err := decrypt(accessToken)
                if err != nil {
                    http.Error(w, `{"message": "Token decryption failed"}`, http.StatusUnauthorized)
                    return
                }

                // Use Scalekit SDK to validate the token
                isValid, err := scalekit.ValidateAccessToken(decryptedAccessToken)
                if err != nil || !isValid {
                    // Get stored refresh token
                    refreshToken, err := getStoredRefreshToken(r)
                    if err != nil {
                        http.Error(w, `{"message": "No refresh token available"}`, http.StatusUnauthorized)
                        return
                    }

                    // Use stored refreshToken to get a new access token
                    tokenResponse, err := scalekit.RefreshAccessToken(refreshToken)
                    if err != nil {
                        http.Error(w, `{"message": "Token refresh failed"}`, http.StatusUnauthorized)
                        return
                    }

                    // Go SDK returns TokenResponse with AccessToken, RefreshToken, ExpiresIn
                    // Store the new refresh token
                    err = storeRefreshToken(tokenResponse.RefreshToken)
                    if err != nil {
                        http.Error(w, `{"message": "Failed to store refresh token"}`, http.StatusInternalServerError)
                        return
                    }

                    // Update the cookie with the new access token
                    encryptedNewAccessToken, err := encrypt(tokenResponse.AccessToken)
                    if err != nil {
                        http.Error(w, `{"message": "Token encryption failed"}`, http.StatusInternalServerError)
                        return
                    }

                    newCookie := &http.Cookie{
                        Name:     "accessToken",
                        Value:    encryptedNewAccessToken,
                        HttpOnly: true,
                        Secure:   true,
                        Path:     "/",
                        SameSite: http.SameSiteStrictMode,
                    }
                    http.SetCookie(w, newCookie)

                    r = r.WithContext(context.WithValue(r.Context(), "tokenValid", true))
                } else {
                    r = r.WithContext(context.WithValue(r.Context(), "tokenValid", true))
                }

                next(w, r)
            }
        }

        // Example of using the middleware to protect routes
        func dashboardHandler(w http.ResponseWriter, r *http.Request) {
            w.Header().Set("Content-Type", "application/json")
            w.Write([]byte(`{
                "message": "This is a protected route",
                "tokenValid": true
            }`))
        }

        // Usage: http.HandleFunc("/dashboard", verifyToken(dashboardHandler))
        ```
        </TabItem>
        <TabItem value="java" label="Java">
        ```java wrap
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import javax.servlet.http.Cookie;
        import org.springframework.web.servlet.HandlerInterceptor;

        @Component
        public class TokenVerificationInterceptor implements HandlerInterceptor {
            @Override
            public boolean preHandle(
                HttpServletRequest request,
                HttpServletResponse response,
                Object handler
            ) throws Exception {
                try {
                    // Get access token from cookie
                    String accessToken = getCookieValue(request, "accessToken");
                    String refreshToken = getCookieValue(request, "refreshToken");

                    // Decrypt the tokens
                    String decryptedAccessToken = decrypt(accessToken);
                    String decryptedRefreshToken = decrypt(refreshToken);

                    // Use Scalekit SDK to validate the token
                    boolean isValid = scalekit.authentication().validateAccessToken(decryptedAccessToken);


                    // Use refreshToken to get a new access token
                    AuthenticationResponse tokenResponse = scalekit
                            .authentication()
                            .refreshToken(decryptedRefreshToken);



                    // Update the cookie with the new access token and refresh token
                    String encryptedNewAccessToken = encrypt(tokenResponse.getAccessToken());
                    String encryptedNewRefreshToken = encrypt(tokenResponse.getRefreshToken());

                    Cookie accessTokenCookie = new Cookie("accessToken", encryptedNewAccessToken);
                    accessTokenCookie.setHttpOnly(true);
                    accessTokenCookie.setSecure(true);
                    accessTokenCookie.setPath("/");
                    response.addCookie(accessTokenCookie);

                    Cookie refreshTokenCookie = new Cookie("refreshToken", encryptedNewRefreshToken);
                    refreshTokenCookie.setHttpOnly(true);
                    refreshTokenCookie.setSecure(true);
                    refreshTokenCookie.setPath("/");
                    response.addCookie(refreshTokenCookie);

                    return true;
                } catch (Exception e) {
                   // handle exception
                }
            }

            private String getCookieValue(HttpServletRequest request, String cookieName) {
                Cookie[] cookies = request.getCookies();
                if (cookies != null) {
                    for (Cookie cookie : cookies) {
                        if (cookieName.equals(cookie.getName())) {
                            return cookie.getValue();
                        }
                    }
                }
                return null;
            }
        }
        ```
        </TabItem>
      </Tabs>

      Successfully authenticated users can now access your dashboard.

5. ## Log out the user

      To properly log out users, clear local session data and invalidate their session on Scalekit's servers:

      <Tabs syncKey="tech-stack">
        <TabItem value="node" label="Node.js">
          ```javascript
          /**
           * Handles user logout by:
           * 1. Clearing local session data
           * 2. Invalidating the Scalekit session
           * 3. Redirecting to post-logout URL
           */
          app.get('/logout', (req, res) => {
            // Clear all session data including cookies and local storage
            clearSessionData();

            /**
             * Generates a Scalekit logout URL that will:
             * - Invalidate the user's session on Scalekit's servers
             * - Redirect the user to the specified post-logout URL
             * @param {string} idToken - The user's ID token to invalidate
             * @param {string} postLogoutRedirectUri - URL to redirect after logout
             * @returns {string} The complete logout URL
             */
            const logoutUrl = scalekit.getLogoutUrl(
              idToken,
              postLogoutRedirectUri
            );

            // Redirect to Scalekit's logout endpoint
            // Note: This is a one-time use URL that becomes invalid after use
            res.redirect(logoutUrl);
          });
          ```
        </TabItem>
        <TabItem value="python" label="Python">
          ```python
          from flask import Flask, redirect
          from scalekit import LogoutUrlOptions

          app = Flask(__name__)

          @app.route('/logout')
          def logout():
              # Clear all session data including cookies and local storage
              clear_session_data()

              # Generate Scalekit logout URL
              options = LogoutUrlOptions(
                  id_token_hint=id_token,
                  post_logout_redirect_uri=post_logout_redirect_uri
              )
              logout_url = scalekit.get_logout_url(options)

              # Redirect to Scalekit's logout endpoint
              # Note: This is a one-time use URL that becomes invalid after use
              return redirect(logout_url)
          ```
        </TabItem>
        <TabItem value="go" label="Go">
          ```go
          package main

          import (
              "net/http"
              "github.com/gin-gonic/gin"
              "github.com/scalekit-inc/scalekit-sdk-go"
          )

          func logoutHandler(c *gin.Context) {
              // Clear all session data including cookies and local storage
              clearSessionData()

              // Generate Scalekit logout URL
              options := scalekit.LogoutUrlOptions{
                  IdTokenHint:           idToken,
                  PostLogoutRedirectUri: postLogoutRedirectUri,
              }
              logoutUrl, err := scalekit.GetLogoutUrl(options)
              if err != nil {
                  c.JSON(http.StatusInternalServerError, gin.H{
                      "error": "Failed to generate logout URL",
                  })
                  return
              }

              // Redirect to Scalekit's logout endpoint
              // Note: This is a one-time use URL that becomes invalid after use
              c.Redirect(http.StatusFound, logoutUrl.String())
          }
          ```
        </TabItem>
        <TabItem value="java" label="Java">
          ```java
          import com.scalekit.internal.http.LogoutUrlOptions;
          import org.springframework.web.bind.annotation.*;
          import org.springframework.web.servlet.view.RedirectView;
          import java.net.URL;

          @RestController
          public class LogoutController {

              @GetMapping("/logout")
              public RedirectView logout() {
                  // Clear all session data including cookies and local storage
                  clearSessionData();

                  // Generate Scalekit logout URL
                  LogoutUrlOptions options = new LogoutUrlOptions();
                  options.setIdTokenHint(idToken);
                  options.setPostLogoutRedirectUri(postLogoutRedirectUri);

                  URL logoutUrl = scalekit.authentication()
                      .getLogoutUrl(options);

                  // Redirect to Scalekit's logout endpoint
                  // Note: This is a one-time use URL that becomes invalid after use
                  return new RedirectView(logoutUrl.toString());
              }
          }
          ```
        </TabItem>
      </Tabs>
      The logout process completes when Scalekit invalidates the user's session and redirects them to your [specified post-logout URL](/fsa/reference/redirects).

</Steps>
## What you've accomplished

🎉 **Congratulations!** You've successfully integrated Scalekit's Full Stack Authentication. Your application now has:

- **Complete authentication flow** - Sign-in, sign-up, and logout
- **Secure session management** - Encrypted tokens with automatic refresh
- **Multi-tenant architecture** - Ready for B2B SaaS scaling
- **Enterprise-ready foundation** - Built to handle SSO and advanced auth methods

## What's next?

You've completed the Scalekit quickstart and enabled secure authentication for your users and sign-in flow.

- [Design your data model](/fsa/data-modelling/) to learn how to model your data to best work with Scalekit.
- [Manage users](/fsa/reference/user-profile/) to create, update, and delete user accounts.
- [Customize the login page](/fsa/guides/login-page-branding/) to match your brand's design and style.

================
File: guides/integrations/auth-systems/auth0.mdx
================
---
title: Auth0
description: "Learn how to integrate Scalekit with Auth0 for seamless Single Sign-On (SSO) authentication, allowing enterprise users to log in via Scalekit."
tableOfContents:
  minHeadingLevel: 3
sidebar:
  label: "Auth0"
---
import { Aside, Steps } from '@astrojs/starlight/components'

This guide is designed to provide you a walkthrough of integrating Scalekit with Auth0, thereby facilitating seamless Single Sign-on (SSO) authentication for your application's users. We demonstrate how to configure Scalekit so that Auth0 can allow some of your enterprise users to login via Scalekit and still continue to act as the identity management solution for your users and manage the login, session management functionality.

![Scalekit - Auth0 Integration ](@/assets/docs/guides/auth-systems/auth0/0.png)

Scalekit is designed as a fully compatible OpenID Connect (OIDC) provider, thus streamlining the integration. As Auth0 continues to act as your identity management system, you'll be able to seamlessly integrate Single Sign-on into your application without having to write code.

<Aside>

Auth0 classifies OpenID Connect as Enterprise Connection and this feature is available only in the paid plans of Auth0. Please check whether your current plan has access to creating Enterprise Connections with OpenID Connect providers.

</Aside>

Ensure you have:

- Access to Auth0's Authenticate dashboard. You need to have a role as an 'Admin' or 'Editor - Connections' to create and edit OIDC connections on Auth0
- Access to your Scalekit dashboard

## Add Scalekit as OIDC connection

Use <a href="https://auth0.com/docs/api/management/v2/connections/post-connections" target="_blank">Auth0 Connections API</a> to create Scalekit as a OpenID connection for your tenant. Sample curl command below:

```bash showLineNumbers=false wrap
curl --request POST \
  --url 'https://<AUTH0_TENANT_DOMAIN>.us.auth0.com/api/v2/connections' \
  -H 'Content-Type: application/json' \
  -H 'Accept: application/json' \
  --header 'authorization: Bearer <API_TOKEN>' \
  --data-raw '{ "strategy": "oidc", "name": "Scalekit", "options": { "type": "back_channel", "discovery_url": "<SCALEKIT_ENVIRONMENT_URL>/.well-known/openid-configuration", "client_secret" : "<SCALEKIT_CLIENT_SECRET>", "client_id" : "<SCALEKIT_CLIENT_ID>",  "scopes": "openid profile" } }'
```

<Aside type="caution">

Because of an <a href="https://community.auth0.com/t/creating-an-oidc-connection-fails-with-options-issuer-is-required-error/128189" target="_blank">existing issue</a> in adding OIDC connections via Auth0 Management Console, you need to use Auth0 API to create OIDC connection.

</Aside>

| Parameter              | Description                                                                                                                                                                         |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| AUTH0_TENANT_DOMAIN    | This is your Auth0 tenant url. Typically, looks like https:<span></span>//yourapp.us.auth0.com                                                                                         |
| API_TOKEN              | <a href="https://auth0.com/docs/secure/tokens/access-tokens/management-api-access-tokens" target="_blank">Generate an API token</a> from your Auth0 dashboard and use it to authenticate your Auth0 API calls |
| SCALEKIT_ENVIRONMENT_URL       | Find this in your <a href="https://app.scalekit.com" target="_blank">API config</a> section of Scalekit Dashboard. For development use `https://{your-subdomain}.scalekit.dev`, for production use `https://{your-subdomain}.scalekit.com` |
| SCALEKIT_CLIENT_SECRET | Generate a new client secret in your <a href="https://app.scalekit.com" target="_blank">API config</a> section of Scalekit Dashboard and use that here                                                         |
| SCALEKIT_CLIENT_ID    | Find this in your <a href="https://app.scalekit.com" target="_blank">API config</a> section of Scalekit Dashboard                                                                                              |

After the successful execution of the above API call, you will see a new OpenID connection created in your Auth0 tenant. To confirm this, you can navigate to <a href="https://auth0.com/docs/authenticate/enterprise-connections#view-enterprise-connections" target="_blank">Enterprise Connections</a> in your Auth0 dashboard.

## Add redirect URI in Scalekit

After creating Scalekit as a new OIDC connection, you need to:

<Steps>
1. Copy the Callback URL from your Auth0 Dashboard
2. Add it as a new Redirect URI in your Scalekit API Config section
</Steps>

### Copy callback URL from Auth0

In your Auth0 dashboard, go to Authentication > Enterprise > OpenID Connect > Scalekit > Settings.
Copy the "Callback URL" that's available in the General section of settings.

![Copy Callback URL from your Auth0 Dashboard](@/assets/docs/guides/auth-systems/auth0/1.png)

### Set redirect URI in Scalekit API config

Go to your Scalekit dashboard. Select environment as Development or Production. Navigate to the "API Config" in the Settings (left nav). In the Redirect URIs section, select **Add new URI**. Paste the Callback URL that you copied from Auth0 dashboard. Click on Add button.

![Add new Redirect URI in Scalekit Dashboard](@/assets/docs/guides/auth-systems/auth0/2.png)

## Onboard Single Sign-on customers in Scalekit

To onboard new enterprise customers using Single Sign-on login, you need to:

<Steps>
1. Create an Organization in Scalekit
2. Generate Admin Portal link to allow your customers configure SSO settings
3. Configure Domain in the Scalekit dashboard for that Organization
4. Update Home Realm Discovery settings in your Auth0 tenant with this Organization's domain
</Steps>

## Update home realm discovery in Auth0

In step 2, you have successfully configured Scalekit as an OIDC connection in your Auth0 tenant. It's time to enable Home Realm Discovery for your enterprise customers in Auth0. This configuration will help Auth0 determine which users to be routed to login via Single Sign-on.

In your Auth0 dashboard, go to Authentication > Enterprise > OpenID Connect > Scalekit > Login Experience.
Navigate to "Home Realm Discovery" in the Login Experience Customization section.

In the Identity Provider domains, add the comma separated list of domains that need to be authenticated with Single Sign-on via Scalekit. Auth0 uses this configuration to compare the users email domain at the time of login:

- If there is a match in the configured domains, users will be redirected to the Scalekit's Single Sign-on
- If there is no match, users will be prompted to login via other authentication methods like password or passwordless login based on your Auth0 configuration

For example, if you would like users from three Organizations (FooCorp, BarCorp, AcmeCorp) to access your application using their respective identity providers, you need to add them as a comma separated list foocorp.com, barcorp.com, acmecorp.com. Screenshot below for reference

![Add domains for Home Realm Discovery in Auth0](@/assets/docs/guides/auth-systems/auth0/3.png)

**Save** the Home Realm Discovery settings.

You have now successfully integrated Scalekit with Auth0, thereby facilitating seamless SSO authentication for your application's users.

================
File: guides/integrations/auth-systems/aws-cognito.mdx
================
---
title: AWS Cognito
description: "Learn how to integrate Scalekit with AWS Cognito as an OIDC provider for seamless enterprise Single Sign-On (SSO) authentication."
sidebar:
  label: "AWS Cognito"
prev: false
next: false
---

import { Aside, Steps } from "@astrojs/starlight/components"

Expand your existing AWS Cognito authentication system by integrating Scalekit as an OpenID Connect (OIDC) provider. This integration enables enterprise users to log into your application seamlessly using Single Sign-On (SSO).

![](@/assets/docs/guides/auth-systems/cognito/0.png)

Here's a typical flow illustrating the integration:

<Steps>
1. **User initiates login**: Enterprise users enter their company email address on your application's custom login page (not managed by AWS Cognito) to initiate SSO
2. **Authentication via Scalekit**: Based on identifiers such as the user's company email and Scalekit's connection identifier, users are redirected to authenticate through their organization's Identity Provider (IdP)
</Steps>

Prefer exploring an example app? Check out this <a href="https://github.com/scalekit-developers/nextjs-example-apps/tree/main/cognito-scalekit" target="_blank">Next.js example on GitHub</a>

## Configure Scalekit as an OIDC provider in AWS Cognito

To enable AWS Cognito to redirect users to Scalekit for SSO initiation, configure your Scalekit account as an OIDC provider within AWS Cognito:

<Steps>
1. Navigate to **AWS Cognito** and select your existing **User Pool**
2. Under the **Authentication** section, choose **Social and external providers**
3. Click **Add identity provider > OpenID Connect (OIDC)**
</Steps>

AWS Cognito will display a form requiring specific details to establish the connection with Scalekit:

<figure>
  ![Scalekit - AWS Cognito Integration](@/assets/docs/guides/auth-systems/cognito/1.png)
  <figcaption>AWS Cognito - Add Identity Provider</figcaption>
</figure>

| **Field**             | **Description**                                                                                     |
|-----------------------|-----------------------------------------------------------------------------------------------------|
| Provider Name     | A recognizable label for Scalekit within the AWS ecosystem. This name is used programmatically when generating authorization URLs. For example: `ScalekitIdPRouter` |
| Client ID         | Obtain this from your Scalekit Dashboard under **API Config**                                    |
| Client Secret     | Generate a secret from your Scalekit Dashboard (**API Config**) and input it here                |
| Authorized Scopes | Scopes defining the user attributes that AWS Cognito can access from Scalekit                   |
| Identifiers       | Identifiers instruct AWS Cognito to check user-entered email addresses during sign-in and direct users accordingly to the associated identity provider based on their domain |
| Attribute Request Method | Method used to exchange attributes and generate tokens for users; ensure you map Scalekit's user attributes correctly to your user pool attributes in AWS Cognito |
| Issuer URL        | Enter your Scalekit environment URL found in the Scalekit Dashboard under **API Config**. For development use `https://{your-subdomain}.scalekit.dev` and for production use `https://{your-subdomain}.scalekit.com` |

Scalekit's profile information includes various user attributes useful for your application requirements. Map these attributes between both providers using the attribute list found at **Scalekit Dashboard > Authentication > Single Sign-On**.

This ensures standardized information exchange between your customers' identity providers and your application.

<figure>
  ![Scalekit - AWS Cognito Integration](@/assets/docs/guides/auth-systems/cognito/2.png)
</figure>

The same attribute names are considered OpenID Connect attributes within AWS Cognito, streamlining user profile synchronization between your app and identity providers.

<figure>
  ![Scalekit - AWS Cognito Integration](@/assets/docs/guides/auth-systems/cognito/3.png)
</figure>

Click **Add identity provider** to complete adding Scalekit as an identity provider.

## Implement Single Sign-On in your application

Your application should use its own custom login page instead of the managed login page provided by AWS Cognito. This approach allows you to collect enterprise users' email addresses and redirect them appropriately for authentication via SSO.

<figure>
  ![Scalekit - AWS Cognito Integration](@/assets/docs/guides/auth-systems/cognito/4.png)
</figure>

Generate an authorization URL with two additional parameters— `identity_provider` and `login_hint` — to redirect users seamlessly:

```typescript title="Example Code" wrap
import { Issuer, Client } from "openid-client";

const client = await getOidcClient();

const authUrl = client.authorizationUrl({
  scope: "openid email",
  state: state,
  nonce: nonce,
  identity_provider: "ScalekitIdPRouter", // Same as Provider name (above)
  login_hint: email, // User's company email address
});
console.log("authUrl", authUrl);
const response = NextResponse.redirect(authUrl);
```

### Example authorization endpoint URL

Here's an example of a complete authorization endpoint URL incorporating the required parameters:

```sh wrap
https://[domain].auth.[region].amazoncognito.com/oauth2/authorize
  ?client_id=k6tana1l8b0bvhk9gfixkurr6
  &scope=openid%20email
  &response_type=code
  &redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fauth%2Fcallback
  &state=-5iLRZmPwwdqwqT-A4yiJM6KQvCLQM0JRx9QaXOlzRE
  &nonce=sGSXePnJ0Ue5GZyTpKG4rRsVeWyfZloImbMWunUDbG4
  &identity_provider=ScalekitIdPRouter
  &login_hint=enterpriseuser%40example.org
```

For ease of development, Scalekit supports testing with `@example.org` and `@example.com` domains. Authorization endpoints generated using these domains as `login_hint` will redirect enterprise users to Scalekit's built-in IdP Simulator.

<figure>
  ![Scalekit - AWS Cognito Integration](@/assets/docs/guides/auth-systems/cognito/5.png)
</figure>

Treat the IdP Simulator as equivalent to an actual organization's IdP authentication step. For instance, if John belongs to Megasoft (using Okta as their IdP), logging in with `john@megasoft.org` would redirect him to Okta's authentication process (including MFA or other organizational policies).

Scalekit integrates seamlessly with [major identity providers](/guides/integrations/sso-integrations/). Use Scalekit's [Admin Portal](/guides/sso/admin-portal/) to onboard enterprise customers, enabling them to set up connections between their identity providers and your application.

<Aside>

The domain of your enterprise customer should be added to the list of identifiers in the AWS Cognito > User Pool > Authentication > Social and external providers > [ScalekitIdPRouter] > Identifiers

</Aside>

### Successful SSO response

Upon successful authentication via SSO, your application receives user profile details mapped according to AWS Cognito's configured user attributes:

```json title="Successful SSO response" showLineNumbers=false
{
"sub": "807c593c-d0c1-709c-598f-633ec61bcc8b",
"email_verified": "false",
"email": "john@example.com",
"username": "scalekitIdPRouter_conn_60040666217971987;a2c49d97-d36f-460f-97c2-87eb295095af"
}
```

Now that you've successfully integrated AWS Cognito with Scalekit for SSO, here are some recommended next steps — Onboard Enterprise Customers using the Scalekit Admin Portal to help customers configure their identity providers.

================
File: guides/integrations/auth-systems/firebase.mdx
================
---
title: Co-exist with Firebase
description: "Learn how to integrate Scalekit with Firebase for enterprise SSO, using either Firebase's OIDC provider or direct SSO with custom tokens."
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
sidebar:
  label: Firebase

prev: false
next: false
---

import { Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components'

This guide explains how to integrate Scalekit with Firebase applications for enterprise Single Sign-On (SSO) authentication. You'll learn two distinct approaches based on your Firebase Authentication setup.

![Scalekit - Firebase Integration](@/assets/docs/guides/auth-systems/firebase/0.png)

## Before you begin

Review your Firebase Authentication setup to determine which integration approach suits your application:

- **Option 1**: Requires Firebase Authentication with Identity Platform (paid tier)
- **Option 2**: Works with Legacy Firebase Authentication (free tier)

You also need:
- Access to a <a href="https://app.scalekit.com" target="_blank">Scalekit account</a>
- Firebase project with Authentication enabled
- Basic understanding of [Firebase Admin SDK](https://firebase.google.com/docs/reference/admin) (for Option 2)

Checkout our [example app](https://github.com/scalekit-sdk/firebase-oidc-example) for a complete implementation.

## Option 1: Configure Scalekit as an OIDC Provider

Use this approach if you have **Firebase Authentication with Identity Platform**. Firebase acts as an OpenID Connect (OIDC) relying party that integrates directly with Scalekit.

<Aside type="note">
OpenID Connect providers are not available in Legacy Firebase Authentication. See the <a href="https://cloud.google.com/identity-platform/docs/product-comparison" target="_blank">Firebase product comparison</a> for details.
</Aside>

```mermaid wrap showLineNumbers=false title="How it works"
graph LR
    User --> FirebaseOIDC[Firebase OIDC]
    FirebaseOIDC --> Scalekit
    Scalekit --> IdentityProvider[Identity Provider]
    IdentityProvider --> Scalekit
    Scalekit --> FirebaseOIDC
    FirebaseOIDC --> YourApp[Your App]
```

Firebase handles the OAuth 2.0 flow automatically using its built-in OIDC provider support.

<Steps>

1. #### Configure Firebase to accept Scalekit as an identity provider

   Log in to the <a href="https://console.firebase.google.com/" target="_blank">Firebase Console</a> and navigate to your project.

   - Go to **Authentication** > **Sign-in method**
   - Click **Add new provider** and select **OpenID Connect**
   - Set the **Name** to "Scalekit"
   - Choose **Code flow** for the **Grant Type**

   ![Sign-in tab in your Firebase Console](@/assets/docs/guides/auth-systems/firebase/1.png)

2. #### Copy your Scalekit API credentials

   In your Scalekit Dashboard, navigate to **Settings** > **API Config** and copy these values:

   - **Client ID**: Your Scalekit application identifier
   - **Environment URL**: Your Scalekit environment (e.g., `https://your-subdomain.scalekit.dev`)
   - **Client Secret**: Generate a new secret if needed

   ![Scalekit API Configuration](@/assets/docs/guides/auth-systems/firebase/2.png)

3. #### Connect Firebase to Scalekit using your API credentials

   In Firebase Console, paste the Scalekit values into the corresponding fields:

   - **Client ID**: Paste your Scalekit Client ID
   - **Issuer URL**: Paste your Scalekit Environment URL
   - **Client Secret**: Paste your Scalekit Client Secret

   ![Firebase OIDC Provider Configuration](@/assets/docs/guides/auth-systems/firebase/3.png)

4. #### Allow Firebase to redirect users back to your app

   Copy the **Callback URL** from your Firebase OIDC Integration settings.

   ![Firebase Callback URL](@/assets/docs/guides/auth-systems/firebase/4.png)

   Add this URL as a **Redirect URI** in your Scalekit API Config.

   ![Scalekit Redirect URI Configuration](@/assets/docs/guides/auth-systems/firebase/5.png)

5. #### Add SSO login to your frontend code

   Use Firebase's standard OIDC authentication in your frontend:

   ```javascript title="Login Implementation"
   import { getAuth, OAuthProvider, signInWithPopup } from 'firebase/auth';

   const auth = getAuth();

   // Initialize Scalekit as an OIDC provider
   const scalekitProvider = new OAuthProvider('oidc.scalekit');

   // Set SSO parameters
   scalekitProvider.setCustomParameters({
     domain: 'customer@company.com', // or organization_id, connection_id
   });

   // Handle SSO login
   const loginButton = document.getElementById('sso-login');
   loginButton.onclick = async () => {
     try {
       const result = await signInWithPopup(auth, scalekitProvider);
       const user = result.user;

       console.log('Authenticated user:', user.email);
       // User is now signed in to Firebase
     } catch (error) {
       console.error('Authentication failed:', error);
     }
   };
   ```

</Steps>

## Option 2: Direct SSO with Custom Tokens

Use this approach if you have **Legacy Firebase Authentication** or need full control over the authentication flow. Your backend integrates directly with Scalekit and creates custom Firebase tokens.

<details>
<summary>View authentication flow summary</summary>

```mermaid wrap showLineNumbers=false title="How it works"
1. User clicks "Sign In"
   ↓
2. Frontend calls backend → Backend generates Scalekit auth URL
   ↓
3. Frontend redirects to Scalekit auth URL
   ↓
4. Scalekit redirects to Identity Provider
   ↓
5. User authenticates with IdP
   ↓
6. IdP redirects back to Scalekit
   ↓
7. Scalekit redirects to your backend callback URL with code
   ↓
8. Backend exchanges code for user profile with Scalekit
   ↓
9. Backend creates custom Firebase token
   ↓
10. Backend returns custom token to frontend
    ↓
11. Frontend calls signInWithCustomToken(firebase, customToken)
    ↓
12. Firebase creates/updates user and returns Firebase user object
    ↓
13. User is authenticated and can access your app!
```
</details>

Your backend handles SSO authentication and creates custom tokens for Firebase.

<Steps>

1. #### Install Scalekit and Firebase Admin SDKs

   Install the Scalekit SDK and configure your backend server with Firebase Admin SDK:

   ```bash
   npm install @scalekit-sdk/node firebase-admin
   ```

   ```javascript title="backend/server.js"
   import { ScalekitClient } from '@scalekit-sdk/node';
   import admin from 'firebase-admin';

   // Initialize Scalekit
   const scalekit = new ScalekitClient(
     process.env.SCALEKIT_ENVIRONMENT_URL,
     process.env.SCALEKIT_CLIENT_ID,
     process.env.SCALEKIT_CLIENT_SECRET
   );

   // Initialize Firebase Admin
   ```

2. #### Handle SSO callback and create Firebase tokens

   Implement the SSO callback handler that exchanges the authorization code for user details and creates custom Firebase tokens:

   ```javascript title="SSO Callback Handler"
   app.get('/auth/callback', async (req, res) => {
     const { code, error, error_description } = req.query;

     if (error) {
       return res.status(400).json({
         error: 'Authentication failed',
         details: error_description
       });
     }

     try {
       // Exchange code for user profile
       const result = await scalekit.authenticateWithCode(
         code,
         'https://your-app.com/auth/callback'
       );

       const user = result.user;

       // Create custom Firebase token
       const customToken = await admin.auth().createCustomToken(user.id, {
         email: user.email,
         name: `${user.givenName} ${user.familyName}`,
         organizationId: user.organizationId,
       });

       res.json({
         customToken,
         user: {
           email: user.email,
           name: `${user.givenName} ${user.familyName}`,
         }
       });
     } catch (error) {
       console.error('SSO authentication failed:', error);
       res.status(500).json({ error: 'Internal server error' });
     }
   });
   ```

3. #### Generate authorization URL to initiate SSO

   Create an endpoint to generate Scalekit authorization URLs:

   <Tabs syncKey="backend-language">
   <TabItem value="nodejs" label="Node.js">

   ```javascript title="Authorization URL Endpoint"
   app.post('/auth/start-sso', async (req, res) => {
     const { organizationId, domain, connectionId } = req.body;

     try {
       const options = {};
       if (organizationId) options.organizationId = organizationId;
       if (domain) options.domain = domain;
       if (connectionId) options.connectionId = connectionId;

       const authorizationUrl = scalekit.getAuthorizationUrl(
         'https://your-app.com/auth/callback',
         options
       );

       res.json({ authorizationUrl });
     } catch (error) {
       console.error('Failed to generate authorization URL:', error);
       res.status(500).json({ error: 'Internal server error' });
     }
   });
   ```

   </TabItem>
   <TabItem value="python" label="Python">

   ```python title="Authorization URL Endpoint"
   @app.route('/auth/start-sso', methods=['POST'])
   def start_sso():
       data = request.get_json()
       organization_id = data.get('organizationId')
       domain = data.get('domain')
       connection_id = data.get('connectionId')

       try:
           options = {}
           if organization_id:
               options['organization_id'] = organization_id
           if domain:
               options['domain'] = domain
           if connection_id:
               options['connection_id'] = connection_id

           authorization_url = scalekit.get_authorization_url(
               'https://your-app.com/auth/callback',
               options
           )

           return jsonify({'authorizationUrl': authorization_url})
       except Exception as e:
           print(f'Failed to generate authorization URL: {e}')
           return jsonify({'error': 'Internal server error'}), 500
   ```

   </TabItem>
   <TabItem value="golang" label="Go">

   ```go title="Authorization URL Endpoint"
   func startSSOHandler(w http.ResponseWriter, r *http.Request) {
       var requestData struct {
           OrganizationID string `json:"organizationId"`
           Domain         string `json:"domain"`
           ConnectionID   string `json:"connectionId"`
       }

       if err := json.NewDecoder(r.Body).Decode(&requestData); err != nil {
           http.Error(w, "Invalid request body", http.StatusBadRequest)
           return
       }

       options := scalekit.AuthorizationUrlOptions{}
       if requestData.OrganizationID != "" {
           options.OrganizationId = requestData.OrganizationID
       }
       if requestData.Domain != "" {
           options.Domain = requestData.Domain
       }
       if requestData.ConnectionID != "" {
           options.ConnectionId = requestData.ConnectionID
       }

       authorizationURL := scalekitClient.GetAuthorizationUrl(
           "https://your-app.com/auth/callback",
           options,
       )

       response := map[string]string{
           "authorizationUrl": authorizationURL,
       }

       w.Header().Set("Content-Type", "application/json")
       json.NewEncoder(w).Encode(response)
   }
   ```

   </TabItem>
   <TabItem value="java" label="Java">

   ```java title="Authorization URL Endpoint"
   @PostMapping("/auth/start-sso")
   public ResponseEntity<?> startSSO(@RequestBody Map<String, String> request) {
       String organizationId = request.get("organizationId");
       String domain = request.get("domain");
       String connectionId = request.get("connectionId");

       try {
           AuthorizationUrlOptions options = new AuthorizationUrlOptions();
           if (organizationId != null) options.setOrganizationId(organizationId);
           if (domain != null) options.setDomain(domain);
           if (connectionId != null) options.setConnectionId(connectionId);

           String authorizationUrl = scalekitClient.authentication()
               .getAuthorizationUrl("https://your-app.com/auth/callback", options)
               .toString();

           return ResponseEntity.ok(Map.of("authorizationUrl", authorizationUrl));
       } catch (Exception e) {
           System.err.println("Failed to generate authorization URL: " + e.getMessage());
           return ResponseEntity.status(500).body(Map.of("error", "Internal server error"));
       }
   }
   ```

   </TabItem>
   </Tabs>

4. #### Build frontend SSO flow with custom tokens

   Create the frontend flow that initiates SSO and handles the custom token:

   ```javascript title="Frontend SSO Implementation"
   import { getAuth, signInWithCustomToken } from 'firebase/auth';

   const auth = getAuth();

   // Initiate SSO flow
   const initiateSSO = async () => {
     try {
       // Get authorization URL from your backend
       const response = await fetch('/auth/start-sso', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({
           organizationId: 'org_123456789', // or domain, connectionId
         }),
       });

       const { authorizationUrl } = await response.json();

       // Redirect to SSO
       window.location.href = authorizationUrl;
     } catch (error) {
       console.error('Failed to initiate SSO:', error);
     }
   };

   // Handle SSO callback (call this on your callback page)
   const handleSSOCallback = async () => {
     const urlParams = new URLSearchParams(window.location.search);
     const code = urlParams.get('code');
     const error = urlParams.get('error');

     if (error) {
       console.error('SSO failed:', error);
       return;
     }

     try {
       // Exchange code for custom token
       const response = await fetch(`/auth/callback?code=${code}`);
       const { customToken, user } = await response.json();

       // Sign in to Firebase with custom token
       const userCredential = await signInWithCustomToken(auth, customToken);
       const firebaseUser = userCredential.user;

       console.log('Successfully authenticated:', firebaseUser);

       // Redirect to your app
       window.location.href = '/dashboard';
     } catch (error) {
       console.error('Authentication failed:', error);
     }
   };
   ```

</Steps>

## Handle identity provider-initiated SSO

Both approaches support IdP-initiated SSO, where users access your application directly from their identity provider portal. Create a dedicated endpoint to handle these requests.

For detailed implementation instructions, refer to the [IdP-Initiated SSO guide](/sso/guides/idp-init-sso/).

Both approaches provide secure, enterprise-grade SSO authentication while maintaining compatibility with Firebase's ecosystem and features.

================
File: guides/integrations/scim-integrations/azure-scim.mdx
================
---
title: Microsoft Azure AD
description: Integrate Microsoft Entra ID with the host application for seamless user management
sidebar:
  order: 1
  label: "Microsoft Entra ID"
  badge:
    variant: note
    text: SCIM
prev: false
next: false
---

import { Steps, Aside } from '@astrojs/starlight/components';

This guide helps administrators sync their EntraID directory with an application they want to onboard to their organization. Integrating your application with Entra ID automates user management tasks and ensures access rights stay up-to-date.

This registration sets up the following:

1. **Endpoint**: This is the URL where EntraID sends requests to the onboarded app, acting as a communication point between them.
2. **Bearer Token**: Used by EntraID to authenticate its requests to the endpoint, ensuring security and authorization.

These components enable seamless synchronization between your application and the EntraID directory.

<Steps>
1. ### Create an endpoint and API token

   Select the "Directory Sync" tab to display a list of Directory Providers. Choose "Entra ID" as your Directory Provider. If the Admin Portal is not accessible from the app, request instructions from the app owner.

   ![Setting up Directory Sync in the admin portal of an app being onboarded: Entra ID selected as the provider, awaiting configuration](@/assets/docs/guides/scim-integrations/google-dir-sync/1.png)

   Click "Configure" after selecting "EntraID" to generate an Endpoint URL and Bearer token for your organization, allowing the app to listen to events and maintain synchronization.

   ![Endpoint URL and Bearer token for your organization.](@/assets/docs/guides/scim-integrations/entra-id-scim/00-2.png)

2. ### Add a new application in Entra ID

   To send user-related updates to the app you want to onboard, create a new app in Microsoft Entra ID.

   Go to the Microsoft Azure portal and select "Microsoft Entra ID".

   ![Microsoft Entra ID in the Azure portal.](@/assets/docs/guides/scim-integrations/entra-id-scim/01.png)

   In the "Manage > All applications" tab, click "+ New application".

   ![Adding a new application in Microsoft Entra ID.](@/assets/docs/guides/scim-integrations/entra-id-scim/02.png)

   Click "+ Create your own application" in the modal that opens on the right.

   ![Creating a new application in Microsoft Entra ID.](@/assets/docs/guides/scim-integrations/entra-id-scim/03.png)

   Name the app you want to onboard (e.g., "Hero SaaS") and click "Create", leaving other defaults as-is.

   ![Creating a new application in Microsoft Entra ID.](@/assets/docs/guides/scim-integrations/entra-id-scim/04.png)

3. ### Configure provisioning settings

   In the "Hero SaaS" app's overview, select "Manage > Provisioning" from the left sidebar.

   ![Configuring provisioning for the "Hero SaaS" app.](@/assets/docs/guides/scim-integrations/entra-id-scim/05.png)

   Set the Provisioning Mode to "Automatic".

   In the Admin Credentials section, set:

   - Tenant URL: _Endpoint_
   - Secret Token: _Bearer Token generated previously_

   ![Setup Provisioning Mode and Admin Credentials.](@/assets/docs/guides/scim-integrations/entra-id-scim/06.png)

   In the Mappings section, click "Provision Microsoft Entra ID Users" and toggle "Enabled" to "Yes".

   ![Making sure the "Provision Microsoft Entra ID Users" is enabled.](@/assets/docs/guides/scim-integrations/entra-id-scim/07.png)

   ![Making sure the "Provision Microsoft Entra ID Users" is enabled.](@/assets/docs/guides/scim-integrations/entra-id-scim/08.png)

   Close the modal and reload the page for changes to take effect.

   Go to "Overview > Manage > Provisioning" and ensure "Provisioning Status" is toggled "On".

   ![Making sure the "Provisioning Status" is toggled "On".](@/assets/docs/guides/scim-integrations/entra-id-scim/010.png)

   Entra ID is now set up to send events to Hero SaaS when users are added or removed.

4. ### Test user and group provisioning

   In the Hero SaaS Application, go to "Provision on demand". Input a user name from your user list and click "Provision".

   ![Provisioning a user/group on demand.](@/assets/docs/guides/scim-integrations/entra-id-scim/020.png)

   Once provisioned, the user should appear in the admin portal, showing how many users have access to the Hero SaaS app.

   ![Group (Admins) provisioned in the admin portal.](@/assets/docs/guides/scim-integrations/entra-id-scim/013.png)

   <Aside type="note">
   Provisioning or deprovisioning users can be done from "Manage > User and groups > Add user/group". [Entra ID takes up to 40 minutes](https://learn.microsoft.com/en-us/entra/identity/app-provisioning/use-scim-to-provision-users-and-groups#getting-started:~:text=Once%20connected%2C%20Microsoft%20Entra%20ID%20runs%20a%20synchronization%20process.%20The%20process%20runs%20every%2040%20minutes.%20The%20process%20queries%20the%20application%27s%20SCIM%20endpoint%20for%20assigned%20users%20and%20groups%2C%20and%20creates%20or%20modifies%20them%20according%20to%20the%20assignment%20details.) for the changes to propagate to the application.
   </Aside>

</Steps>

================
File: guides/integrations/scim-integrations/google-dir-sync.mdx
================
---
title: Google Workspace Directory
description: Integrate Google Workspace with the host application for seamless user management
sidebar:
  order: 2
  label: "Google Workspace"
  badge:
    variant: note
    text: SCIM
prev: false
next: false
---

import { Steps, Aside } from '@astrojs/starlight/components';

This guide helps administrators sync their Google Workspace directory with an application they want to onboard to their organization. Integrating your application with Google Workspace automates user management tasks and ensures access rights stay up-to-date.

<Steps>
1. ### Access the directory configuration screen

   Navigate to the Admin Portal of your application and select the "Directory Sync" tab. You'll see a list of available directory providers.

   ![Directory Sync configuration screen with various provider options.](@/assets/docs/guides/scim-integrations/google-dir-sync/1.png)

2. ### Select Google Workspace

   From the list of directory providers, locate and click on "Google Workspace".

   ![Select Google Workspace from the available directory providers.](@/assets/docs/guides/scim-integrations/google-dir-sync/2.png)

3. ### Begin configuration

   Click on the "Configure" button to start setting up the Google Workspace integration.

   ![Click Configure to begin setting up the Google Workspace integration.](@/assets/docs/guides/scim-integrations/google-dir-sync/3.png)

4. ### Authorize Google Workspace

   To establish the connection, you need to authorize access to your Google Workspace directory. Click on "Authorize Google Workspace".

   ![Click Authorize Google Workspace to begin the authorization process.](@/assets/docs/guides/scim-integrations/google-dir-sync/5.png)

5. ### Sign in with Google admin account

   You'll be redirected to Google's authentication page. Sign in with your Google Workspace administrator account. If you're already signed in with multiple accounts, select "Use another account" to ensure you're using your administrator account.

   ![Select "Use another account" if you need to sign in with a different Google account.](@/assets/docs/guides/scim-integrations/google-dir-sync/6.png)

6. ### Enter administrator credentials

   Enter your Google Workspace administrator email address and password when prompted.

   ![Enter your Google Workspace administrator email address.](@/assets/docs/guides/scim-integrations/google-dir-sync/7.png)

7. ### Grant required permissions

   When prompted, review and confirm the permissions requested by the application. These permissions allow the application to read user and group information from your Google Workspace directory.

   ![Review the requested permissions for directory access.](@/assets/docs/guides/scim-integrations/google-dir-sync/16.png)

   Click "Continue" to grant the necessary permissions.

   ![Click Continue to grant directory access permissions.](@/assets/docs/guides/scim-integrations/google-dir-sync/19.png)

8. ### Select groups to sync

   After authorization, you'll see the groups available in your Google Workspace directory. Select the groups you want to synchronize with your application.

   ![Select which Google Workspace groups you want to sync with your application.](@/assets/docs/guides/scim-integrations/google-dir-sync/21.png)

9. ### Map IdP groups to application roles

   Map IdP groups to application roles to control access to your application. This needs to be enabled by the host application.

   ![Map IdP groups to application roles to control access to your application.](@/assets/docs/guides/scim-integrations/google-dir-sync/22-5.png)

10. ### Enable directory sync

    After selecting your groups, click "Enable Sync" to activate the integration.

    ![Click Enable Sync to start synchronizing users and groups from Google Workspace.](@/assets/docs/guides/scim-integrations/google-dir-sync/26.png)

11. ### Troubleshoot common issues

    If you encounter issues during synchronization:

    1. **Authorization errors**: Ensure you have sufficient privileges to authorize us to access your users and groups information from your Google Workspace directory.
    2. **Missing users/groups**: We automatically fetch latest users and groups from Google Workspace directory once every hour. If you would like to trigger a sync manually, use the "Sync Now" button in the Actions menu.
</Steps>

================
File: guides/integrations/scim-integrations/index.mdx
================
---
title: SCIM integrations
description: Step by Step guide to provisioning over own SCIM implementation
sidebar:
  label: List of SCIM integrations
  order: 1
tableOfContents: false
prev: false
next: false
---

import { Tabs, TabItem, LinkCard } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { SCIMIntegrationsSection } from '@/components/templates';

SCIM (System for Cross-domain Identity Management) is a standardized protocol for automating user provisioning between identity providers and applications. This section provides guides for setting up SCIM integration with various identity providers.

Choose your identity provider from the guides below to get started with SCIM integration:

<SCIMIntegrationsSection />

================
File: guides/integrations/scim-integrations/jumpcloud.mdx
================
---
title: JumpCloud Directory
description: "Learn how to sync your JumpCloud directory with your application for automated user provisioning and management using SCIM."
sidebar:
  order: 3
  label: "JumpCloud"
  badge:
    variant: note
    text: SCIM
prev: false
next: false
---

import { Steps, Aside } from '@astrojs/starlight/components';

This guide helps administrators sync their JumpCloud directory with an application they want to onboard to their organization. Integrating your application with JumpCloud automates user management tasks and ensures access rights stay up-to-date.

This registration sets up the following:

1. **Endpoint**: This is the URL where JumpCloud sends requests to the onboarded app, acting as a communication point between them.
2. **Bearer Token**: Used by JumpCloud to authenticate its requests to the endpoint, ensuring security and authorization.

These components enable seamless synchronization between your application and the JumpCloud directory.

<Steps>
1. ### Create an endpoint and API token

   Open the Admin Portal and select the "SCIM Provisioning" tab. A list of Directory Providers will be displayed. Choose "JumpCloud" as your Directory Provider. If the Admin Portal is not accessible from the app, request instructions from the app owner.

   ![SCIM Provisioning Setup](@/assets/docs/guides/scim-integrations/jumpcloud-scim/1-select-jumpcloud.png)

   ![SCIM Provisioning Setup](@/assets/docs/guides/scim-integrations/jumpcloud-scim/1-2-scimconfigs.png)

   This action will generate an Endpoint URL and Bearer token for your organization, allowing the app to listen to events and maintain synchronization with your organization.

2. ### Add a new application in JumpCloud

   Go to the JumpCloud Admin Portal > SSO Applications and click on "+ Add New Application."

   ![Add New Application](@/assets/docs/guides/scim-integrations/jumpcloud-scim/2-add-new-app.png)

   Create a custom application by trying to do an non-existent application search.

   ![Application Selection](@/assets/docs/guides/scim-integrations/jumpcloud-scim/3-custom-integration.png)

   Click "Next" and choose the features you would like to enable. Since your application wants to provision new users and user updates from JumpCloud, select "Export users to this app (Identity Management)"

   ![Feature Selection](@/assets/docs/guides/scim-integrations/jumpcloud-scim/4-export-users.png)

   Finally, enter the general info such as display name (this example uses "YourApp") and click "Save Application"

   ![Successful addition](@/assets/docs/guides/scim-integrations/jumpcloud-scim/5-success-app-creation.png)

3. ### Configure provisioning settings

   Click on "Configure Application" and proceed to configure the application settings. This opens a modal with "Identity Management" selected. Enter the Endpoint URL and Bearer Token provided in the Step 1.

   ![Configure Application Settings](@/assets/docs/guides/scim-integrations/jumpcloud-scim/6-scim-config-page.png)

4. ### Configure group management

   JumpCloud uses groups as the primary way provision users to your application.

   ![Provisioning Settings](@/assets/docs/guides/scim-integrations/jumpcloud-scim/7-group-management.png)

   Click "Activate" and then "Save".

5. ### Assign users and groups

   To assign users to the newly integrated application:

   ![User Assignment](@/assets/docs/guides/scim-integrations/jumpcloud-scim/8-group-assigned.png)

   1. Go to "SSO Applications" and select the application you created. This opens an Modal. Select the User Group and click on "Save".
   2. Click on the "User Groups" tab and select the apps you want to assign to this group of users.
   3. If you don't have groups you can create one from "User Groups" tab. In this example, we have created a group called "YourApp Users" and assigned the "YourApp" app to it.
   4. Click on "Save Group" to save the changes.
   5. Now try adding a user to the group. If you don't have users, you can create one from "Users" tab.

   <Aside type="tip">
   Make sure to organize your users into groups for easier management and assignment of permissions.
   </Aside>

6. ### Group based Role Assignment Configuration

   To automatically assign roles to users based on their group membership, configure appropriate group to role mapping in the SCIM Configuration Portal.

7. ### Verify successful connection

   After completing these steps, verify that the users and groups are successfully synced by visiting Users and Groups tab in the Admin Portal.

   ![Verification Process](@/assets/docs/guides/scim-integrations/jumpcloud-scim/9-synced-user.png)

   <Aside type="note">
   When an group is disassociated from an app in JumpCloud ("YourApp"), JumpCloud sends an group update event that unassigns all the group users to your app. However, the group association is not removed automatically.
   </Aside>

</Steps>

================
File: guides/integrations/scim-integrations/okta-scim.mdx
================
---
title: Okta Directory
description: "Learn how to sync your Okta Directory with your application for automated user provisioning and management using SCIM."
sidebar:
  order: 2
  label: "Okta"
  badge:
    variant: note
    text: SCIM
prev: false
next: false
---

import { Steps, Aside } from '@astrojs/starlight/components';

This guide is designed to help administrators seamlessly sync their Okta Directory with an application they want to onboard to their organization. By integrating your application with Okta, you can automate user management tasks and ensure that access rights are consistently up-to-date.

This registration sets up the following:

1. **Endpoint**: This is the URL where Okta will send requests to the app you are onboarding. It acts as a communication point between Okta and your application.
2. **Bearer Token**: This token is used by Okta to authenticate its requests to the endpoint. It ensures that the requests are secure and authorized.

By setting up these components, you enable seamless synchronization between your application and the Okta directory.

<Steps>
1. ### Create an endpoint and API token

   Open the Admin Portal from the app being onboarded and select the "Directory Sync" tab. A list of Directory Providers will be displayed. Choose "Okta" as your Directory Provider. If the Admin Portal is not accessible from the app, request instructions from the app owner.

   ![Okta SCIM](@/assets/docs/guides/scim-integrations/okta-scim/0.png)

   ![Okta directory sync setup: Endpoint URL and one-time visible bearer token provided.](@/assets/docs/guides/scim-integrations/okta-scim/5.png)

   After selecting "Okta," click "Configure." This action will generate an Endpoint URL and Bearer token for your organization, allowing the app to listen to events and maintain synchronization with your organization.

2. ### Add a new application in Okta

   Log in to the Okta admin dashboard and navigate to "Applications" in the main menu.

   ![Okta app catalog: SCIM 2.0 Test App integration options displayed.](@/assets/docs/guides/scim-integrations/okta-scim/1-scim-search.png)

   If you haven't previously created a SCIM application in Okta, select "Browse App Catalog." Otherwise, choose it from your existing list of applications. In the Okta Application dashboard, search for "SCIM 2.0 Test App (OAuth Bearer Token)" and select the corresponding result.

   Click "Add Integration" on the subsequent page.

   ![Adding SCIM 2.0 Test App integration in Okta for app being onboarded](@/assets/docs/guides/scim-integrations/okta-scim/2.png)

   Provide a descriptive name for the app, then proceed by clicking "Next."

   ![Naming the app 'Hero SaaS' during SCIM 2.0 Test App integration in Okta.](@/assets/docs/guides/scim-integrations/okta-scim/3.png)

   The default configuration is typically sufficient for most applications. However, if your directory requires additional settings, such as Attribute Statements, configure these on the Sign-On Options page. Complete the application creation process by clicking "Done."

3. ### Enable sending and receiving events in provisioning settings

   In your application's Enterprise Okta admin panel, navigate to the "Provisioning" tab and select "Configure API Integration."

   ![Enabling API Integration in Okta for app being onboarded.](@/assets/docs/guides/scim-integrations/okta-scim/4.png)

   Copy the Endpoint URL and Bearer Token from your Admin Portal and paste them into the *SCIM 2.0 Base URL* field and *OAuth Bearer Token* field, respectively. Verify the configuration by clicking "Test API Credentials," then save the settings.

   ![Verifying SCIM credentials for Hero SaaS integration in Okta](@/assets/docs/guides/scim-integrations/okta-scim/6.png)

   Give provisioning permissions to the API integration. This is necessary to allow Okta to send and receive events to the app. Upon successful configuration, the Provisioning tab will display a new set of options. These options will be utilized to complete the provisioning process for your application.

   ![Saving verified SCIM API integration settings for Hero SaaS in Okta](@/assets/docs/guides/scim-integrations/okta-scim/7.png)

4. ### Configure provisioning options

   In the "To App" navigation section, enable the following options:

   - Create Users
   - Update User Attributes
   - Deactivate Users

   ![Granting provisioning permissions to Hero SaaS app in Okta SCIM integration](@/assets/docs/guides/scim-integrations/okta-scim/4.1.png)

   After enabling these options, click "Save" to apply the changes. These settings allow Okta to perform user provisioning actions in your application, including creating new user accounts, updating existing user information, and deactivating user accounts when necessary.

5. ### Assign users and groups

   ![Assigning users to Hero SaaS in Okta: Options to assign to individuals or groups](@/assets/docs/guides/scim-integrations/okta-scim/10.png)

   To assign users to the SAML Application:

   1. Navigate to the "Assignments" tab.
   2. From the "Assign" dropdown, select "Assign to People."
   3. Choose the users you want to provision and click "Assign."
   4. A form will open for each user. Review and populate the user's metadata fields.
   5. Scroll to the bottom and click "Save and Go Back."
   6. Repeat this process for all users, then select "Done."
   ![Assigning users to Hero SaaS in Okta: Selecting individuals for access](@/assets/docs/guides/scim-integrations/okta-scim/12.png)

6. ### Push groups and sync group membership

   To push groups and sync group membership:

   1. Navigate to the "Push Groups" tab.
   2. From the "Push Groups" dropdown, select "Find groups by name."
   3. Search for and select the group you want to push.
   4. Ensure the "Push Immediately" box is checked.
   5. Click "Save."

   ![Pushing group memberships to SCIM 2.0 Test App: Configuring the 'Avengers' group in Okta](@/assets/docs/guides/scim-integrations/okta-scim/15.png)

   <Aside type="caution" title="IMPORTANT">
   For accurate group membership synchronization, ensure that the same groups are not configured for push groups and group assignments. If the same groups are configured in both assignments and push groups, manual group pushes may be required for accurate membership reflection.<br />
   <a href="https://help.okta.com/en-us/content/topics/users-groups-profiles/app-assignments-group-push.htm" target="_blank" rel="noopener">Okta documentation</a>
   </Aside>

7. ### Group based Role Assignment Configuration

   To automatically assign roles to users based on their group membership, configure appropriate group to role mapping in the SCIM Configuration Portal.
   ![Pushing group memberships to SCIM 2.0 Test App: Configuring the 'Avengers' group in Okta](@/assets/docs/guides/scim-integrations/okta-scim/gbra.png)

8. ### Verify successful connection

   After completing these steps, verify that the users and groups are successfully synced by visiting Users and Groups tab in the Admin Portal.

   ![Verification Process](@/assets/docs/guides/scim-integrations/okta-scim/verify.png)
</Steps>

================
File: guides/integrations/scim-integrations/onelogin.mdx
================
---
title: OneLogin Directory
description: "Learn how to sync your OneLogin directory with your application for automated user provisioning and management using SCIM."
sidebar:
  order: 3
  label: "OneLogin"
  badge:
    variant: note
    text: SCIM
prev: false
next: false
---
import { Steps, Aside } from '@astrojs/starlight/components';

This guide helps administrators sync their OneLogin directory with an application they want to onboard. Integrating your application with OneLogin automates user management tasks and keeps access rights up-to-date.

Setting up the integration involves:

1. **Endpoint**: The URL where OneLogin sends requests to your application, enabling communication between them.
2. **Bearer Token**: A token OneLogin uses to authenticate its requests to the endpoint, ensuring security and authorization.

By setting up these components, you enable seamless synchronization between your application and the OneLogin directory.

<Steps>
1. ### Create an endpoint and API token

   Open the Admin Portal from the app being onboarded and select the "Directory Sync" tab. Choose "OneLogin" as your Directory Provider.

   ![Setting up Directory Sync in the admin portal of an app being onboarded: OneLogin selected as the provider, awaiting configuration](@/assets/docs/guides/scim-integrations/onelogin-scim/0-1.png)

   Click "Configure" to generate an Endpoint URL and Bearer token for your organization.

   ![OneLogin directory sync setup: Endpoint URL and one-time visible bearer token provided](@/assets/docs/guides/scim-integrations/onelogin-scim/0-2.png)

   <Aside type="note">
   If the "Directory Sync" tab is not visible, contact the app owner to enable it via the Scalekit Dashboard (Organizations > Your Organization > Enable Directory Sync).
   </Aside>

2. ### Add a new application in OneLogin

   In OneLogin, click "Administration" and then "Applications" from the top navigation pane.

   ![OneLogin Administration Applications](@/assets/docs/guides/scim-integrations/onelogin-scim/2.png)

   Click "Add App" to add a new application.

   ![The OneLogin Applications page displays a list of apps with options to download JSON or add a new app.](@/assets/docs/guides/scim-integrations/onelogin-scim/3.png)

   Search for "SCIM Provisioner with SAML (SCIM v2 Enterprise)"

   ![OneLogin application search results for "SCIM Provisioner with SAML" displaying SCIM v2 Enterprise option.](@/assets/docs/guides/scim-integrations/onelogin-scim/4.png)

   Name the app (e.g., "Hero SaaS App") and click "Save".

   ![Configuring the portal settings for the application in OneLogin, including display name and icon options.](@/assets/docs/guides/scim-integrations/onelogin-scim/5.png)

   Go to the "Provisioning" tab, enable provisioning, and click "Save".

   ![Setting up provisioning workflow for SCIM Provisioner with SAML in OneLogin, including options for user creation, deletion, and suspension actions.](@/assets/docs/guides/scim-integrations/onelogin-scim/6.png)

3. ### Provision users

   Go to "Users" and click on a user you want to provision.

   ![OneLogin Users dashboard displaying user information, including roles, last login time, and account status.](@/assets/docs/guides/scim-integrations/onelogin-scim/7.png)

   <Aside type="note">
   You can create a new user for testing. Ensure users have a "username" property, which will be treated as a unique identifier in SCIM implementations. Using an email address as the username is also allowed.
   </Aside>

   Go to the "Applications" tab, click "+", and assign "Hero SaaS App". Click "Continue".

   ![Assigning a new login to a user in OneLogin](@/assets/docs/guides/scim-integrations/onelogin-scim/8.png)

   Click "Pending" to approve provisioning.

   ![OneLogin user provisioning dialog for creating Kitty Flake in Hero SaaS App, with options to approve or skip the action.](@/assets/docs/guides/scim-integrations/onelogin-scim/9.png)

   The status should change to "Provisioned" within a few seconds.

   ![OneLogin user profile for Kitty Flake displaying assigned applications, with Hero SaaS App provisioned and admin-configured.](@/assets/docs/guides/scim-integrations/onelogin-scim/10.png)

   This action informs the Hero SaaS app that the user is approved for access, and the app can create an account for them. You can see the new user added to the "Hero SaaS App" in the portal.

   ![OneLogin Directory Sync interface showing user details for Kitty Flake in Your organization, with SCIM integration status.](@/assets/docs/guides/scim-integrations/onelogin-scim/11.png)

4. ### Configure group provisioning

   Applications being onboarded may have roles that scope access, such as "admin" roles allowing users to perform administrator actions like deleting logs. You can choose which users in your organization get administrator access while others get member access.

   <Aside type="note">
   Labels such as "Member" and "Admin" are specific to the app. Check the "Access Roles" section in the configuration portal provided by the application (in this case, Hero SaaS App). The app owner must enable this section based on its applicability.
   </Aside>

   To map users to groups in the app being onboarded:

   1. Create a role in OneLogin.
   2. Enable the inclusion of the Group parameter.
   3. Create a rule that automatically picks up a user's role value and sets it to the Group parameter.
   4. Assign the role to the user.
   5. Assign the user to the app.

5. ### Configure provisioning settings for groups

   Navigate to the list of Applications and select "Hero SaaS App". Ensure the provisioning workflow is enabled in the "Provisioning" tab.

   ![Setting up provisioning workflow for SCIM Provisioner with SAML in OneLogin, including options for user creation, deletion, and suspension actions.](@/assets/docs/guides/scim-integrations/onelogin-scim/6.png)

   Switch to "Rules" Tab and Click "Add Rule" button.

   Name the rule (e.g., "Assign Group in Hero SaaS") and set the action to "Set Groups in Hero SaaS App" for each "role" with any value.

   ![Configuring a new mapping for group assignment in the Hero SaaS App using OneLogin.](@/assets/docs/guides/scim-integrations/onelogin-scim/13.png)

   Select the "Parameters" tab, click on the "Groups" row, and check "Include in User Provisioning" in the popup.

   ![Configuring field groups in OneLogin for SCIM Provisioning, including SAML assertion and user provisioning options.](@/assets/docs/guides/scim-integrations/onelogin-scim/12.png)

6. ### Create and assign roles

   Click on the user and navigate to "Applications".

   ![Assigning the 'Hero SaaS App' to the 'hero_saas_viewer' role in OneLogin.](@/assets/docs/guides/scim-integrations/onelogin-scim/14.png)

   Add "Hero SaaS App" and select the roles to be passed to the app (treated as Groups by Hero SaaS App).

   ![Viewing application assignment and status for 'Test User' in OneLogin, with 'Hero SaaS App' pending.](@/assets/docs/guides/scim-integrations/onelogin-scim/16.png)

   Approve the user provisioning along with the Group.

   ![Approving 'Test User' for the 'Hero SaaS App' with assigned groups: Viewer and hero_saas_viewer.](@/assets/docs/guides/scim-integrations/onelogin-scim/17.png)

   Finally, verify that the groups are sent to the Hero SaaS App from the administrator portal where you configured the OneLogin connection.

   ![Directory sync status for Your Organization, showing linked groups and user count in OneLogin.](@/assets/docs/guides/scim-integrations/onelogin-scim/18.png)
</Steps>

================
File: guides/integrations/social-connections/github.mdx
================
---
title: GitHub as your sign in option
description: "Learn how to integrate GitHub Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
sidebar:
  order: 3
  label: "GitHub"
tableOfContents:
  maxHeadingLevel: 3
---

import { Steps } from '@astrojs/starlight/components';

Scalekit enables apps to easily let users sign in using GitHub as their social connector. This guide walks you through
the process of setting up the connection between Scalekit and GitHub, and using the Scalekit SDK to add "Sign in with
GitHub" to your application.

<figure>
  ![A diagram showing "Your Application" connecting to "Scalekit" via OpenID Connect, which links to GitHub using OAuth 2.0.](@/assets/docs/guides/social-connections/github-1.png)
</figure>

By the end of this guide, you will be able to:

1. Set up an OAuth 2.0 connection between Scalekit and GitHub
2. Scalekit SDK to add "Sign in with GitHub" to your application

## Connect GitHub with Scalekit

**Navigate to social login settings**

Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

<figure>
  ![Scalekit dashboard showcasing social login setup with various platform integration
  options.](@/assets/docs/common/social-connections/1-navigate-to-social-logins.png)
</figure>

**Add a new GitHub connection**

Click the "+ Add Connection" button and select GitHub from the list of available options.

<figure>
  ![Add social login connections: Google, Microsoft, GitHub, Github,
  Salesforce.](@/assets/docs/common/social-connections/2-list-social-logins.png)
  <figcaption>Add social login connections: GitHub</figcaption>
</figure>

## Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with GitHub.
- **Client ID** and **Client Secret** are generated by GitHub when you register an OAuth App. They enable Scalekit to
  authenticate your app and establish trust with GitHub.

<figure>
  ![Configure OAuth settings](@/assets/docs/guides/social-connections/github-1.png)
  <figcaption>
    GitHub OAuth configuration in Scalekit, showing redirect URI, client credentials, and scopes for social login setup.
  </figcaption>
</figure>

**Set up GitHub OAuth 2.0**

GitHub lets you set up OAuth through the Microsoft Identity Platform.
<a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app" target="_blank" rel="noopener">Follow GitHub's instructions to set up OAuth 2.0</a>.

<Steps>
1. Navigate to GitHub's OAuth Apps settings page
2. Click "New OAuth App" to create a new application
3. Fill in the application details:
   - Application name: Your app's name
   - Homepage URL: Your application's homepage
   - Application description: Brief description of your app
   - Authorization callback URL: Use the Redirect URI from Scalekit
4. Click "Register application" to create the OAuth App
5. Copy the generated Client ID and Client Secret
6. Paste these credentials into the Scalekit Dashboard
7. Click "Save Changes" in Scalekit to complete the setup
</Steps>

<figure>
  ![GitHub OAuth configuration for social login, showing redirect URI, client ID, and scopes for
  authentication.](@/assets/docs/guides/social-connections/github-1.png)
</figure>

## Test the connection

Click the "Test Connection" button in Scalekit. You will be redirected to the GitHub Consent screen to authorize access.
A summary table will show the information that will be sent to your app.

<figure>
  ![Test connection success](@/assets/docs/guides/social-connections/github-2.png)
</figure>

================
File: guides/integrations/social-connections/gitlab.mdx
================
---
title: GitLab as your sign in option
description: "Learn how to integrate GitLab Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
sidebar:
  order: 4
  label: "GitLab"
tableOfContents:
  maxHeadingLevel: 3
prev:
  label: "GitHub"
  link: /guides/integrations/social-connections/github
next:
  label: "LinkedIn"
  link: /guides/integrations/social-connections/linkedin
---

import { Steps } from '@astrojs/starlight/components';

Scalekit enables apps to easily let users sign in using GitLab as their social connector. This guide walks you through the process of setting up the connection between Scalekit and GitLab, and using the Scalekit SDK to add "Sign in with GitLab" to your application.

<figure>
  ![A diagram showing "Your Application" connecting to "Scalekit" via OpenID Connect, which links to GitLab using OAuth 2.0.](@/assets/docs/common/poster-scalekit-social.png)
</figure>

By the end of this guide, you will be able to:

1. Set up an OAuth 2.0 connection between Scalekit and GitLab
2. Scalekit SDK to add "Sign in with GitLab" to your application

## Set up GitLab connection

### Access social login settings

Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

<figure>
  ![Scalekit dashboard showcasing social login setup with various platform integration options.](@/assets/docs/common/social-connections/1-navigate-to-social-logins.png)
</figure>

### Add GitLab connection

Click the "+ Add Connection" button and select GitLab from the list of available options.

<figure>
  ![Add social login connections: Google, Microsoft, GitHub, GitLab, Salesforce.](@/assets/docs/common/social-connections/2-list-social-logins.png)
</figure>

## Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with GitLab.
- **Client ID** and **Client Secret** are generated by GitLab when you register an OAuth App. They enable Scalekit to
  authenticate your app and establish trust with GitLab.

<figure>
  ![GitLab OAuth configuration for social login, showing redirect URI, client ID, and scopes for
  authentication.](@/assets/docs/guides/social-connections/gitlab-1.png)
</figure>

### Set up GitLab OAuth 2.0

GitLab lets you set up OAuth through the Microsoft Identity Platform.
<a href="https://docs.gitlab.co.jp/ee/integration/oauth_provider.html" target="_blank" rel="noopener">Follow GitLab's instructions to set up OAuth 2.0</a>.

<Steps>
1. Navigate to GitLab's OAuth Applications settings page
2. Click "New Application" to create a new OAuth application
3. Fill in the application details:
   - Name: Your app's name
   - Redirect URI: Use the Redirect URI from Scalekit
   - Scopes: Select the required scopes for your application
4. Click "Save application" to create the OAuth App
5. Copy the generated Application ID and Secret
6. Paste these credentials into the Scalekit Dashboard
7. Click "Save Changes" in Scalekit to complete the setup
</Steps>

<figure>
  ![GitLab OAuth configuration for social login, showing redirect URI, client ID, and scopes for
  authentication.](@/assets/docs/guides/social-connections/gitlab-2.png)
</figure>

## Test the connection

Click the "Test Connection" button in Scalekit. You will be redirected to the GitLab Consent screen to authorize access.
A summary table will show the information that will be sent to your app.

<figure>
  ![Test connection success](@/assets/docs/common/social-connections/5-successful-test-connection.png)
</figure>

================
File: guides/integrations/social-connections/google.mdx
================
---
title: Google as your sign in option
description: "Learn how to integrate Google Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
sidebar:
  order: 1
  label: "Google"
tableOfContents:
  maxHeadingLevel: 3
prev:
  label: "Social login quickstart"
  link: /social-logins/quickstart/
next:
  label: "Microsoft"
  link: /guides/integrations/social-connections/microsoft
---

import { Steps, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

Scalekit enables apps to easily let users sign in using Google as their social connector. This guide walks you through the process of setting up the connection between Scalekit and Google, and using the Scalekit SDK to add "Sign in with Google" to your application.

By the end of this guide, you will be able to:

1. Test Google sign-in without setting up Google OAuth credentials (dev only)
2. Set up an OAuth 2.0 connection between Scalekit and Google
3. Implement 'Sign in with Google' in your application using the Scalekit SDK

## Set up Google connection

### Access social login settings

Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

![Scalekit dashboard showcasing social login setup with various platform integration options.](@/assets/docs/guides/social-connections/google-social/1-navigate-to-social-logins.png)

### Add Google connection

Click the "+ Add Connection" button and select Google from the list of available options.

![Add social login connections: Google, Microsoft, GitHub, GitLab, Salesforce.](@/assets/docs/guides/social-connections/google-social/2-list-social-logins.png)

## Test with Scalekit credentials

For faster development and testing, Scalekit provides pre-configured Google OAuth credentials, allowing you to test the authentication flow without setting up your own Google OAuth client.

This is particularly useful when you want to quickly validate Google sign-in functionality in your app without dealing with OAuth setup. It also helps if you're still in the early stages of development and don't have Google credentials yet, or if you need to test the behavior before setting up a production-ready connection.

Under OAuth Configuration, select **Use Scalekit credentials** and **save** the changes. Once done, you can now directly test the setup by clicking **Test Connection**.

![Use Scalekit credentials to test connection](@/assets/docs/guides/social-connections/google-social/2-1-test-scalekit-credentials.png)

## Set up with your own credentials

### Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with Google.
- **Client ID** and **Client Secret** are generated by Google when you register an OAuth App. They enable Scalekit to authenticate your app and establish trust with Google.

### Get Google OAuth client credentials

<Steps>
1. Open the <a href="https://console.cloud.google.com/" target="_blank" rel="noopener">Google Cloud Platform Console</a>. From the projects list, select an existing project or create a new one.

2. Navigate to the <a href="https://console.cloud.google.com/auth/overview" target="_blank" rel="noopener">Google Auth Platform's overview page</a>.
   - Click **Get Started** and provide details such as app information, audience, and contact information. Complete the process by clicking **Create**.

3. On the "Overview" page, click the **Create OAuth Client** button to start setting up your app's OAuth client.

4. Choose the appropriate application type (e.g., web application) from the dropdown menu.

5. Copy the redirect URI from your Google Social Login configuration and paste it into the **Authorized Redirect URIs** field. The URI should follow this format (for development environment): `https://{your-subdomain}.scalekit.dev`.

6. **Save and retrieve credentials**: Click **Save** to finalize the setup. You will be redirected to a list of Google OAuth Clients. Select the newly created client and copy the **Client ID** and **Client Secret** from the additional information section.

7. **Enter credentials in social login configuration**: Paste the copied client credentials into their respective fields on your Google Social Login page.

8. Click **Test Connection** to simulate and verify the Google Sign-In flow.
</Steps>

<Aside type="note">
- Explore options like branding, audience, clients, and data access to customize your OAuth consent screen for your application's needs.
- Ensure your app's verification status with Google is complete before enabling social login features for users to ensure trustworthiness.
</Aside>
For more details, refer to <a href="https://support.google.com/cloud/answer/6158849" target="_blank" rel="noopener">Google's OAuth guide</a>.

![Google OAuth configuration in Scalekit, showing redirect URI, client credentials, and scopes for social login setup.](@/assets/docs/common/social-connections/3-google-oauth-config.png)

- Use the Redirect URI from Scalekit as the Callback URL in Google's setup
- Copy the generated Client ID and Client Secret into the Scalekit Dashboard

After completing the setup, click "Save Changes" in Scalekit for the changes to take effect.

![Google OAuth configuration for social login, showing redirect URI, client ID, and scopes for authentication.](@/assets/docs/guides/social-connections/google-social/4-after-oauth-config.png)

### Configure login prompt behavior

Scalekit offers flexibility to control how and when users are prompted for reauthentication, consent, or account selection. Below are the available options for customizing user sign-in behavior:

- **Auto sign-in (default)**:
  Automatically completes the login process without showing any confirmation prompts. This is ideal for single Google account users who are already logged in and have previously provided consent.

- **Consent**:
  The authorization server prompts the user for consent before returning information to the client.

- **Select account**:
  The authorization server prompts the user to select a user account. This allows a user who has multiple accounts at the authorization server to select amongst the multiple accounts that they may have current sessions for.

- **None**:
  The authorization server does not display any authentication or user consent screens; it will return an error if the user is not already authenticated and has not pre-configured consent for the requested scopes. You can use none to check for existing authentication and/or consent.

## Verify the connection

Click the "Test Connection" button in Scalekit. You will be redirected to the Google Consent screen to authorize access. A summary table will show the information that will be sent to your app.

![Test connection success](@/assets/docs/guides/social-connections/google-social/5-successful-test-connection.png)

================
File: guides/integrations/social-connections/index.mdx
================
---
title: Social connections
description: Learn how to integrate social login providers with Scalekit to enable secure social authentication for your users.
tableOfContents: false
sidebar:
  order: 1
  label: "Overview"
prev: false
next: false
---

import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';

Scalekit makes it easy to add social login options to your application. This allows your users to sign in using their existing accounts from popular platforms like Google, GitHub, and more.

<CardGrid>
  <LinkCard title="Google" href="/guides/integrations/social-connections/google">
    Enable users to sign in with their Google accounts using OAuth 2.0
  </LinkCard>
  <LinkCard title="GitHub" href="/guides/integrations/social-connections/github">
    Allow users to authenticate using their GitHub credentials
  </LinkCard>
  <LinkCard title="Microsoft" href="/guides/integrations/social-connections/microsoft">
    Integrate Microsoft accounts for seamless user authentication
  </LinkCard>
  <LinkCard title="GitLab" href="/guides/integrations/social-connections/gitlab">
    Enable GitLab-based authentication for your application
  </LinkCard>
  <LinkCard title="LinkedIn" href="/guides/integrations/social-connections/linkedin">
    Let users sign in with their LinkedIn accounts using OAuth 2.0
  </LinkCard>
  <LinkCard title="Salesforce" href="/guides/integrations/social-connections/salesforce">
    Enable Salesforce-based authentication for your application
  </LinkCard>
</CardGrid>

## Benefits of social connections

- **Simplified user experience**: Users can sign in with accounts they already have
- **Reduced friction**: Eliminate the need for users to create and remember new credentials
- **Enhanced security**: Leverage the security measures of established identity providers
- **Rich user profiles**: Access profile information (with user consent) to personalize your application

================
File: guides/integrations/social-connections/linkedin.mdx
================
---
title: LinkedIn as your sign in option
description: "Learn how to integrate LinkedIn Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
sidebar:
  order: 5
  label: "LinkedIn"
tableOfContents:
  maxHeadingLevel: 3
prev:
  label: "GitLab"
  link: /guides/integrations/social-connections/gitlab
next:
  label: "Salesforce"
  link: /guides/integrations/social-connections/salesforce
---

import { Steps } from '@astrojs/starlight/components'

Scalekit enables apps to easily let users sign in using LinkedIn as their social connector. This guide walks you through the process of setting up the connection between Scalekit and LinkedIn, and using the Scalekit SDK to add "Sign in with LinkedIn" to your application.

<figure>
  ![A diagram showing "Your Application" connecting to "Scalekit" via OpenID Connect, which links to LinkedIn using OAuth 2.0.](@/assets/docs/common/poster-scalekit-social.png)
</figure>

By the end of this guide, you will be able to:

1. Set up an OAuth 2.0 connection between Scalekit and LinkedIn
2. Use the Scalekit SDK to add "Sign in with LinkedIn" to your application

## Connect LinkedIn with Scalekit

<Steps>

1. Navigate to social login settings
   Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

   <figure>
     ![Scalekit dashboard showcasing social login setup with various platform integration options.](@/assets/docs/common/social-connections/1-navigate-to-social-logins.png)
   </figure>

2. Add a new LinkedIn connection
   Click the "+ Add Connection" button and select LinkedIn from the list of available options.

</Steps>

## Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with LinkedIn.
- **Client ID** and **Client Secret** are generated by LinkedIn when you register an OAuth App. They enable Scalekit to authenticate your app and establish trust with LinkedIn.

## Set up LinkedIn OAuth 2.0

LinkedIn lets you set up OAuth through the LinkedIn Developer Platform.
<a href="https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow?tabs=HTTPS1" target="_blank">Follow LinkedIn's instructions to set up OAuth 2.0</a>.

<Steps>

1. Use the Redirect URI from Scalekit as the Redirect URI in LinkedIn's setup
2. Copy the generated Client ID and Client Secret into the Scalekit Dashboard
3. Click "Save Changes" in Scalekit for the changes to take effect

</Steps>

<figure>
  ![LinkedIn OAuth configuration for social login, showing redirect URI, client ID, and scopes for authentication.](@/assets/docs/guides/social-connections/linkedin-1.png)
</figure>

## Test the connection

<Steps>

1. Click the "Test Connection" button in Scalekit
2. You will be redirected to the LinkedIn Consent screen to authorize access
3. A summary table will show the information that will be sent to your app

</Steps>

<figure>
  ![Test connection success](@/assets/docs/common/social-connections/5-successful-test-connection.png)
</figure>

================
File: guides/integrations/social-connections/microsoft.mdx
================
---
title: Microsoft as your sign in option
description: "Learn how to integrate Microsoft Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
sidebar:
  order: 2
  label: "Microsoft"
tableOfContents:
  maxHeadingLevel: 3
prev:
  label: "Google"
  link: /guides/integrations/social-connections/google
next:
  label: "GitHub"
  link: /guides/integrations/social-connections/github
---

import { Steps } from '@astrojs/starlight/components'

Scalekit enables apps to easily let users sign in using Microsoft as their social connector. This guide walks you through the process of setting up the connection between Scalekit and Microsoft, and using the Scalekit SDK to add "Sign in with Microsoft" to your application.

<figure>
  ![A diagram showing "Your Application" connecting to "Scalekit" via OpenID Connect, which links to Microsoft using OAuth 2.0.](@/assets/docs/common/poster-scalekit-social.png)
</figure>

By the end of this guide, you will be able to:

1. Set up an OAuth 2.0 connection between Scalekit and Microsoft
2. Use the Scalekit SDK to add "Sign in with Microsoft" to your application

## Connect Microsoft with Scalekit

<Steps>

1. Navigate to social login settings
   Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

   <figure>
     ![Scalekit dashboard showcasing social login setup with various platform integration options.](@/assets/docs/common/social-connections/1-navigate-to-social-logins.png)
   </figure>

2. Add a new Microsoft connection
   Click the "+ Add Connection" button and select Microsoft from the list of available options.

   <figure>
     ![Add social login connections: Google, Microsoft, GitHub, GitLab, Salesforce.](@/assets/docs/common/social-connections/2-list-social-logins.png)
     <figcaption>Add social login connections: Microsoft</figcaption>
   </figure>

</Steps>

## Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with Microsoft.
- **Client ID** and **Client Secret** are generated by Microsoft when you register an OAuth App. They enable Scalekit to authenticate your app and establish trust with Microsoft.

<figure>
  ![Microsoft OAuth configuration in Scalekit, showing redirect URI, client credentials, and scopes for social login setup.](@/assets/docs/guides/social-connections/microsoft-1.png)

</figure>

## Set up Microsoft OAuth 2.0

Microsoft lets you set up OAuth through the Microsoft Identity Platform.
<a href="https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app" target="_blank">Follow Microsoft's instructions to set up OAuth 2.0</a>.

<Steps>

1. Use the Redirect URI from Scalekit as the <a href="https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app?tabs=certificate#add-a-redirect-uri" target="_blank">Redirect URI in Microsoft's setup</a>
2. Copy the generated Client ID and Client Secret into the Scalekit Dashboard
3. Click "Save Changes" in Scalekit for the changes to take effect

</Steps>

<figure>
  ![Microsoft OAuth configuration for social login, showing redirect URI, client ID, and scopes for authentication.](@/assets/docs/guides/social-connections/microsoft-2.png)
</figure>

## Choose the user experience for login prompt

Scalekit offers flexibility to control how and when users are prompted for reauthentication, consent, or account selection. Below are the available options for customizing user sign-in behavior:

- _Auto Sign-in (default)_:
  Automatically completes the login process without showing any confirmation prompts. This is ideal for single account users who are already logged in and have previously provided consent.

- _Consent_:
  The authorization server triggers a consent screen after sign-in, asking the user to grant permissions to the app.

- _Select Account_:
  The authorization server prompts the user to select a user account. This allows a user who has multiple accounts at the authorization server to select amongst the multiple accounts that they may have current sessions for.

- _Login_:
  Forces the user to re-enter their credentials and log in, even if a valid session already exists.

- _None_:
  Performs a background authentication check without displaying any screens. If the user is not authenticated or hasn't provided consent, an error will be returned.

## Test the connection

<Steps>

1. Click the "Test Connection" button in Scalekit
2. You will be redirected to the Microsoft Consent screen to authorize access
3. A summary table will show the information that will be sent to your app

</Steps>

<figure>
  ![Test connection success](@/assets/docs/common/social-connections/5-successful-test-connection.png)
  <figcaption>Test connection success, showing the consent screen and summary table.</figcaption>
</figure>

================
File: guides/integrations/social-connections/salesforce.mdx
================
---
title: Salesforce as your sign in option
sidebar:
  order: 6
  label: "Salesforce"
tableOfContents:
  maxHeadingLevel: 3
description: "Learn how to integrate Salesforce Sign-In with Scalekit, enabling secure social authentication for your users with step-by-step OAuth configuration instructions."
prev:
  label: "LinkedIn"
  link: /guides/integrations/social-connections/linkedin
next: false
---

import { Steps } from '@astrojs/starlight/components';

Scalekit enables apps to easily let users sign in using Salesforce as their social connector. This guide walks you through the process of setting up the connection between Scalekit and Salesforce, and using the Scalekit SDK to add "Sign in with Salesforce" to your application.

<figure>
  ![A diagram showing "Your Application" connecting to "Scalekit" via OpenID Connect, which links to Salesforce using OAuth 2.0.](@/assets/docs/common/poster-scalekit-social.png)
</figure>

By the end of this guide, you will be able to:

1. Set up an OAuth 2.0 connection between Scalekit and Salesforce
2. Implement "Sign in with Salesforce" in your application using the Scalekit SDK

## Set up Salesforce connection

### Access social login settings

Open your Scalekit dashboard and navigate to Social Login under the Authentication section.

<figure>
  ![Scalekit dashboard showcasing social login setup with various platform integration options.](@/assets/docs/common/social-connections/1-navigate-to-social-logins.png)
</figure>

### Add Salesforce connection

Click the "+ Add Connection" button and select Salesforce from the list of available options.

<figure>
  ![Add social login connections: Google, Microsoft, GitHub, Salesforce.](@/assets/docs/common/social-connections/2-list-social-logins.png)
  <figcaption>Add social login connections: Salesforce</figcaption>
</figure>

## Configure OAuth settings

The OAuth Configuration details page helps you set up the connection:

- Note the **Redirect URI** provided for your app. You'll use this URL to register with Salesforce.
- **Client ID** and **Client Secret** are generated by Salesforce when you register an OAuth App. They enable Scalekit
  to authenticate your app and establish trust with Salesforce.

<figure>
  ![Salesforce OAuth configuration in Scalekit, showing redirect URI, client credentials, and scopes for social login setup.](@/assets/docs/guides/social-connections/salesforce-1.png)
</figure>

### Set up Salesforce OAuth 2.0

Salesforce lets you set up OAuth through the Microsoft Identity Platform.
<a href="https://dub.sh/connected-app-create-salesforce" target="_blank" rel="noopener">Follow Salesforce's instructions to set up OAuth 2.0</a>

<Steps>
1. Use the Redirect URI from Scalekit as the Redirect URI in Salesforce's setup. The URI should follow this format:
   - Development: `https://{your-subdomain}.scalekit.dev`
   - Production: `https://{your-subdomain}.scalekit.com`

2. Copy the generated Client ID and Client Secret into the Scalekit Dashboard

3. Click "Save Changes" in Scalekit for the changes to take effect
</Steps>

## Test the connection

Click the "Test Connection" button in Scalekit. You will be redirected to the Salesforce Consent screen to authorize
access. A summary table will show the information that will be sent to your app.

<figure>
  ![Test connection success](@/assets/docs/common/social-connections/5-successful-test-connection.png)
</figure>

================
File: guides/integrations/sso-integrations/azure-ad-saml.mdx
================
---
title: "Azure AD SAML"
prev: false
next: false
description: "Learn how to set up SAML-based Single Sign-On (SSO) in Scalekit using Microsoft Entra ID (Azure AD), with step-by-step instructions for enterprise application configuration."

sidebar:
  order: 3
  label: "Microsoft Entra ID"
  badge:
    variant: note
    text: SAML
---

import { Steps, Aside } from "@astrojs/starlight/components"

> Step-by-step guide to configure Single Sign-On with Microsoft Entra ID as the identity provider

This guide walks you through configuring Microsoft Entra ID as your SAML identity provider for the application you are onboarding, enabling secure Single Sign-On for your users. You'll learn how to set up an enterprise application, configure SAML settings, map user attributes, and assign users to the application. By following these steps, your users will be able to seamlessly authenticate using their Microsoft Entra ID credentials.

## Download metadata XML

<Steps>
1. Sign into the SSO Configuration Portal, select **Microsoft Entra ID**, then **SAML**, and click on **Configure**

   Under **Service Provider Details**, click on **Download Metadata XML**

   ![Download Metadata XML](@/assets/docs/guides/sso-integrations/azure-ad-saml/0.png)
</Steps>

## Create enterprise application

<Steps>
1. Login to **Microsoft Entra ID** in the <a href="https://portal.azure.com/" target="_blank">Microsoft Azure Portal</a>. Select the option for **Entra ID application** and locate the **Enterprise Applications** tab

   ![Locate Enterprise applications](@/assets/docs/guides/sso-integrations/azure-ad-saml/1.png)

2. In the **Enterprise Applications** tab **New Application** in the top navigation bar

   ![Click on New application](@/assets/docs/guides/sso-integrations/azure-ad-saml/2.png)

3. Click on **Create your own Application** and give your application a name

   Select the **_Integrate any other application you don't find in the gallery (Non-gallery)_** option. Click on **Create**

   ![Create a new application on Entra ID](@/assets/docs/guides/sso-integrations/azure-ad-saml/3.gif)
</Steps>

## Configure SAML settings

<Steps>
1. Locate the **Single Sign-On** option under **Manage**, and choose **SAML**

   ![Locate SAML under Single sign-on](@/assets/docs/guides/sso-integrations/azure-ad-saml/4.png)

2. Click on **Upload metadata file**. Upload the **Metadata XML file** downloaded in step 1

   ![Click on Upload metadata file](@/assets/docs/guides/sso-integrations/azure-ad-saml/4-5.png)

3. Click on **Save**

   ![Save button](@/assets/docs/guides/sso-integrations/azure-ad-saml/5.png)
</Steps>

## Map user attributes

<Steps>
1. Under **Attributes & Claims**, click on **Edit**

   ![Click on Edit](@/assets/docs/guides/sso-integrations/azure-ad-saml/6.png)

2. Check the **Attribute Mapping** section in the **SSO Configuration Portal**, and carefully map the same attributes on your **Entra ID** app

   ![SSO Configuration Portal](@/assets/docs/guides/sso-integrations/azure-ad-saml/7.png)
   ![Microsoft Entra ID](@/assets/docs/guides/sso-integrations/azure-ad-saml/8.png)
</Steps>

## Assign users and groups

<Steps>
1. Go to the **Users and groups** tab, and click on **Add user/group**

   Here, please select all the required users or user groups that need login access to this application via Single Sign-On

   ![Assigning users and groups to your application](@/assets/docs/guides/sso-integrations/azure-ad-saml/9.gif)
</Steps>

## Configure metadata URL

<Steps>
1. Under **SAML Certification**, copy the link under **App Federation Metadata URL on Entra ID**

   ![Copy App Federation Metadata URL](@/assets/docs/guides/sso-integrations/azure-ad-saml/10.png)

2. Under **Identify Provider Configuration**, select **Configure using Metadata URL**, and paste it under **App Federation Metadata URL** on the **SSO Configuration Portal**

   ![Paste App Federation Metadata URL](@/assets/docs/guides/sso-integrations/azure-ad-saml/11.png)
</Steps>

## Test the connection

Click on **Test Connection**. If everything is done correctly, you will see a **Success** response as shown below.

![Test your SAML application for SSO](@/assets/docs/guides/sso-integrations/azure-ad-saml/12.png)

<Aside type="note">
If the connection fails, you'll see an error, the reason for the error, and a way to solve that error right on the screen.
</Aside>

## Enable the connection

Click on **Enable Connection**. This will let all your selected users login to the new application via your Microsoft Entra ID SSO.

![Enable SSO on Entra ID](@/assets/docs/guides/sso-integrations/azure-ad-saml/13.png)

With this, we are done configuring your Microsoft Entra ID application for an SSO login setup.

================
File: guides/integrations/sso-integrations/generic-oidc.mdx
================
---
title: "Generic OIDC"
description: "Learn how to configure a generic OIDC identity provider for secure single sign-on (SSO) with your application using Scalekit."
prev: false
next: false
sidebar:
  order: 7
  label: "Generic provider"
  badge:
    variant: note
    text: OIDC
---

import { Steps } from "@astrojs/starlight/components";

This guide walks you through configuring a generic OIDC identity provider for your application, enabling secure single sign-on for your users. You'll learn how to set up OIDC integration, configure client credentials, and test the connection.

<Steps>
1. ### Configure OIDC

   Sign into the SSO Configuration Portal, select **Custom Provider**, then **OIDC,** and click on **Configure.**

   ![Select Custom Provider→OIDC and then Configure](@/assets/docs/guides/sso-integrations/oidc-custom-provider/0.png)

   Copy the **Redirect URl** from the **SSO Configuration Portal**.

   ![Copy Redirect URI](@/assets/docs/guides/sso-integrations/oidc-custom-provider/1.png)

   On your Identity Provider portal, select OIDC as the integration method, and Web Applications as application type.

   Paste this Redirect URI in the sign in redirect URI space on your identity provider portal.

2. ### Configure Attribute mapping

   On your identity provider portal, if attribute mapping is required, map the given attributes exactly as shown below.

   :::tip

   Usually, you don't have to configure any attributes and by default - most identity providers support standard OIDC claims to send user information as part of ID Token or User Info endpoint.

   :::

   ![Map exact attributes shown](@/assets/docs/guides/sso-integrations/oidc-custom-provider/2.png)

3. ### Assign users/groups

   Choose who can access the app by assigning users to your app on your identity provider portal.

4. ### Configure Identity Provider

   Find the client ID from your identity provider portal. Paste this in the space for Client ID on your SSO Configuration Portal.

   ![Enter copied Client ID in the SSO Configuration Portal](@/assets/docs/guides/sso-integrations/oidc-custom-provider/3.png)

   Similarly, generate and copy the Client Secret from your SSO Configuration Portal and paste it under Client Secret under IdP Configuration.

   ![Enter copied Client Secret in the SSO Configuration Portal](@/assets/docs/guides/sso-integrations/oidc-custom-provider/4.png)

   Find and copy the Issuer URL from your custom provider's portal. Paste the above URL in the **SSO configuration Portal** under **Issuer URL**. Click on Update.

   ![Enter copied Issuer URL, and click Update](@/assets/docs/guides/sso-integrations/oidc-custom-provider/5.png)

   :::info
   We support configuring Issuer URL field with Discovery Endpoint also.

   Discovery Endpoints usually end with ./well-known/openid-configuration
   :::

5. ### Finalize application

   Your IdP configuration section on the SSO Configuration Portal should look something like this once you're done configuring it.

   ![Completed view of IdP configuration on the SSO Configuration Portal](@/assets/docs/guides/sso-integrations/oidc-custom-provider/6.png)

6. ### Test connection

   Click on **Test Connection.** If everything is done correctly, you will see a **Success** response as shown below.

   If the connection fails, you'll see an error, the reason for the error, and a way to solve that error right on the screen.

   ![Test SSO Configuration](@/assets/docs/guides/sso-integrations/oidc-custom-provider/7.png)

7. ### Enable connection

   Click on **Enable Connection.** This will let all your selected users login to the new application via OIDC.

   ![Enable OIDC Connection](@/assets/docs/guides/sso-integrations/oidc-custom-provider/8.png)

   With this, we are done configuring your application for an OIDC login setup.
</Steps>

================
File: guides/integrations/sso-integrations/generic-saml.mdx
================
---
title: "Generic SAML"
description: "Learn how to configure a generic SAML identity provider for secure single sign-on (SSO) with your application using Scalekit."
prev: false
next: false
sidebar:
  order: 6
  label: "Generic provider"
  badge:
    variant: note
    text: SAML
---

import { Steps } from "@astrojs/starlight/components";

This guide walks you through configuring a generic SAML identity provider for your application, enabling secure single sign-on for your users. You'll learn how to set up a SAML application, configure service provider and identity provider settings, and test the connection.

<Steps>
1. ### Create a SAML application

   Login to your Identity Provider portal as an admin and create a new Application with SAML as the single sign-on method.

2. ### Configure the Service Provider

   Depending on your Identity Provider, they may allow you to configure **Service Provider section** in your SAML application via either of the three following methods:

   - via SAML Metadata URL
   - via SAML Metadata file
   - via copying ACS URL and Entity ID manually

   #### via SAML Metadata URL

   Copy the **Metadata URL** content in your Identity Provider portal

   #### via SAML Metadata File

   Under **Service Provider Details,** click on **Download Metadata XML** and upload in your Identity Portal

   ![Download Metadata XML](@/assets/docs/guides/sso-integrations/saml-custom-provider/0.png)

   #### via Manual Configuration

   Copy the **ACS URL (Assertion Consumer Service)** and **Service Provider Entity ID** from the Service Provider Details section and paste them in the appropriate sections in your Identity Provider Portal.

3. ### Configure Attribute mapping & assign users/groups

   #### Attribute mapping

   SAML Attributes need to be configured in your Identity Provider portal so that the user profile details are shared with us at the time of user login as part of SAML Response payload.

   User profile details that are needed for seamless user login are:

   - Email Address of the user
   - First Name of the user
   - Last Name of the user

   To configure these attributes, locate **Attribute Settings** section in the SAML Configuration page in your Identity Provider's application, and carefully map the attributes with the Attribute names exactly as shown in the below image.

   ![Attribute Mapping section in SSO Configuration Portal](@/assets/docs/guides/sso-integrations/saml-custom-provider/1.png)

   #### Assign user/group

   To finish the Service Provider section of the SAML configuration, you need to "Assign" the users who need to access to this application.

   Find the User/Group assignment section in your Identity Provider application and select and assign all the required users or user groups that need access to this application via Single Sign-on.

4. ### Configure Identity Provider

   After you have completed the Service Provider configuration, you now need to configure the Identity Provider details in our SSO Configuration page.

   Depending on your Identity Provider, you can choose either of the below methods:

   - Automated Configuration (configuration via Metadata URL)
   - Manual Configuration (configuration via individual fields)

   #### Automated Configuration (recommended)

   :::info

   If you supply the Identity Provider Metadata URL, our system will automatically fetch the necessary configuration details required like Login URL, Identity Provider Entity ID, X.509 Certificate to complete the SAML SSO configuration.

   Also, we will periodically scan this url to keep the configuration up-to-date incase any of this information changes in your Identity Provider reducing the manual effort needed from your side.

   :::

   Locate and copy the Identity Provider Metadata URL from your Identity Provider's application.

   Under **Identify Provider Configuration,** select **Configure using Metadata URL,** and paste it under **Metadata URL** on the **SSO Configuration Portal.**

   ![Paste Issuer URL on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/saml-custom-provider/2.png)

   #### Manual Configuration

   1. Choose "Configure Manually" option in the "Identity Provider Configuration" section
   2. Carefully copy the below configuration details from your Identity Provider section and paste them in the appropriate fields:
      - Issuer (also referred to as Identity Provider Entity ID)
      - Sign-on URL (also referred to as SSO URL or Single Sign-on URL)
      - Signing Certificate (also referred to as X.509 certificate)
        - You can also upload the certificate file instead of copying the contents manually.

5. ### Test Single Sign-on

   To verify whether the SAML SSO configuration is completed correctly, click on **Test Connection** on the SSO Configuration Portal.

   If everything is done correctly, you will see a **Success** response as shown below.

   ![Test your SAML application for SSO configuration](@/assets/docs/guides/sso-integrations/saml-custom-provider/3.png)

   If there's a misconfiguration, our test will identify the errors and will offer you a way to correct the configuration right on the screen.

6. ### Enable Single Sign-on

   After you successfully verified that the connection is configured correctly, you can enable the connection to let your users login to this application via Single Sign-on.

   Click on **Enable Connection.**

   ![Enable Single Sign-on](@/assets/docs/guides/sso-integrations/saml-custom-provider/4.png)

   With this, we are done configuring your application for an SSO login setup.
</Steps>

================
File: guides/integrations/sso-integrations/google-saml.mdx
================
---
title: Google Workspace
description: "Learn how to configure Google Workspace as a SAML identity provider for secure single sign-on (SSO) with your application using Scalekit."
tableOfContents:
  maxHeadingLevel: 4
sidebar:
  order: 4
  label: "Google Workspace"
  badge:
    variant: note
    text: SAML
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }

---

import { Aside, Steps } from '@astrojs/starlight/components'

This guide walks you through configuring Google Workspace as your SAML identity provider for the application you are onboarding, enabling secure single sign-on for your users. You'll learn how to set up an enterprise application and configure SAML settings to the host application. By following these steps, your users will be able to seamlessly authenticate using their Google Workspace credentials.

<Steps>

1. ## Create a custom SAML app in Google Workspace

   Google allows you to add custom SAML applications that connect with Scalekit over the SAML protocol. This is the first step in establishing a secure SSO connection.

   **Prerequisites:** You need a super administrator account in Google Workspace to complete these steps.

   1. Go to Google **Admin console** (`admin.google.com`)
   2. Select **Apps** → **Web and mobile apps**
   3. Click **Add app** → **Add custom SAML app**
   4. Provide an app name (e.g., "YourApp") and upload an app icon if needed
   5. Click **Continue**

   ![Custom SAML app](@/assets/docs/guides/sso-integrations/google-saml/0-google-saml.png)
   *Creating a new custom SAML application in Google Workspace*

   **Get Google identity provider details:**

   On the **Google identity provider details** page, you'll need to collect setup information for Scalekit. You can either:
   - Download the **IDP metadata** file, or
   - Copy the **SSO URL** and **Entity ID** and download the **Certificate**

   Your SSO config portal connects with Google IdP using three essential pieces of information:
   - **SSO URL**
   - **Entity ID**
   - **Certificate**

   Copy these values from the Google console and paste them into your config portal.

   ![Google IdP Details](@/assets/docs/guides/sso-integrations/google-saml/0.1-google-saml.png)
   *Essential SAML configuration details from Google Workspace*

   **Note:** Keep this page open as you'll need to return to it after configuring Scalekit's service provider details.

2. ## Configure the service provider in Google Admin console

   In your SSO configuration portal:
   1. Navigate to Single sign-on (SSO) → Google Workspace → SAML 2.0
   2. Select the organization you want to configure
   3. Copy these critical details from the SSO settings:
      - **ACS URL** (Assertion consumer service URL)
      - **SP Entity ID** (Service provider entity ID)
      - **SP Metadata URL**

   ![SSO Config Portal](@/assets/docs/guides/sso-integrations/google-saml/1-google-saml.png)
   *Service provider configuration details in SSO portal*

   In Google Admin console:
   1. Paste the copied details into their respective fields
   2. Select **"Email"** as the **NameID format** (this serves as the primary user identifier during authentication)
   3. Click **Continue**

   ![Google Workspace](@/assets/docs/guides/sso-integrations/google-saml/1.1-google-saml.png)
   *Configuring service provider details in Google Workspace*

3. ## Configure attribute mapping

   User profile attributes in Google IdP need to be mapped to your application's user attributes for seamless authentication. The essential attributes are:

   - Email address
   - First name
   - Last name

   To configure these attributes:
   1. Locate the **Attribute mapping** section in your identity provider's application
   2. Map the Google attributes to your application attributes as shown below

   ![User profile attributes](@/assets/docs/guides/sso-integrations/google-saml/2.1-google-saml.png)
   *Mapping user attributes between Google Workspace and your application*

4. ## Assign users and groups

   Control access to your application by assigning specific users or groups:

   1. Go to the **User/group assignment** section in your identity provider application
   2. Select and assign the user groups that need access to your application via SSO

   ![Group assignment](@/assets/docs/guides/sso-integrations/google-saml/2.2-google-saml.png)
   *Assigning user groups for SSO access*

5. ## Configure identity provider in SSO portal

   **Copy Google identity provider details:**

   From your Google Workspace, copy the IdP details shown during custom app creation:

   ![Google IdP details](@/assets/docs/guides/sso-integrations/google-saml/3.1-google-saml.png)
   *Identity provider details from Google Workspace*

   **Update Scalekit configuration:**

   In your SSO configuration portal, navigate to the Identity provider configuration section. Paste the Google IdP details into the appropriate fields: Entity ID, SSO URL, and x509 certificates.

   ![Update IdP details in SSO config portal](@/assets/docs/guides/sso-integrations/google-saml/3.2-google-saml.png)
   *Updating identity provider configuration in SSO portal*

   Click **Update** to save the configuration.

6. ## Test the connection

   Verify your SAML SSO configuration:

   1. Click **Test connection** in the SSO configuration portal
   2. If successful, you'll see a confirmation message:

   ![Test Single Sign On](@/assets/docs/guides/sso-integrations/google-saml/4-google-saml.png)
   *Successful SSO connection test*

   If there are any configuration issues, the test will identify them and provide guidance for correction.

7. ## Enable SSO connection

   Once you've verified the configuration:

   1. Click **Enable connection** to activate SSO for your users

   ![Enable SSO Connection](@/assets/docs/guides/sso-integrations/google-saml/5-google-saml.png)
   *Enabling the SSO connection*

8. ## Test SSO functionality

   After enabling the connection, test both types of SSO flows to ensure everything works correctly:

   **Identity provider (IdP) initiated SSO:**
   1. In Google Admin console, go to **Apps** → **Web and mobile apps**
   2. Select your custom SAML app
   3. Click **Test SAML login** at the top left
   4. Your app should open in a separate tab with successful authentication

   **Service provider (SP) initiated SSO:**
   1. Open the SSO URL for your SAML app
   2. You should be automatically redirected to the Google sign-in page
   3. Enter your Google Workspace credentials
   4. After successful authentication, you'll be redirected back to your application

   **Troubleshooting:** If either test fails, check the SAML app error messages and verify your IdP and SP settings match exactly.

</Steps>

Congratulations! You have successfully configured Google SAML for your application. Your users can now securely authenticate using their Google Workspace credentials through single sign-on.

<Aside type="note" title="Google Workspace SSO resources">
For more detailed information about setting up custom SAML apps in Google Workspace, refer to the [official Google Workspace documentation](https://support.google.com/a/answer/6087519).
</Aside>

================
File: guides/integrations/sso-integrations/index.mdx
================
---
title: SSO Integrations
description: Learn how to integrate with Scalekit's SSO feature.
sidebar:
  label: List of SSO integrations
  order: 1
tableOfContents: false
next: false
---

Scalekit provides seamless integration with all major identity providers (IdPs) to enable Single Sign-On for your application. Below you'll find detailed guides for setting up SSO with popular providers like Okta, Microsoft Entra ID (formerly Azure AD), Google Workspace, JumpCloud, and more. Each guide walks you through the step-by-step process of configuring your IdP and connecting it to Scalekit, allowing you to quickly implement enterprise-grade authentication for your users.

<br />
import { LinkCard, CardGrid } from '@astrojs/starlight/components';
import { SSOIntegrationsSection } from '@/components/templates';

<SSOIntegrationsSection />

================
File: guides/integrations/sso-integrations/jumpcloud-saml.mdx
================
---
title: "JumpCloud SAML"
description: "Learn how to configure JumpCloud as a SAML identity provider for secure single sign-on (SSO) with your application using Scalekit."
prev: false
next: false
sidebar:
  order: 4
  label: "JumpCloud"
  badge:
    variant: note
    text: SAML
---

import { Aside, Steps } from '@astrojs/starlight/components';

This guide walks you through configuring JumpCloud as your SAML identity provider for the application you are onboarding, enabling secure single sign-on for your users. You'll learn how to set up an enterprise application, configure SAML settings to the host application. By following these steps, your users will be able to seamlessly authenticate using their JumpCloud credentials.

## Download metadata XML

Sign into the SSO Configuration Portal, select **JumpCloud,** then **SAML,** and click on **Configure**

Under **Service Provider Details,** click on **Download Metadata XML**

![Download Metadata XML](@/assets/docs/guides/sso-integrations/jumpcloud-saml/0.png)

## Create enterprise application

<Steps>
1. Login to your JumpCloud Portal and go to **SSO Applications**

   ![Locate SSO Applications](@/assets/docs/guides/sso-integrations/jumpcloud-saml/1.png)

2. Click on **Add New Application**

   ![Click on Add New Application](@/assets/docs/guides/sso-integrations/jumpcloud-saml/2.png)

3. In the **Create New Application Integration** search box:
   - Type **Custom SAML App**
   - Select it from the drop down list
   - Give your app a name
   - Select your icon (optional)
   - Click on **Save**

   ![Create and save a new application integration](/images/docs/guides/sso-integrations/jumpcloud-saml/2-5.gif)

4. Click on **Configure Application**

   ![Click on Configure application](@/assets/docs/guides/sso-integrations/jumpcloud-saml/3.png)
</Steps>

## SAML configuration

<Steps>
1. Go to the **SSO** tab and upload the downloaded Metadata XML under **Service Provider Metadata→ Upload Metadata**

   ![Upload Metadata XML under Service Provider Metadata](@/assets/docs/guides/sso-integrations/jumpcloud-saml/4.png)

2. Copy the **SP Entity ID** from your SSO Configuration Portal and paste it in both the **IdP Entity ID** and **SP Entity ID** fields on JumpCloud Portal

   ![Copy SP Entity ID from your SSO Configuration Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/5.png)
   ![Paste it under IdP Entity ID and SP Entity ID on JumpCloud Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/6.png)

3. Configure ACS URL:
   - Copy the **ACS URL** from your SSO Configuration Portal
   - Go to the **ACS URLs** section in JumpCloud Portal
   - Paste it in the **Default URL** field

   ![Copy ACS URL from SSO Configuration Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/7.png)
   ![Paste it under Default URL on JumpCloud Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/8.png)
</Steps>

## Attribute mapping

<Steps>
1. In the SSO tab, scroll to find **Attributes**

   ![Locate Attributes section on JumpCloud Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/9.png)

2. Map the attributes:
   - Check the **Attribute Mapping** section in the SSO Configuration Portal
   - Map the same attributes on your JumpCloud application

   ![Attribute mapping from SSO Configuration Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/10.png)
   ![Attribute Mapping on JumpCloud Portal](/images/docs/guides/sso-integrations/jumpcloud-saml/10-5.gif)
</Steps>

## Assign users

Go to the **User Groups** tab. Select appropriate users/groups you want to assign to this application, and click on **Save** once done.

![Assign individuals or groups to your application](@/assets/docs/guides/sso-integrations/jumpcloud-saml/11.png)

## Upload IdP metadata URL

<Steps>
1. On your JumpCloud Portal, click on **SSO** and copy the **Copy Metadata URL**

   ![Copy Metadata URL from your JumpCloud portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/12.png)

2. Configure the metadata URL:
   - Under **Identify Provider Configuration**, select **Configure using Metadata URL**
   - Paste it under **App Federation Metadata URL** on the SSO Configuration Portal

   ![Paste Metadata URL on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/jumpcloud-saml/13.png)
</Steps>

## Test connection

Click on **Test Connection**. If everything is done correctly, you will see a **Success** response as shown below.

If the connection fails, you'll see an error, the reason for the error, and a way to solve that error right on the screen.

![Test SSO configuration](@/assets/docs/guides/sso-integrations/jumpcloud-saml/14.png)

## Enable connection

Click on **Enable Connection**. This will let all your selected users login to the new application via your JumpCloud SSO.

![Enable SSO on JumpCloud](@/assets/docs/guides/sso-integrations/jumpcloud-saml/15.png)

<Aside type="note">
You can access the SSO Configuration Portal at <a href="https://your-subdomain.scalekit.dev" target="_blank">https://your-subdomain.scalekit.dev</a> (Development) or <a href="https://your-subdomain.scalekit.com" target="_blank">https://your-subdomain.scalekit.com</a> (Production)
</Aside>

================
File: guides/integrations/sso-integrations/microsoft-ad-fs.mdx
================
---
title: "Microsoft AD FS"
description: "Learn how to configure Microsoft AD FS as a SAML identity provider for secure single sign-on (SSO) with your application using Scalekit."
prev: false
next: false
sidebar:
  order: 5
  label: "Microsoft AD FS"
  badge:
    variant: note
    text: SAML
---

import { Steps, Aside, Badge } from "@astrojs/starlight/components"

This guide walks you through configuring Single Sign-On (SSO) with Microsoft Active Directory Federation Services (AD FS) as your Identity Provider.

####  Before you begin

To successfully set up AD FS SAML integration, you'll need:

- Elevated access to your AD FS Management Console
- Access to the Admin Portal of the application you're integrating Microsoft AD FS with

<Aside type="tip">
  Having these prerequisites ready before starting will make the configuration process smoother
</Aside>

## Configuration steps

<Steps>

1. #### Begin the configuration

   Choose Microsoft AD FS as your identity provider

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/-1-1.png)

   Download Metadata XML file so that you can configure AD FS Server going forward

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/-1.png)

2. #### Open AD FS Management Console
   - Launch Server Manager
   - Click 'Tools' in the top menu
   - Select 'AD FS Management'

3. #### Create a Relying Party Trust
   - In the left navigation pane, expand 'Trust Relationships'
   - Right-click 'Relying Party Trusts'
   - Select 'Add Relying Party Trust'
   - Click 'Start' to begin the configuration

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/0-1.png)

4. #### Configure Trust Settings
   - Select 'Claims aware' as the trust type
   - Choose 'Enter data about the relying party manually'
   - Click 'Next' to proceed

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/2.png)

   Import the Metadata XML file that you downloaded earlier

   <Aside type="note">
     You can configure the relying party trust using either of these methods:
     - Enter the Metadata URL directly (if network access allows)
   </Aside>

5. #### Set Display Name
   - Enter a descriptive name for your application (e.g., "ExampleApp")
   - Click 'Next' to continue

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/3.png)

6. #### Configure Access Control
   - Select an appropriate access control policy
   - For purposes of this guide, select 'Permit everyone'
   - Click 'Next' to proceed

7. #### Review Trust Configuration
   - Verify the following settings:
     - Monitoring configuration
     - Endpoints
     - Encryption settings
   - Click 'Next' to continue

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/5.png)

   The wizard will complete with the 'Edit Claim Issuance Policy' option automatically selected

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/6.png)

8. #### Create Claim Rules
   - Click 'Add Rule' to create a new claim rule
   - Select 'Send LDAP Attributes as Claims' template

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/7.png)
   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/8.png)

9. #### Map User Attributes
   - Enter a descriptive rule name (e.g., "Example App")
   - Configure the following attribute mappings:
     - `E-Mail-Addresses` → E-Mail Address
     - `Given-Name` → Given Name
     - `Surname` → Surname
     - `User-Principal-Name` → Name ID
   - Click 'Finish' to complete the mapping

   ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/9.png)

10. #### Complete Admin Portal Configuration
    - Navigate to Identity Provider Configuration in the Admin Portal
    - Select "Configure Manually"
    - The above endpoints are AD FS endpoints. You can find them listed in AD FS Console > Service > Endpoints > Tokens and Metadata sections. Enter these required details:
      - Microsoft AD FS Identifier: `http://<your-adfs-server-domain>/adfs/services/trust`
      - Login URL: `http://<your-adfs-server-domain>/adfs/ls`
      - Certificate:
        1. Access <a href="https://<your-adfs-server-domain>/FederationMetadata/2007-06/FederationMetadata.xml" target="_blank">Federation Metadata URL</a>
        2. Locate the text after the first `X509Certificate` tag
        3. Copy and paste this certificate into the "Certificate" field
    - Click "Update" to save the configuration

    ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/12-1.png)

11. #### Test the Integration
    - In the Admin Portal, click "Test Connection"
    - You will be redirected to the AD FS login page
    - Enter your AD FS credentials
    - Verify successful redirection back to the Admin Portal with the correct user attributes

    ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/13.png)

12. #### Enable Connection
    - Click on **Enable Connection**
    - This will let all your selected users login to the new application via your AD FS SSO

    ![](@/assets/docs/guides/sso-integrations/microsoft-ad-fs/14.png)

</Steps>

================
File: guides/integrations/sso-integrations/okta-saml.mdx
================
---
title: "Okta SAML"
prev: false
next: false
description: "Learn how to set up SAML-based Single Sign-On (SSO) in Scalekit using Okta as your Identity Provider, with step-by-step instructions for enterprise application configuration."
sidebar:
  order: 2
  label: "Okta"
  badge:
    variant: note
    text: SAML
---

import { Steps, Aside } from "@astrojs/starlight/components"



This guide walks you through configuring Okta as your SAML identity provider for the application you are onboarding, enabling secure single sign-on for your users. You'll learn how to set up an enterprise application, configure SAML settings to the host application. By following these steps, your users will be able to seamlessly authenticate using their Okta credentials.

## Create Enterprise Application

<Steps>
1. Login to your _Okta Admin Console_. Go to _Applications→ Applications_.

   ![](@/assets/docs/guides/sso-integrations/okta-saml/0.png)

2. In the **Applications** tab, click on **Create App Integration.**

   ![](@/assets/docs/guides/sso-integrations/okta-saml/1.png)

3. Choose **SAML 2.0**, and click on **Next.**

   ![](@/assets/docs/guides/sso-integrations/okta-saml/2.png)

4. Give your app a name, choose your app visibility settings, and click on **Next.**

   ![](@/assets/docs/guides/sso-integrations/okta-saml/3.png)

</Steps>

## SAML Configuration

<Steps>
1. Copy the **SSO URL** from the **SSO Configuration Portal**. Paste this link in the space for **SSO URL** on the **Okta Admin Console**.

   ![](@/assets/docs/guides/sso-integrations/okta-saml/4.png)
   ![](@/assets/docs/guides/sso-integrations/okta-saml/5.png)

2. Copy the **Audience URI (SP Entity ID)** from the SSO Configuration Portal, and paste it in your **Okta Admin Console** in the space for **Audience URI.**

   ![](@/assets/docs/guides/sso-integrations/okta-saml/6.png)
   ![](@/assets/docs/guides/sso-integrations/okta-saml/7.png)

3. You can leave the Default Relay State as blank. Similarly, select your preferences for the Name ID format, Application Username, and Update application username on fields.

   ![](@/assets/docs/guides/sso-integrations/okta-saml/8.png)

</Steps>

## Attribute Mapping

Check the **Attribute Mapping** section in the **SSO Configuration Portal**, and carefully map the same attributes on your Okta Admin Console.

![Attribute mapping on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/okta-saml/9.png)
![Attribute mapping on Okta Admin Console](@/assets/docs/guides/sso-integrations/okta-saml/10.png)

## Assign User/Group

<Steps>
1. Go to the **Assignments** tab.

   ![Locate Assignments tab](@/assets/docs/guides/sso-integrations/okta-saml/11.png)

2. Click on **Assign** on the top navigation bar, select **Assign to People/Groups.**

   ![Select Assign to People or Groups](@/assets/docs/guides/sso-integrations/okta-saml/12.png)

3. Click on **Assign** next to the people you want to assign it to. Click on **Save and Go Back**, and click on **Done.**

   ![Assign specific individuals or groups to app](@/assets/docs/guides/sso-integrations/okta-saml/13.png)

</Steps>

## Finalize App

<Steps>
1. Preview your SAML Assertion generated, and click on **Next.**

   ![Preview SAML Assertion](@/assets/docs/guides/sso-integrations/okta-saml/14.png)

2. Fill the feedback form, and click on **Finish** once done.

   ![Feedback form after configuring SAML](@/assets/docs/guides/sso-integrations/okta-saml/15.png)

</Steps>

## Upload IdP Metadata URL

<Steps>
1. On the **Sign On** tab copy the **Metadata URL** from the **Metadata Details** section on **Okta Admin Console.**

   ![Copy Metadata URL from Okta Admin Console](@/assets/docs/guides/sso-integrations/okta-saml/16.png)

2. Under **Identify Provider Configuration,** select **Configure using Metadata URL,** and paste it under **App Federation Metadata URL** on the **SSO Configuration Portal.**

   ![Paste Metadata URL on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/okta-saml/17.png)

</Steps>

## Test Connection

Click on **Test Connection.** If everything is done correctly, you will see a **Success** response as shown below.

![Test SSO configuration](@/assets/docs/guides/sso-integrations/okta-saml/18.png)

<Aside type="note">
If the connection fails, you'll see an error, the reason for the error, and a way to solve that error right on the screen.
</Aside>

## Enable Connection

Click on **Enable Connection.** This will let all your selected users login to the new application via your Okta SSO.

![Enable SSO on Okta Admin Console](@/assets/docs/guides/sso-integrations/okta-saml/19.png)

With this, we are done configuring your Okta application for an SSO login setup.

================
File: guides/integrations/sso-integrations/onelogin-saml.mdx
================
---
title: "OneLogin SAML"
description: "A step-by-step guide to setting up Single Sign-On with OneLogin as the Identity Provider, including creating an enterprise application, configuring SAML, attribute mapping, assigning users, uploading IdP metadata, testing the connection, and enabling SSO."
keywords:
  [
    'OneLogin SAML',
    'Single Sign-On',
    'SSO',
    'Identity Provider',
    'Enterprise Application',
    'SAML Configuration',
    'Attribute Mapping',
    'User Assignment',
    'IdP Metadata',
    'Connection Testing',
  ]
prev: false
next: false
sidebar:
  order: 5
  label: "OneLogin"
  badge:
    variant: note
    text: SAML
---

import { Steps } from '@astrojs/starlight/components';

This guide walks you through configuring OneLogin as your SAML identity provider for the application you are onboarding, enabling secure single sign-on for your users. You'll learn how to set up an enterprise application, configure SAML settings to the host application. By following these steps, your users will be able to seamlessly authenticate using their OneLogin credentials.

<Steps>
1. ### Creating enterprise application

   Login to your **OneLogin Portal**. Go to **Applications→ Applications.**

   ![Locate Applications](@/assets/docs/guides/sso-integrations/onelogin-saml/0.png)

   Click on **Add App.**

   ![Click on Add App](@/assets/docs/guides/sso-integrations/onelogin-saml/1.png)

   In the **Find Application** search box, type in **SAML Custom Connector (Advanced)**, and select it from the drop down list.

   ![Select SAML Custom Connector from drop down (GIF)](/images/docs/guides/sso-integrations/onelogin-saml/2-5.gif)

   Give your app a name that reflects the application you'll be connecting it to, so users can easily recognize it in their OneLogin portal., select your icon (optional) and then click on **Save.**

   ![Click on Save](@/assets/docs/guides/sso-integrations/onelogin-saml/2.png)

2. ### SAML configuration

   On the Application page click on **Configuration.**

   ![Locate Configuration](@/assets/docs/guides/sso-integrations/onelogin-saml/3.png)

   From your **SSO Configuration Portal**, copy the **ACS (Consumer) URL**. Go back to your **OneLogin Admin Portal**, and paste it in the **Recipient** and **ACS (Consumer) URL Validator** fields.

   ![Copy ACS (Consumer) URL on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/4.png)

   **OneLogin Admin Portal**

   ![Paste it in Recipient, ACS URL Validator, and ACS(Consumer) URL fields on OneLogin Admin Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/5.png)

   Similarly, copy the **Audience (Entity ID) f**rom your SSO Configuration Portal. Go back to your **OneLogin Admin Portal**, and paste it in the **Audience (EntityID).**

   ![Copy Audience (Entity ID) on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/6.png)

   ![Paste copied URL in Audience (EntityID) on OneLogin Admin Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/7.png)

   Click on **Save**.

   ![Locate Save](@/assets/docs/guides/sso-integrations/onelogin-saml/8.png)

3. ### Attribute mapping

   Go to the **Parameters** tab on **OneLogin Admin Portal**, and click on the plus (+) sign to add attributes.

   ![Locate Parameters tab](@/assets/docs/guides/sso-integrations/onelogin-saml/9.png)

   Check the **Attribute Mapping** section in the **SSO Configuration Portal**, and carefully map the **exact** **same attributes** on your **OneLogin Admin Portal**.

   ![Check attributes on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/10.png)

   ![Paste attributes on OneLogin Admin Portal](/images/docs/guides/sso-integrations/onelogin-saml/10-5.gif)

4. ### Assign user/group

   Go to the **Users** tab.

   ![Locate Users under Users tab](@/assets/docs/guides/sso-integrations/onelogin-saml/11.png)

   Click the user you want to assign to the application.

   ![Select user to assign](@/assets/docs/guides/sso-integrations/onelogin-saml/12.png)

   Click on the **Applications** tab. Click on the **+** sign to assign the newly created application.

   ![Add application to previously selected user](@/assets/docs/guides/sso-integrations/onelogin-saml/13.png)

   Select the newly created application from the drop down, and click on **Continue.**

   ![Select application from drop-down](@/assets/docs/guides/sso-integrations/onelogin-saml/14.png)

   Click on **Save**.

   ![Save user assignment to application](@/assets/docs/guides/sso-integrations/onelogin-saml/15.png)

5. ### Upload IdP metadata URL

   On **OneLogin Admin Portal**, click on SSO. Copy the **Issuer URL**.

   ![Copy Issuer URL on OneLogin Admin Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/16.png)

   Under **Identify Provider Configuration,** select **Configure using Metadata URL,** and paste it under **App Federation Metadata URL** on the **SSO Configuration Portal.**

   ![Paste Issuer URL on SSO Configuration Portal](@/assets/docs/guides/sso-integrations/onelogin-saml/17.png)

6. ### Test connection

   Click on **Test Connection.** If everything is done correctly, you will see a **Success** response as shown below.

   If the connection fails, you'll see an error, the reason for the error, and a way to solve that error right on the screen.

   ![Test SSO Configuration](@/assets/docs/guides/sso-integrations/onelogin-saml/18.png)

7. ### Enable connection

   Click on **Enable Connection.** This will let all your selected users login to the new application via your **OneLogin Admin Portal** SSO.

   ![Enable SSO on Onelogin Admin Console](@/assets/docs/guides/sso-integrations/onelogin-saml/19.png)
</Steps>

With this, we are done configuring your **OneLogin Admin Portal** application for an SSO login setup.

================
File: guides/integrations/sso-integrations/pingidentity-saml.mdx
================
---
title: "PingIdentity SAML"
description: "Learn how to configure PingIdentity as a SAML identity provider for secure single sign-on (SSO) with your application using Scalekit."
prev: false
next: false
sidebar:
  order: 5
  label: "PingIdentity"
  badge:
    variant: note
    text: SAML
---

import { Steps } from '@astrojs/starlight/components';

This guide walks you through configuring Ping Identity as your SAML identity provider for the application you are onboarding, enabling secure single sign-on for your users. You'll learn how to set up an enterprise application, configure SAML settings to the host application. By following these steps, your users will be able to seamlessly authenticate using their Ping Identity credentials.

<Steps>
1. ### Create a custom SAML app in PingIdentity

   Log in to PingOne Admin Console. Select Applications → Applications.

   ![Custom SAML app](@/assets/docs/guides/sso-integrations/ping-identity-saml/0-ping-oidentity-saml.png)

   Add a New SAML Application → Click **+ Add Application**.

   Enter an **Application Name** and select the **SAML Application** as the Application Type. Click **Configure**.

   ![Naming the custom SAML app](@/assets/docs/guides/sso-integrations/ping-identity-saml/0.1-ping-identity-saml.png)

2. ### Configure the Service Provider in Ping Identity

   Log in to your SSO configuration portal and click on Single Sign-on (SSO) → Ping Identity → SAML 2.0 for the organization you want to configure it for.

   ![SSO Configuration Portal](@/assets/docs/guides/sso-integrations/ping-identity-saml/1-ping-identity-saml.png)

   Now, copy the following details from Scalekit's SSO settings:

   - **ACS URL** (Assertion Consumer Service URL)
   - **SP Entity ID** (Service Provider Entity ID)
   - **SP Metadata URL**

   Paste the details copied from your SSO configuration portal into the respective fields under SAML configuration in the Ping Identity dashboard:

   - Method 1: Import Metadata

   ![Import Metadata](@/assets/docs/guides/sso-integrations/ping-identity-saml/1.1-ping-identity-saml.png)

   - Method 2: Import from URL

   ![Import from URL](@/assets/docs/guides/sso-integrations/ping-identity-saml/1.2-ping-identity-saml.png)

   - Method 3: Manually Enter

   ![Manually Enter](@/assets/docs/guides/sso-integrations/ping-identity-saml/1.3-ping-identity-saml.png)

3. ### Configure Attribute mapping & assign users/groups

   #### Attribute mapping

   For the user profile details to be shared with us at the time of user login as part of SAML response payload, SAML Attributes need to be configured in your Identity Provider portal.

   To ensure seamless login, the below user profile details are needed:
   - Email Address
   - First Name
   - Last Name

   To configure these attributes, locate **Attribute Mapping** section in the SAML Configuration page in your Identity Provider's application, and carefully map the attributes with the Attribute names exactly as shown in the below image.

   ![Attribute Mapping](@/assets/docs/guides/sso-integrations/ping-identity-saml/2.1-ping-identity-saml.png)

   #### Assign user/group

   To finish the Service Provider section of the SAML configuration, you need to "add" the users who need to access to this application.

   Find the User/Group assignment section in your Identity Provider application and select and assign all the required users or user groups that need access to this application via Single Sign-on.

   ![Assign users & groups](@/assets/docs/guides/sso-integrations/ping-identity-saml/2.2-ping-identity-saml.png)

4. ### Configure Identity Provider in your SSO configuration portal

   In your SSO configuration portal, navigate to the Identity Provider Configuration section to complete the setup. You can do this in two ways:

   - Method 1: Enter the Metadata URL and click update.

   ![Configure using Metadata URL](@/assets/docs/guides/sso-integrations/ping-identity-saml/3.1-ping-identity-saml.png)

   - Method 2: Configure manually

   To do so, enter the IdP entity ID, IdP Single Sign-on URL, and upload the x.509 certificate that you downloaded from Ping Identity. Then, click update.

   ![Configure using Metadata URL](@/assets/docs/guides/sso-integrations/ping-identity-saml/3.2-ping-identity-saml.png)

5. ### Verify successful connection by simulating SSO upon clicking Test Connection

   To verify whether the SAML SSO configuration is completed correctly, click on **Test Connection** on the SSO Configuration Portal.

   If everything is done correctly, you will see a **Success** response as shown below.

   ![Test Single Sign On](@/assets/docs/guides/sso-integrations/ping-identity-saml/4-ping-identity-saml.png)

   If there's a misconfiguration, our test will identify the errors and will offer you a way to correct the configuration right on the screen.

6. ### Enable your Single Sign-on connection

   After you successfully verified that the connection is configured correctly, you can enable the connection to let your users login to this application via Single Sign-on.

   Click on **Enable Connection**.

   ![Enable SSO Connection](@/assets/docs/guides/sso-integrations/ping-identity-saml/5-ping-identity-saml.png)

   With this, we are done configuring Ping Identity SAML for your application for an SSO login setup.
</Steps>

================
File: guides/integrations/index.mdx
================
---
title: Integrations
description: Explore Scalekit's comprehensive integration capabilities with SSO providers, social connections, SCIM provisioning, and authentication systems.
prev: false
next: false
---

import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';
import {
  SSOIntegrationsSection,
  SCIMIntegrationsSection,
  SocialIntegrationsSection,
  AuthSystemsSection,
} from '@/components/templates';

Explore integration guides for SSO, social logins, SCIM provisioning, and connecting with popular authentication systems.

## Single Sign-On (SSO) integrations

 Configure organization IdPs and connect it to Scalekit to implement enterprise-grade authentication for your users.

<SSOIntegrationsSection />


## Social connections

Enable users to sign in with their existing accounts from popular platforms. Social connections reduce signup friction and provide a familiar authentication experience.

<SocialIntegrationsSection />

## SCIM Provisioning integrations

SCIM (System for Cross-domain Identity Management) automates user provisioning between identity providers and applications. These guides help you set up SCIM integration with various identity providers.

<SCIMIntegrationsSection />

## Authentication system integrations

Scalekit can coexist with your existing authentication systems, allowing you to add enterprise SSO capabilities without replacing your current setup. These integrations show you how to configure Scalekit alongside popular authentication platforms.

<AuthSystemsSection />

================
File: guides/m2m/mcp/additional-reading.mdx
================
---
title: MCP Servers - Additional Reading
description: "Explore advanced topics for MCP servers, including OAuth 2.1 flows, scope design, dynamic client registration, and security best practices."
slug: "guides/mcp/additional-reading"
sidebar:
  label: Additional Reading
next: false
topic: "mcp"
---
MCP Clients that want to get authorized to access your MCP Server need to follow either of the below OAuth 2.1 Flows Supported by Scalekit.

## OAuth 2.1 Flows Supported

### Authorization Code Flow

Ideal when an AI agent or MCP Client acts on behalf of a human user:

```javascript
// Step 1: Redirect user to authorization server
const authURL = new URL('https://your-org.scalekit.com/oauth/authorize');
authURL.searchParams.set('response_type', 'code');
authURL.searchParams.set('client_id', 'your-client-id');
authURL.searchParams.set('redirect_uri', 'https://your-app.com/callback');
authURL.searchParams.set('scope', 'mcp:tools:calendar:read mcp:tools:email:send');
authURL.searchParams.set('state', generateSecureRandomString());
authURL.searchParams.set('code_challenge', generatePKCEChallenge());
authURL.searchParams.set('code_challenge_method', 'S256');

// Step 2: Handle callback and exchange code for token
app.get('/callback', async (req, res) => {
  const { code, state } = req.query;

  // Verify state parameter to prevent CSRF
  if (!isValidState(state)) {
    return res.status(400).json({ error: 'Invalid state parameter' });
  }

  const tokenResponse = await fetch('https://your-org.scalekit.com/oauth/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      client_id: 'your-client-id',
      redirect_uri: 'https://your-app.com/callback',
      code_verifier: getPKCEVerifier() // From PKCE challenge generation
    })
  });

  const tokens = await tokenResponse.json();
  // Store tokens securely and proceed with MCP calls
});
```

### Client Credentials Flow

Perfect for automated agents that don't represent a specific user but want to access your MCP Server on their own behalf. This is typically used for Machine-to-Machine (M2M) authentication.

```javascript
const getMachineToken = async () => {
  const response = await fetch('https://your-org.scalekit.com/oauth/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'client_credentials',
      client_id: 'your-service-client-id',
      client_secret: 'your-service-client-secret',
      scope: 'mcp:tools:inventory:check mcp:resources:store-data',
      audience: 'https://your-mcp-server.com',
    })
  });

  return await response.json();
};
```

## Scope Design Best Practices

Design OAuth scopes that reflect your MCP server's actual capabilities and security requirements:

### Hierarchical Scopes

```javascript
// Resource-based scopes
'mcp:resources:customer-data:read'    // Read customer data
'mcp:resources:customer-data:write'   // Modify customer data
'mcp:resources:*'                     // All resources (admin-level)

// Tool-based scopes
'mcp:tools:weather'                   // Weather API access
'mcp:tools:calendar:read'             // Read calendar events
'mcp:tools:calendar:write'            // Create/modify calendar events
'mcp:tools:email:send'                // Send emails
'mcp:tools:*'                         // All tools access

// Action-based scopes
'mcp:exec:workflows:risk-assessment'  // Execute risk assessment workflow
'mcp:exec:functions:data-analysis'    // Run data analysis functions
```

### Scope Validation Helpers

```javascript
const ScopeValidator = {
  hasScope: (userScopes, requiredScope) => {
    return userScopes.includes(requiredScope) ||
           userScopes.includes(requiredScope.split(':').slice(0, -1).join(':') + ':*');
  },

  hasAnyScope: (userScopes, allowedScopes) => {
    return allowedScopes.some(scope => ScopeValidator.hasScope(userScopes, scope));
  },

  validateToolAccess: (userScopes, toolName) => {
    const toolScope = `mcp:tools:${toolName}`;
    const wildcardScope = 'mcp:tools:*';
    return userScopes.includes(toolScope) || userScopes.includes(wildcardScope);
  }
};

// Usage in MCP tool handlers
app.post('/mcp/tools/:toolName', (req, res) => {
  const { toolName } = req.params;
  const userScopes = req.auth.scopes;

  if (!ScopeValidator.validateToolAccess(userScopes, toolName)) {
    return res.status(403).json({
      error: 'insufficient_scope',
      error_description: `Access to tool '${toolName}' requires appropriate scope`
    });
  }

  // Process tool request
});
```

## Dynamic Client Registration

Scalekit supports Dynamic Client Registration (DCR) to enable seamless integration for new MCP clients that want to connect to your MCP Server. MCP clients can auto-register using DCR:

```javascript
// MCP clients can auto-register using DCR
const registerClient = async (clientMetadata) => {
  const response = await fetch('https://your-org.scalekit.com/resource-server/oauth/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      client_name: 'AI Sales Assistant',
      client_uri: 'https://sales-ai.company.com',
      redirect_uris: ['https://sales-ai.company.com/oauth/callback'],
      grant_types: ['authorization_code', 'refresh_token'],
      response_types: ['code'],
      scope: 'mcp:tools:crm:read mcp:tools:email:send',
      audience: 'https://your-mcp-server.com',
      token_endpoint_auth_method: 'client_secret_basic',
      ...clientMetadata
    })
  });

  return await response.json();
  // Returns: { client_id, client_secret, client_id_issued_at, ... }
};
```

## Security Implementation

### Rate Limiting by Client

Implement client-specific rate limits:

```javascript
import rateLimit from 'express-rate-limit';

const createClientRateLimit = () => {
  return rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    limit: (req) => {
      // Different limits based on client type or scopes
      const scopes = req.auth?.scopes || [];
      if (scopes.includes('mcp:tools:*')) return 1000; // Premium client
      if (scopes.includes('mcp:tools:basic')) return 100; // Basic client
      return 50; // Default limit
    },
    keyGenerator: (req) => req.auth?.clientId || req.ip,
    message: {
      error: 'rate_limit_exceeded',
      error_description: 'Too many requests from this client'
    }
  });
};

app.use('/mcp', createClientRateLimit());
```

### Comprehensive Logging

Track all OAuth and MCP interactions:

```javascript
const auditLogger = {
  logTokenRequest: (clientId, grantType, scopes, success) => {
    console.log(JSON.stringify({
      event: 'oauth_token_request',
      timestamp: new Date().toISOString(),
      client_id: clientId,
      grant_type: grantType,
      requested_scopes: scopes,
      success
    }));
  },

  logMCPAccess: (req, toolName, success, error = null) => {
    console.log(JSON.stringify({
      event: 'mcp_tool_access',
      timestamp: new Date().toISOString(),
      user_id: req.auth?.userId,
      client_id: req.auth?.clientId,
      tool_name: toolName,
      scopes: req.auth?.scopes,
      success,
      error: error?.message,
      ip_address: req.ip,
      user_agent: req.get('User-Agent')
    }));
  }
};

// Use in your MCP handlers
app.post('/mcp/tools/:toolName', async (req, res) => {
  const { toolName } = req.params;

  try {
    // Process tool request
    const result = await processToolRequest(toolName, req.body);

    auditLogger.logMCPAccess(req, toolName, true);
    res.json(result);
  } catch (error) {
    auditLogger.logMCPAccess(req, toolName, false, error);
    res.status(500).json({ error: 'Tool execution failed' });
  }
});
```

### Health Check Endpoints

Monitor your MCP server and authorization integration:

```javascript
app.get('/health', async (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      mcp_server: 'healthy',
      oauth_server: 'unknown'
    }
  };

  try {
    // Test OAuth server connectivity
    const oauthTest = await fetch('https://your-org.scalekit.com/.well-known/oauth-authorization-server');
    health.services.oauth_server = oauthTest.ok ? 'healthy' : 'degraded';
  } catch (error) {
    health.services.oauth_server = 'unhealthy';
    health.status = 'degraded';
  }

  const statusCode = health.status === 'healthy' ? 200 : 503;
  res.status(statusCode).json(health);
});
```

## Troubleshooting

### Common Issues and Solutions

**Token Validation Failures**

```javascript
// Debug token validation issues
const debugTokenValidation = async (token) => {
  try {
    // Check token structure
    const [header, payload, signature] = token.split('.');
    console.log('Token Header:', JSON.parse(atob(header)));
    console.log('Token Payload:', JSON.parse(atob(payload)));

    // Validate with detailed error info
    await jwtVerify(token, JWKS, {
      issuer: 'https://your-org.scalekit.com',
      audience: 'https://your-mcp-server.com'
    });
  } catch (error) {
    console.error('Token validation error:', {
      name: error.name,
      message: error.message,
      code: error.code
    });
  }
};
```

**CORS Issues with Authorization Server**

```javascript
// Configure CORS for OAuth endpoints
app.use('/oauth', cors({
  origin: 'https://your-org.scalekit.com',
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Authorization', 'Content-Type', 'MCP-Protocol-Version']
}));
```

**Scope Permission Debugging**

```javascript
const debugScopes = (req, res, next) => {
  console.log('Request Scopes:', {
    user_scopes: req.auth?.scopes,
    required_scope: req.requiredScope,
    has_permission: req.auth?.scopes?.includes(req.requiredScope)
  });
  next();
};
```

### Error Response Standards

Follow OAuth 2.1 and MCP error response formats:

```javascript
const sendOAuthError = (res, error, description, statusCode = 400) => {
  res.status(statusCode).json({
    error,
    error_description: description,
    error_uri: 'https://your-mcp-server.com/docs/errors'
  });
};

// Usage examples
app.use((error, req, res, next) => {
  if (error.name === 'TokenExpiredError') {
    return sendOAuthError(res, 'invalid_token', 'Access token has expired', 401);
  }

  if (error.name === 'InsufficientScopeError') {
    return sendOAuthError(res, 'insufficient_scope', `Required scope: ${error.requiredScope}`, 403);
  }

  // Default error
  sendOAuthError(res, 'server_error', 'An unexpected error occurred', 500);
});
```

## Advanced Configuration

### Custom Scope Mapping

Map OAuth scopes to internal permissions:

```javascript
const scopePermissionMap = {
  'mcp:tools:weather': ['weather:read'],
  'mcp:tools:calendar:read': ['calendar:events:read'],
  'mcp:tools:calendar:write': ['calendar:events:read', 'calendar:events:write'],
  'mcp:tools:email:send': ['email:send', 'contacts:read'],
  'mcp:resources:customer-data': ['customers:read', 'customers:write']
};

const getPermissionsFromScopes = (scopes) => {
  const permissions = new Set();
  scopes.forEach(scope => {
    const scopePermissions = scopePermissionMap[scope] || [];
    scopePermissions.forEach(permission => permissions.add(permission));
  });
  return Array.from(permissions);
};
```

### Refresh Token Management

Handle token refresh for long-running agents:

```javascript
const TokenManager = {
  async refreshToken(refreshToken) {
    const response = await fetch('https://your-org.scalekit.com/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: 'your-client-id',
        client_secret: 'your-client-secret'
      })
    });

    return await response.json();
  },

  async autoRefreshWrapper(tokenStore, makeRequest) {
    try {
      return await makeRequest(tokenStore.accessToken);
    } catch (error) {
      if (error.status === 401) {
        // Token expired, try refresh
        const newTokens = await this.refreshToken(tokenStore.refreshToken);
        tokenStore.accessToken = newTokens.access_token;
        tokenStore.refreshToken = newTokens.refresh_token;

        // Retry original request
        return await makeRequest(tokenStore.accessToken);
      }
      throw error;
    }
  }
};
```

================
File: guides/m2m/mcp/oauth.mdx
================
---
title: OAuth authorization server for MCP servers
description: Secure your Model Context Protocol (MCP) servers with Scalekit's drop-in OAuth 2.1 authorization solution
slug: "guides/mcp/oauth"
tableOfContents:
  maxHeadingLevel: 3
sidebar:
  label: Quickstart Guide
next: false
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
---
import Subtitle from '@/components/ui/Subtitle.astro'
import { CardGrid, Badge } from '@astrojs/starlight/components';

<Subtitle>Secure your Model Context Protocol (MCP) servers with Scalekit's drop-in OAuth 2.1 authorization solution</Subtitle>

Scalekit provides a production-ready OAuth 2.1 authorization server that implements the <a href="https://modelcontextprotocol.io/specification/draft/basic/authorization" target="_blank" rel="noopener">MCP authorization specification</a>. This guide shows you how to integrate OAuth-based authentication and authorization into your MCP server with minimal code changes.

**Why use Scalekit OAuth for MCP servers?**

- **Identity-scoped access:** Restrict each token to a specific user or agent.
- **Granular permissions:** Control exactly which tools and data each client can access using fine-grained scopes.
- **OAuth 2.1 compliance:** Rely on a modern, secure, and widely adopted authorization standard.
- **Comprehensive audit trails:** Track who accessed what, when, and with which permissions.

For a deeper explanation of why an OAuth layer is essential for remote MCP servers, read the <a href="/guides/mcp/overview" target="_blank" rel="noopener">MCP authorization overview</a>.

## How it works

The Scalekit OAuth authorization server and your MCP server work together to secure access and enforce permissions.

**Scalekit OAuth authorization server**

Acts as the identity provider for your MCP server. It:

- Authenticates users and agents
- Issues access tokens with fine-grained scopes
- Manages OAuth 2.1 flows (authorization code, client credentials)
- Supports dynamic client registration for easy onboarding

**Your MCP server**

Validates incoming access tokens and enforces the permissions encoded in each token. Only requests with valid, authorized tokens are allowed.

This separation of responsibilities ensures a clear boundary: Scalekit handles identity and token issuance, while your MCP server focuses on business logic of executing the actual tool calls.

## Getting started

### Prerequisites

Before you begin, ensure you have:

1. Access to your Scalekit account and the API credentials. If you don't have a Scalekit account yet, you can <a href="https://app.scalekit.com/ws/signup" target="_blank" rel="noopener">signup here</a>.
2. Installed Scalekit SDK into your project

    ```sh showLineNumbers=false
    npm install @scalekit/sdk
    ```

    ```js showLineNumbers=false
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>',
    );
    ```

### Step 1: Register your MCP server

In the Scalekit dashboard, navigate to **MCP servers** and click **Add MCP server**. Configure your server with the following settings:

![MCP server registration](@/assets/docs/guides/mcp/scalekit-register-mcp-server.png)

**Basic configuration:**

- **Server name**: A display name that users will see during authorization (e.g., "My AI Assistant")
- **Resource identifier**: Your MCP server's unique identifier, typically your server's URL (e.g., `https://mcp.mycompany.com`). Access tokens minted by Scalekit will have the resource identifier as `aud` claim.

**Access control settings:**

- **Allow dynamic client registration** — Enables MCP clients to register automatically without manual approval. For security reasons, Scalekit ensures that any client that registers via DCR has to implement PKCE-based OAuth 2.1 flow to prevent authorization code interception attacks.

**Token configuration:**

- **Access token lifetime**: Recommended 300-3600 seconds (5 minutes to 1 hour)

**Authentication Provider:**

- **Use Scalekit**: If you are already using Scalekit to power authentication for your other resources like web application, mobile application, API etc, you can continue to use Scalekit as the authentication provider for your MCP server too.

- **Use your own authentication provider**: If you are using any other authentication provider like Microsoft Entra, Google Workspace, AWS Cognito, Auth0, Keycloak etc, you can configure Scalekit to integrate with your existing auth system to validate user identity.

### Step 2: Implement resource metadata discovery

Once you have added your MCP server in the Scalekit dashboard, you will be presented with the protected resource metadata information that you can copy directly from the Scalekit Dashboard and implement in your MCP Server.

MCP clients discover your authorization server through the OAuth 2.0 protected resource metadata endpoint.

![Resource Metadata Information](@/assets/docs/guides/mcp/resource-metadata-info.png)

Below is the code sample to implement resource metadata discovery in your MCP Server:

```javascript
// Required: OAuth Protected Resource Metadata endpoint
// Copy the actual well-known endpoint and the corresponding metadata from the Scalekit dashboard. What is shown here is just a sample
app.get('/.well-known/oauth-protected-resource', (req, res) => {
  res.json({
    "authorization_servers": [
      "https://your-company.scalekit.com/resources/res_82829009141891595"
    ],
    "bearer_methods_supported": [
      "header"
    ],
    "resource": "https://mcp.mycompany.com",
    "resource_documentation": "https://mcp.mycompany.com/docs",
    "scopes_supported": ["weather:read", "weather:write"]
  });
});
```

Description of the OAuth Protected Resource Metadata:

| Field                        | Description                                                                                                                                                                                                                                 |
|------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `resource`                   | The identifier of the resource server. This is the unique identifier of your MCP Server. Every token that Scalekit issues will have this value as `aud` claim.                                                          |
| `authorization_servers`      | A list of authorization servers that are trusted by the resource server. MCP Clients use this information to discover more about the authorization server capability by fetching the authorization server. |
| `bearer_methods_supported`   | A list of methods that are supported for bearer tokens. MCP Clients send the OAuth token as `Authorization: Bearer <token>` header.                                                                                                         |
| `resource_documentation`     | A URL to the documentation of the resource server.                                                                                                                                                                                          |
| `scopes_supported`           | A list of scopes that are supported by the resource server. MCP Clients use this information to determine which scopes that they would like the token for as part of the OAuth authorize request.                                            |

### Step 3: Validate Bearer Token in your MCP Server

Your MCP server needs to validate whether all the incoming requests have a valid access token. Below is a sample middleware implementation if you are using expressjs for implementing your MCP Server.

You can use Scalekit SDKs (across Node.js, Java, GoLang, Python) to determine whether the token is valid or not and whether the token has appropriate claim values like `aud`, `iss`, `exp`, `iat`, `scope` etc.

```javascript
import { Scalekit, TokenValidationOptions } from '@scalekit-sdk/node';
import { NextFunction, Request, Response } from 'express';

const scalekit = new Scalekit('<SCALEKIT_ENVIRONMENT_URL>', '<SCALEKIT_CLIENT_ID>', '<SCALEKIT_CLIENT_SECRET>');
// your resource id that you configure in the scalekit dashboard
const RESOURCE_ID = `https://your-mcp-server.com`;
// your resource metadata endpoint that you can copy from the scalekit dashboard
const resource_metadata_endpoint = `https://your-mcp-server.com/.well-known/oauth-protected-resource`;
export const WWWHeader = {HeaderKey: 'WWW-Authenticate',HeaderValue: `Bearer realm="OAuth", resource_metadata="${resource_metadata_endpoint}"`}

export async function authMiddleware(req: Request, res: Response, next: NextFunction) {
    try {
        // Allow public access to well-known endpoints
        if (req.path.includes('.well-known')) {
            return next();
        }

        // Apply authentication to all MCP requests
        const authHeader = req.headers['authorization'];
        const token = authHeader?.startsWith('Bearer ')? authHeader.split('Bearer ')[1]?.trim(): null;

        if (!token) {
            throw new Error('Missing or invalid Bearer token');
        }

        await scalekit.validateToken(token, { audience: [RESOURCE_ID] });
        next();
    } catch (err) {
        return res.status(401).set(WWWHeader.HeaderKey, WWWHeader.HeaderValue).end();
    }
}

// Apply to all MCP endpoints
app.use('/', authMiddleware);
```

### Step 4: (Optional) Implement Scope-based authorization at the tool execution level

Implement scope validation at the MCP tool execution level to ensure that the tool is only executed if the user has authorized the MCP client for the required scope.

```javascript
    try{
        await scalekit.validateToken(token, { audience: [RESOURCE_ID], requiredScopes: [scope] });
    } catch(error){
        return res.status(403).json({
            error: 'insufficient_scope',
            error_description: `Required scope: ${scope}`,
            scope: scope
      });
    }

```

## Next Steps

**Download our sample MCP Server:** We have put together a simple MCP server that you can check out and run it locally to test the end to end functionality of a working MCP server complete with authentication and authorization. You can download and execute a sample MCP server implementation from <a href="https://github.com/scalekit-inc/mcp-demo" target="_blank" rel="noopener">GitHub</a>.

================
File: guides/m2m/mcp/overview.mdx
================
---
title: Auth for MCP servers - Overview
description: Secure your Model Context Protocol (MCP) servers with Scalekit's drop-in OAuth 2.1 authorization solution
slug: "guides/mcp/overview"
tableOfContents:
  maxHeadingLevel: 2
sidebar:
  label: Overview
prev: false
next: false
---

import { Steps, LinkCard } from '@astrojs/starlight/components';
import Subtitle from '@/components/ui/Subtitle.astro'

<Subtitle>How MCP is transforming AI application architecture and why authorization matters more than ever</Subtitle>

The artificial intelligence landscape is rapidly evolving from simple chatbots to sophisticated agents capable of interacting with real-world systems, accessing sensitive data, and performing complex workflows. As AI applications become more powerful and integrated into business-critical processes, the need for standardized, secure communication protocols has never been more urgent.

Enter the Model Context Protocol (MCP) — a breakthrough standard that's reshaping how AI models interact with external systems while introducing new security challenges that demand careful attention.

## What is Model Context Protocol (MCP)?

Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.

The Model Context Protocol is an open standard that defines how AI applications can safely and efficiently access external resources, tools, and data sources. Instead of each AI system requiring custom integrations for every service it needs to access, MCP creates a universal interface that works across different AI models, platforms, and data sources.

### The MCP architecture

At its core, MCP follows a client-server architecture where a host application can connect to multiple servers:

- **MCP hosts**: AI applications like Claude Desktop, IDEs, or custom AI tools that need to access external resources
- **MCP clients**: Protocol clients that maintain connections between hosts and servers
- **MCP servers**: Lightweight programs that expose specific capabilities (tools, data, or services) through the standardized protocol
- **Data sources**: Local files, databases, APIs, and services that MCP servers can access

This architecture enables a plugin ecosystem where AI models can seamlessly integrate with hundreds of different services without requiring custom code for each integration.

## The path to secure MCP: OAuth 2.1 integration

Recognizing these challenges, the MCP specification evolved to incorporate robust authorization mechanisms. The Model Context Protocol provides authorization capabilities at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners.

### Why OAuth 2.1 for MCP?

The MCP specification chose OAuth 2.1 as its authorization framework for several compelling reasons

|  |  |
|---------|-------------|
| Industry standard | OAuth 2.1 is a well-established, widely-adopted standard for delegated authorization, with extensive tooling and ecosystem support. |
| Security best practices | OAuth 2.1 incorporates lessons learned from OAuth 2.0, removing deprecated flows and enforcing security measures like PKCE (Proof Key for Code Exchange). |
| Flexibility | Supports multiple grant types suitable for different MCP use cases:<br/> **Authorization code**: When AI agents act on behalf of human users<br/> **Client credentials**: For machine-to-machine integrations |
| Ecosystem compatibility | Works with existing identity providers and authorization servers, making it easier for enterprises to integrate MCP into their existing security infrastructure. |

### MCP authorization specification overview

This authorization mechanism is based on established specifications listed below, but implements a selected subset of their features to ensure security and interoperability while maintaining simplicity:

- **OAuth 2.1**: Core authorization framework with enhanced security
- **OAuth 2.0 Authorization Server Metadata (RFC8414)**: Standardized server discovery
- **OAuth 2.0 Dynamic Client Registration Protocol (RFC7591)**: Automatic client registration
- **OAuth 2.0 Protected Resource Metadata (RFC9728)**: Resource server discovery

## The authorization flow in practice

Here's how the MCP OAuth 2.1 flow unfolds step-by-step::

![MCP OAuth 2.1 Authorization Flow](@/assets/docs/guides/mcp/mcp-auth-flow.png)


**Discovery phase**
<Steps>

1. **MCP client** encounters a protected MCP server
2. **Server** responds with `401 Unauthorized` and `WWW-Authenticate` header pointing to authorization server
3. **Client** discovers authorization server capabilities through metadata endpoints

</Steps>

**Authorization phase**

<Steps>
4. **Client** registers with authorization server (if using Dynamic Client Registration)
5. **Authorization server** issues client credentials
6. **Client** initiates appropriate OAuth flow (Authorization Code or Client Credentials)
7. **User** grants consent (for Authorization Code flow)
8. **Authorization server** issues access token with appropriate scopes
</Steps>

**Access phase**

<Steps>
9. **Client** includes access token in requests to MCP server
10. **MCP server** validates token and enforces scope-based permissions
11. **Server** processes request and returns response
12. **All interactions** are logged for audit and compliance
</Steps>


## Key security enhancements in MCP OAuth 2.1

The current MCP authorization specification incorporates several critical security improvements:

#### Mandatory PKCE

MCP clients MUST implement PKCE according to OAuth 2.1 Section 7.5.2. PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.

#### Strict redirect URI validation

MCP clients MUST pre-register exact redirect URIs with the authorization server. During authorization, the server MUST enforce an exact match to prevent redirection attacks.

#### Short-lived tokens

MCP authorization servers SHOULD issue short-lived access tokens to reduce the impact of leaked tokens. This minimizes the window of exposure if tokens are compromised.

#### Comprehensive scope model

MCP OAuth 2.1 supports granular permissions through scopes like:

| Scope                              | Description                          |
|-------------------------------------|--------------------------------------|
| `mcp:tools:weather`                 | Access to weather tools only         |
| `mcp:resources:customer-data:read`  | Read-only access to customer data    |
| `mcp:exec:workflows:*`              | Execute any workflow                 |

#### Dynamic client registration

MCP clients and authorization servers SHOULD support the OAuth 2.1 Dynamic Client Registration Protocol to allow MCP clients to obtain OAuth client IDs without user interaction. This enables seamless onboarding of new AI agents without manual configuration.

## Why authorization matters more than ever

As AI applications become more sophisticated and handle increasingly sensitive operations, proper authorization is no longer optional — it's essential for several reasons:

#### Regulatory compliance

Many industries require strict access controls and audit trails. Healthcare organizations must comply with HIPAA, financial services with SOX and PCI DSS, and global companies with GDPR. <a href="https://www.scalekit.com/blog/oauth-2-1-mcp-secure-ai-integrations" target="_blank">OAuth 2.1 and MCP provide the security framework needed for regulatory compliance</a>.

#### Enterprise adoption

Enterprises won't deploy AI systems that can't integrate with their existing identity and access management infrastructure. OAuth 2.1 compatibility makes MCP servers enterprise-ready.

#### Risk management

As AI agents gain the ability to perform real-world actions — sending emails, making purchases, modifying databases — the potential impact of unauthorized access grows exponentially. Proper authorization limits the blast radius of security incidents.

#### Trust and transparency

Users and organizations need to understand what AI systems can access and how that access is controlled. OAuth scopes provide clear, granular permissions that can be communicated to stakeholders.

#### Future-proofing

As AI capabilities expand, authorization frameworks must be able to evolve. OAuth 2.1's extensible scope model and standards-based approach provide a foundation for future security enhancements.


### Next steps

<LinkCard href="/guides/mcp/oauth" title="MCP OAuth 2.1 implementation guide" description="Step-by-step instructions for setting up production-ready authorization for your MCP server, including code examples and best practices." />

================
File: guides/m2m/api-auth-m2m-clients.mdx
================
---
title: Authenticate M2M clients
description: "Learn how to authenticate M2M clients with your API using Scalekit, from obtaining access tokens to validating requests with JWKS."
sidebar:
  label: Authenticate M2M clients
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

This guide explains how your application can validate API requests from Machine-2-Machine (M2M) clients using Scalekit's M2M authentication system. This guide explains the authentication flow, from obtaining access tokens to validating requests using JSON Web Key Sets (JWKS).

## How M2M clients authenticate with your API

Every Scalekit environment functions as an Authorization Server. M2M clients authenticate using client credentials with this server.

### Storing client credentials

M2M clients must securely store their credentials in environment variables:

```sh title="Environment variables"
YOURAPP_ENVIRONMENT_URL="<YOURAPP_SCALEKIT_ENVIRONMENT_URL>"
YOURAPP_CLIENT_ID="<YOURAPP_CLIENT_ID>"
YOURAPP_CLIENT_SECRET="<YOURAPP_CLIENT_SECRET>"
```

### Obtaining access tokens

To authenticate API requests, clients must first obtain an access token from your authorization server using the Token endpoint:

```sh title="Token endpoint"
https://<YOURAPP_SCALEKIT_ENVIRONMENT_URL>/oauth/token
```

The client sends their credentials to this endpoint:

<Tabs>
  <TabItem value="curl" label="cURL">
    ```sh
    curl -X POST \
      "https://<YOURAPP_SCALEKIT_ENVIRONMENT_URL>/oauth/token" \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials" \
      -d "client_id=<YOURAPP_CLIENT_ID>" \
      -d "client_secret=<YOURAPP_CLIENT_SECRET>" \
      -d "scope=openid profile email"
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python
    import os
    import json
    import requests

    env_url = os.environ['YOURAPP_SCALEKIT_ENVIRONMENT_URL']

    def get_m2m_access_token():
        """Request an access token for M2M client authentication."""
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        params = {
            "grant_type": "client_credentials",
            "client_id": os.environ['YOURAPP_SCALEKIT_CLIENT_ID'],
            "client_secret": os.environ['YOURAPP_SCALEKIT_CLIENT_SECRET'],
            "scope": "openid profile email"
        }

        response = requests.post(
            url=f"{env_url}/oauth/token",
            headers=headers,
            data=params,
            verify=True
        )

        access_token = response.json().get('access_token')
        return access_token
    ```
  </TabItem>
</Tabs>

The server returns a JSON response containing the access token:

```json title="Token response"
{
  "access_token": "<YOURAPP_ACCESS_TOKEN>",
  "token_type": "Bearer",
  "expires_in": 86399,
  "scope": "openid"
}
```

| Field | Description |
|-------|-------------|
| `access_token` | Token for authenticating API requests |
| `token_type` | Always "Bearer" for this flow |
| `expires_in` | Token validity period in seconds (typically 24 hours) |
| `scope` | Authorized scopes for this token |

### Using access tokens

After obtaining the access token, clients include it in the Authorization header of their API requests:

```sh title="API request with access token"
curl --request GET "https://<your-api-endpoint>" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <YOURAPP_ACCESS_TOKEN>"
```

## Validating access tokens

Your API server must validate access tokens before processing requests. Scalekit uses JSON Web Tokens (JWTs) signed with RSA keys, which you validate using the JSON Web Key Set (JWKS) endpoint.

### Retrieving JWKS

Your application should fetch the public keys from the JWKS endpoint:

```sh title="JWKS endpoint"
https://<YOURAPP_ENVIRONMENT_URL>/keys
```

```json title="JWKS response"
{
  "keys": [
    {
      "use": "sig",
      "kty": "RSA",
      "kid": "snk_58327480989122566",
      "alg": "RS256",
      "n": "wUaqIj3pIE_zfGN9u4GySZs862F-0Kl-..",
      "e": "AQAB"
    }
  ]
}
```

### Token validation process

When your API receives a request with a JWT, follow these steps:

1. Extract the token from the Authorization header
2. Fetch the JWKS from the endpoint
3. Use the public key from JWKS to verify the token's signature
4. Validate the token's claims (issuer, audience, expiration)

This example shows how to fetch JWKS data:

```sh title="Fetch JWKS with cURL"
curl -s "https://<YOURAPP_ENVIRONMENT_URL>/keys" | jq
```

<Tabs>
  <TabItem value="nodejs" label="jwksClient (Node.js)">
    ```javascript
    const express = require('express');
    const jwt = require('jsonwebtoken');
    const jwksClient = require('jwks-rsa');
    const app = express();

    // Initialize JWKS client
    const client = jwksClient({
      jwksUri: `https://<YOURAPP_ENVIRONMENT_URL>/keys`
    });

    // Function to get signing key
    function getKey(header, callback) {
      client.getSigningKey(header.kid, function(err, key) {
        if (err) return callback(err);

        const signingKey = key.publicKey || key.rsaPublicKey;
        callback(null, signingKey);
      });
    }

    // Middleware to validate JWT
    function validateJwt(req, res, next) {
      // Extract token from header
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Missing authorization token' });
      }

      const token = authHeader.split(' ')[1];

      // Verify token
      jwt.verify(token, getKey, {
        algorithms: ['RS256']
      }, (err, decoded) => {
        if (err) {
          return res.status(401).json({ error: 'Invalid token', details: err.message });
        }

        // Add decoded token to request object
        req.user = decoded;
        next();
      });
    }

    // Apply middleware to protected routes
    app.use('/api', validateJwt);

    // Example protected route
    app.get('/api/data', (req, res) => {
      res.json({ message: 'Authenticated successfully', userId: req.user.sub });
    });

    app.listen(3000, () => {
      console.log('Server running on port 3000');
    });
    ```
  </TabItem>
  <TabItem value="python" label="Python">
    ```python
    # Validate token and get claims using Scalekit SDK
    claims = scalekit_client.validate_access_token_and_get_claims(
      token="<M2M_CLIENT_ACCESS_TOKEN>"
      )
    ```
  </TabItem>
</Tabs>

<Aside type="tip">
When implementing token validation:

1. Always verify the token signature using the public key from JWKS
2. Validate token expiration and required claims
3. Consider caching JWKS responses to improve performance
4. Implement token revocation checks for sensitive operations
5. Use HTTPS for all API endpoints
</Aside>

### SDK support status

Our [Python SDK](https://github.com/scalekit-inc/scalekit-sdk-python) currently includes support for M2M authentication. The support to verify tokens is coming soon to Node, Java, and Go SDKs.

================
File: guides/m2m/m2m-basics.mdx
================
---
title: M2M authentication basics
description: Understand the fundamentals of Machine-2-Machine (M2M) authentication and how it secures API access for non-human clients.
sidebar:
  label: Understanding M2M
prev: false
next: false
---

import { Aside } from '@astrojs/starlight/components';

Machine-2-Machine (M2M) authentication enables secure access between non-human clients and your APIs, without any traditional human involvement.

These machine clients could be automated clients or AI agents, third-party integrations, backend jobs, or internal services. Depending on the use case, they may act on behalf of an organization, a user, or operate independently to perform system-level tasks.

There are two key benefits to organizations and platforms with a robust M2M authentication system:

- **Secure, credential-based** (client ID and client secret) **authentication for non-human clients** without exposing hardcoded secrets or using long-lived tokens.
- **Centralized management of machine identities**, enabling granular permissions, credential rotation across internal and external services.

This structured approach to M2M auth ensures that machine clients can be authenticated with the same rigour as human users. It ensures secure, scoped access to APIs, simplifies integration development, and aligns with enterprise security standards.

## When do you need M2M auth?

You'll typically use M2M auth when:

- Automated clients or AI agents need to make requests on behalf of users or organizations
- External platforms or third-party integrations (like Zapier or Snowflake) interact with your API
- Internal services or background jobs need to programmatically invoke your APIs

In all these cases, there's no human user session involved, but the system still needs a secure way to authenticate the client and determine what access they should have.

## How Machine-2-Machine (M2M) auth works

M2M authentication typically follows the OAuth 2.0 client credentials flow. This is a standardized way for non-human clients to obtain access tokens without requiring user interaction.

Let's start with how OAuth works:

OAuth 2.0 is an authorization framework that allows a client application to access protected resources on a resource server by presenting an access token. It delegates the authorization decision to a central authorization server, which issues access tokens after validating the client or user.

The protocol defines several grant types, depending on the use case. For example:

- **Client credentials flow** is used when one system (like an automated client or AI agent) wants to access another system's API
- **Authorization code flow** is used when a user authorizes a machine client to act on their behalf.

In the M2M use case, the client could be a backend service, AI agent, or integration. If it's an org-level or internal service client, it uses a `client_id` and `client_secret` from the response to authenticate. For user-backed clients, a user first authorizes the client via the authorization code flow.

## How Scalekit helps

Building secure M2M authentication from scratch can be complex, especially when dealing with token scoping, TTL, credential rotation, and validation.

Scalekit handles these concerns out of the box with minimal setup. With just a few API calls or dashboard actions, you can:

- Register machine clients scoped to an organization, user, or a service
- Generate and manage credentials with safe rotation
- Issue signed, short-lived JWTs with the right claims (`oid`, `uid`, `aud`, `scopes`, etc.) based on the client type
- Validate tokens locally in your API without needing to call back to Scalekit

This allows you to enforce least-privilege access for machine clients without having to implement the OAuth flow or token lifecycle yourself.

## How Scalekit supports M2M auth

Scalekit provides a purpose-built M2M auth system based on the OAuth 2.0 flow. The three types of machine clients are:

- **Org-level clients:** Used when an automated client needs to access APIs on behalf of an organization. Tokens are scoped to a specific org (`oid`) and typically used in org-wide workflows. Read the M2M authentication quickstart to set up an org-level client.
- **User-level clients:** Used when a machine client is acting on behalf of a specific user. These tokens include a `uid` (user ID) in addition to `oid` and allow you to enforce user-contextual access. *(Coming soon)*
- **Internal service clients:** Used for secure service-to-service communication between internal systems. These clients issue tokens with an `aud` (audience) claim to enforce destination-specific access. They are ideal for microservices that need to talk to each other without org or user context. *(Coming soon)*

![How M2M authentication works](@/assets/docs/m2m/m2m-flow.png)

The high-level M2M auth flow looks like:

1. **Register a machine client:** You create an M2M client in Scalekit for the machine that needs access to.
2. **Generate credentials**: Scalekit issues a `client_id` and `client_secret` for that client. These are used to request access tokens.
3. **Request an access token**: The client requests an access token from Scalekit's /oauth/token endpoint, either directly using the client credentials flow for org-level access, or by exchanging an authorization code after user consent in the authorization code flow.
4. **Receive a signed JWT**: Scalekit validates the request and returns a short-lived, signed JWT that contains claims.

    Depending on the type of client, when a token is issued, it contains information like:

    - Which organization it belongs to (`oid`)
    - Which user it belongs to (`uid`)
    - What it's allowed to do (`scopes`)
    - How long it's valid for (`exp`, `nbf`), and
    - Which service it's intended for (`aud`).

    Each token is signed by Scalekit so your API can validate it locally without needing to call Scalekit. This improves performance and keeps your authorization flow resilient even if the auth server is briefly unavailable.

5. **Make authenticated API calls**: The machine client sends this token in the `Authorization` header when calling your API.
6. **Your API validates the token**: Your API checks the token's signature and claims locally. No network call to Scalekit is needed.

This approach allows for a secure and programmatic authentication using short-lived, scoped tokens that can be revoked or rotated as needed.

## Key behavior and properties

<Aside type="tip">
Tokens issued by Scalekit are designed to be secure by default and operationally smooth to manage over time:
</Aside>

- **Short-lived**: All tokens have a configurable TTL (default: 1 hour; minimum: 5 minutes) to reduce long-term risk.
- **Locally verifiable**: Tokens are signed JWTs that can be verified by your API without calling back to Scalekit.
- **Supports rotation**: Each client can store up to five secrets at a time, making credential rotation seamless with no downtime.
- **Includes identity context**: Tokens contain claims like `oid` (org ID), `uid` (user ID), and `aud` (audience) so you can enforce precise access.
- **Scoped access**: Define fine-grained scopes to limit what a client is allowed to do.

These defaults ensure that tokens are short-lived, constrained in what they can do, and fully verifiable without external dependencies.

To start integrating M2M authentication in your application, head to the [quickstart guide](/m2m/quickstart) for setting up an org-level client.

================
File: guides/m2m/overview.mdx
================
---
title: Machine-2-Machine (M2M) authentication
description: "Learn how to secure interactions between software systems with M2M authentication, enabling secure API access for AI agents, apps, and automated workflows."
sidebar:
  label: Overview
prev: false
---

import { Aside, Steps } from '@astrojs/starlight/components';

M2M authentication secures interactions between software systems that operate without human intervention. This authentication method enables AI agents, apps, automation tools, and workflows to interact with your API securely.

Your API provides essential data for M2M interactions. External systems require secure authentication to access this data through your application's API.

Common M2M use cases include:

- API integration with third-party services (CRM systems, analytics platforms, payment providers)
- Scheduled services that automatically sync data with your API
- Automated workflows that update external systems

Scalekit provides an authentication layer for your API, requiring all downstream machines (AI agents, third-party services) to authenticate before consuming your API.

### How M2M authentication works

The following example demonstrates how to implement M2M authentication for a tasks API that enables customer Slack automations to post weekly reminders:

![M2M Authentication Flow](@/assets/docs/m2m/m2m-flow.png)

<Steps>
1. Authenticate with the Scalekit API using your API credentials from your Scalekit environment.
2. Create a client ID and client secret to identify API consumers through your customer interface.
3. Your customer's application authenticates with your Scalekit environment using these credentials to obtain an access token.
4. The customer's application uses this token to request data from your tasks API.
5. Your application verifies the access token using your Scalekit environment's JSON Web Key Set (JWKS) before processing the request.
</Steps>


### Benefits of M2M Authentication


- **Security**: Eliminates the need to share user credentials between services
- **Auditability**: Each service has its own identity, making it easier to track and audit API usage
- **Scalability**: Services can be easily added or removed without affecting other parts of the system
- **Granular Control**: Fine-grained access control can be implemented at the service level

================
File: guides/m2m/scopes.mdx
================
---
title: M2M client scopes
description: Learn how to define and validate permissions for M2M client applications
sidebar:
  label: M2M Client Scopes
topic: m2m
prev:
  label: M2M quickstart
  link: /m2m/quickstart/
next: false
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Scopes define the permissions an application possesses. Within Scalekit, scopes allow your API server (acting as an M2M server) to determine the permissions granted to an M2M client application.

When creating an M2M client via the API, your application specifies the required scopes. Scalekit includes this scope information in the access token that the M2M client uses for subsequent API requests.

<Tabs>
<TabItem value="curl" label="cURL">

```bash title="Register an M2M client with specific scopes"
curl -L 'https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations/<ORGANIZATION_ID>/clients' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer <SCALEKIT_ACCESS_TOKEN>' \
-d '{
    "name": "GitHub Actions Deployment Service",
    "description": "Service account for GitHub Actions to deploy applications to production",
    "scopes": [
        "deploy:applications",
        "read:deployments"
    ],
    "expiry": 3600 # Token expiry time in seconds
}'
```

</TabItem>
<TabItem value="python" label="Python">

```python title="Register an M2M client with specific scopes"
from scalekit.v1.clients.clients_pb2 import OrganizationClient
# Import and initialize the Scalekit client as sc

m2m_client = OrganizationClient(
    name="GitHub Actions Deployment Service",
    description="Service account for GitHub Actions to deploy to production",
    custom_claims=[
        {"key": "github_repository", "value": "acmecorp/inventory-service"},
        {"key": "environment", "value": "production_us"}
    ],
    scopes=["deploy:applications", "read:deployments"],
    audience=["deployment-api.acmecorp.com"],
    expiry=3600
)

response = sc.m2m_client.create_organization_client(
    organization_id="SCALEKIT_ORGANIZATION_ID",
    m2m_client=m2m_client
)
```

</TabItem>
</Tabs>

The API returns a JSON object [containing comprehensive information](/m2m/quickstart/#register-an-api-client) about the newly created M2M client. Your application (acting as the M2M server) should securely provide only the `client_id` and `client_secret` from the response to the M2M client application that needs to authenticate.

The M2M client then uses its client ID and client secret to [authenticate with your API server](/guides/m2m/api-auth-m2m-clients). Successful authentication grants the M2M client an access token, which it includes as a Bearer token in the `Authorization` header for future API requests.

## Validating M2M client scopes

When your API server receives a request from an M2M client, it must validate the scopes present in the access token provided in the `Authorization` header. The access token is a JSON Web Token (JWT).

```json title="Example Decoded Access Token JWT Payload"
{
  "client_id": "m2morg_69038819013296423", // The unique ID of the M2M client
  "exp": 1745305340, // Expiration timestamp
  "iat": 1745218940, // Issued at timestamp
  "iss": "<SCALEKIT_ENVIRONMENT_URL>", // Issuer (Scalekit environment URL)
  "jti": "tkn_69041163914445100", // JWT unique identifier
  "nbf": 1745218940, // Not before timestamp
  "oid": "org_59615193906282635", // Organization ID the client belongs to
  "scopes": [ // Array of permissions granted to this client
    "deploy:applications",
    "read:deployments"
  ],
  "sub": "m2morg_69038819013296423" // Subject (usually the client_id for M2M)
}
```

Scalekit encodes the granted permissions in the `scopes` field within the JWT payload. The `oid` field identifies the specific organization (customer/tenant) associated with this M2M client.

Your API server should inspect the `scopes` array in the received token payload. Use this information to authorize the requested operation, ensuring the client possesses the necessary permissions before processing the API request.

================
File: guides/passwordless/custom-email-provider.mdx
================
---
title: Bring your own email provider
description: Scalekit allows you to configure your own email provider to improve deliverability and security.
slug: "guides/passwordless/custom-email-provider"
sidebar:
  label: 'Custom email provider'
tableOfContents: false
next: false
prev: false
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }

---

import { Badge, LinkCard, CardGrid, Card, Steps, Aside, Tabs, TabItem } from '@astrojs/starlight/components';
import CheckItem from '@/components/ui/CheckItem.astro';

Email delivery is a critical part of your authentication flow. By default, Scalekit sends all authentication emails (sign-in verification, sign-up confirmation, password reset) through its own email service. However, for production applications, you may need more control over email branding, deliverability, and compliance requirements.

Here are common scenarios where you'll want to customize email delivery:

- **Brand consistency**: Send emails from your company's domain with your own sender name and email address to maintain brand trust
- **Deliverability optimization**: Use your established email reputation and delivery infrastructure to improve inbox placement
- **Compliance requirements**: Meet specific regulatory or organizational requirements for email handling and data sovereignty
- **Email analytics**: Track email metrics and performance through your existing email service provider
- **Custom domains**: Ensure emails come from your verified domain to avoid spam filters and build user trust
- **Enterprise requirements**: Corporate customers may require emails to come from verified business domains

Scalekit provides two approaches to handle email delivery, allowing you to choose the right balance between simplicity and control.

![Email delivery methods in Scalekit](@/assets/docs/common/email-providers/1-email-delivery-method.png)



## Use Scalekit's managed email service <Badge variant="note" text="Default"/>

   The simplest approach requires no configuration. Scalekit handles all email delivery using its own infrastructure.

   **When to use this approach:**
   - Quick setup for development and testing
   - You don't need custom branding
   - You want Scalekit to handle email deliverability

   **Default settings:**
   - **Sender Name**: Team workspace_name
   - **From Email Address**: hi@scalekit.com
   - **Infrastructure**: Fully managed by Scalekit

   No additional configuration is required. Your authentication emails will be sent automatically with these settings.

   <Aside type="tip">
   You can customize the sender name in your dashboard settings while still using Scalekit's email infrastructure.
   </Aside>

## Configure your own email provider

   For production applications, you'll likely want to use your own email provider to maintain brand consistency and control deliverability.

   When to use this approach:
   - You need emails sent from your domain
   - You want complete control over email deliverability
   - You need to meet compliance requirements (e.g. GDPR, CCPA)
   - You want to integrate with existing email analytics

### Gather your SMTP credentials

    Before configuring, collect the following information from your email provider:

    | Field | Description |
    |-------|-------------|
    | **SMTP Server Host** | Your provider's SMTP hostname |
    | **SMTP Port** | Usually 587 (TLS) or 465 (SSL) |
    | **SMTP Username** | Your authentication username |
    | **SMTP Password** | Your authentication password |
    | **Sender Email** | The email address emails will be sent from |
    | **Sender Name** | The display name recipients will see |

       ### Configure SMTP settings in Scalekit

    <Steps>
    1. Navigate to email settings

       In your Scalekit dashboard, go to **Emails**.

    2. Select custom email provider

       Choose **Use your own email provider** from the email delivery options

    3. Configure sender information

       ```
       From Email Address: noreply@yourdomain.com
       Sender Name: Your Company Name
       ```

    4. Enter SMTP configuration

       ```
       SMTP Server Host: smtp.your-provider.com
       SMTP Port: 587
       SMTP Username: your-username
       SMTP Password: your-password
       ```

    5. Save and test configuration

       Click **Save** to apply your settings, then send a test email to verify the configuration
    </Steps>

   ### Common provider configurations

   <Tabs>
      <TabItem label="SendGrid">
         ```
         Host: smtp.sendgrid.net
         Port: 587
         Username: apikey
         Password: [Your SendGrid API Key]
         ```
      </TabItem>

      <TabItem label="Amazon SES">
         ```
         Host: email-smtp.us-east-1.amazonaws.com
         Port: 587
         Username: [Your SMTP Username from AWS]
         Password: [Your SMTP Password from AWS]
         ```
      </TabItem>

      <TabItem label="Postmark">
         ```
         Host: smtp.postmarkapp.com
         Port: 587
         Username: [Your Postmark Server Token]
         Password: [Your Postmark Server Token]
         ```
      </TabItem>
   </Tabs>

   <Aside type="note">
   All SMTP credentials are encrypted and stored securely. Email transmission uses TLS encryption for security.
   </Aside>

## Test your email configuration

   After configuring your email provider, verify that everything works correctly:

   1. Send a test email through your authentication flow
   2. Check delivery to ensure emails reach the intended recipients
   3. Verify sender information appears correctly in the recipient's inbox
   4. Confirm formatting, branding, links and buttons work as expected

================
File: guides/passwordless/custom-email-templates.mdx
================
---
title: Custom email templates
description: Scalekit allows you to customize email templates with your branding and content
sidebar:
  label: Custom email templates
slug: "guides/passwordless/custom-email-templates"
tableOfContents: false
next: false
---

import { Badge, LinkCard, CardGrid, Card, Aside, Steps } from '@astrojs/starlight/components';

<Card title="Feature availability" icon="slack">
    Custom email templates are currently available upon request. [Contact our support team](/support/contact-us) to have this feature enabled for your account.
</Card>

Scalekit uses default email templates to send authentication emails to your users. You can customize these templates with your own branding and content to provide a consistent experience for your users.

## Customize your email templates

To customize your email templates:

1. Navigate to _Branding > Email Templates_ in your Scalekit dashboard
2. Customize the following fields:
   - **Subject**: The subject line of the email
   - **Body**: The body content of the email
   - **Sender name**: The display name for the sender
   - **Sender email**: The email address used as the sender
   - **Reply to email**: The email address for replies

Once saved, all subsequent emails will use your customized templates.

## Use basic placeholders to personalize emails

You can personalize emails using built-in placeholders. These placeholders are automatically replaced with user-specific information when the email is sent:

- `{{user.name}}`: The user's name
- `{{user.email}}`: The user's email address
- `{{auth_request_id}}`: The authentication request ID
- `{{otp}}`: The one-time passcode
- `{{magic_link}}`: The magic link for authentication

## Add template variables for advanced customization

For more advanced personalization, you can use template variables to include custom dynamic content in your emails.

### Template variable requirements

- Each variable must be a key-value pair
- Maximum of 30 variables per template
- All template variables must have corresponding values in the request
- Avoid using reserved names: `otp`, `expiry_time_relative`, `link`, `expire_time`, `expiry_time`

### Implement template variables in three steps

<Steps>
  1. Create your email template with variables:
     ```html title="Example email template" showLineNumbers=false
     <p>Hello {{ first_name }},</p>
     <p>Welcome to {{ company_name }}.</p>
     <p>Find your onboarding kit: {{ onboarding_resources }}</p>
     ```

  2. Include variable values in your authentication request:
     ```js ins={3-8} showLineNumbers=false
     const sendResponse = await scalekit.passwordless.sendPasswordlessEmail(
       "<john.doe@example.com>",
       {
         templateVariables: {
           first_name: "John",
           company_name: "Acme Corp",
           onboarding_resources: "https://acme.com/onboarding"
         }
       }
     );
     ```

  3. The sent email will include the replaced values:
     ```html title="Example email preview" showLineNumbers=false
     Hello John,
     Welcome to Acme Corp.
     Find your onboarding kit: https://acme.com/onboarding
     ```
</Steps>

<Aside type="caution">
  The API will return a 400 status code if your template references any variables that aren't provided in the request.
</Aside>

================
File: guides/passwordless/email-magiclink-quickstart.mdx
================
---
title: Email Magic Link quickstart (Headless API)
description: A comprehensive guide to implementing secure, passwordless authentication using Scalekit's Headless API
sidebar:
 label: 'Email Magic Link'
 badge:
   text: 'Headless'
   variant: 'default'
draft: true
---

import { Aside, Steps, Badge, Tabs, TabItem, LinkCard } from '@astrojs/starlight/components';

Coming soon!

================
File: guides/passwordless/oidc.mdx
================
---
title: Passwordless quickstart (via OIDC)
description: A comprehensive guide to implementing secure, passwordless authentication using Scalekit's OIDC
slug: "guides/passwordless/oidc"
sidebar:
 label: 'Quickstart using OIDC'
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
prev:
  link: '/guides/passwordless/overview'
  label: 'Passwordless overview'
---

import { Aside, Steps, Badge, Tabs, TabItem, LinkCard } from '@astrojs/starlight/components';

This guide will walk you through implementing passwordless authentication via Scalekit's OIDC flow. Depending on your configuration, your users will be sent either a one time passcode (OTP) or a magic link to verify their identity.

### Prerequisites

Before you begin, ensure you have:

1. Access to your Scalekit Account and the API credentials. If you don't have a Scalekit account yet, you can <a href="https://app.scalekit.com/ws/signup" target="_blank" rel="noopener">signup here</a>.
2. Installed Scalekit SDK into your project

    ```sh showLineNumbers=false
    npm install @scalekit/sdk
    ```

    ```js showLineNumbers=false
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>',
    );
    ```

## Implementation guide

<Steps>

1. #### Configure settings

    Before implementing the code, ensure passwordless authentication is properly configured in your Scalekit dashboard.

    1. Navigate to **Authentication > Auth Methods**.
    2. In the **Passwordless** section, choose your preferred login method.
    3. For enhanced security, you can also configure these settings:
        - **Enforce same browser origin**: Requires users to complete magic link authentication in the same browser where they initiated the sign-in process. This helps prevent phishing attacks.
        - **Enable new passwordless credentials on resend**: Generates a new verification code or magic link on each resend request, invalidating the previous one.
    4. Click **Save**.

    ![](@/assets/docs/unlisted/passwordless/1-v2.png)

2. #### Initiate authorize request

   To initiate passwordless authentication, redirect users to the Scalekit authorization endpoint with the appropriate parameters.

    Construct your authorization URL with the following parameters and redirect the user to the authorization URL.

    | Parameter | Description |
    |-----------|-------------|
    | `redirect_uri` | Your application endpoint that will receive the authorization code after successful authentication. Example: `https://your-app.com/auth/callback` |
    | `client_id` | Your unique Scalekit application identifier that specifies both your app and environment (staging, production). |
    | `login_hint` | The email address of the user to send the verification email |

   **Example implementation**

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers wrap
    import { ScalekitClient } from '@scalekit-sdk/node';
    // Initialize the SDK client
    const scalekit = new ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>',
    );

    const options = {};

    options['loginHint'] = 'user@example.com';

    const authorizationURL = scalekit.getAuthorizationUrl(redirectUrl, options);
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```python showLineNumbers wrap
    from scalekit import ScalekitClient, AuthorizationUrlOptions, CodeAuthenticationOptions

    # Initialize the SDK client
    scalekit = ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>'
    )

    options = AuthorizationUrlOptions()

    # Authorization URL with login hint
    options.login_hint = 'user@example.com'

    authorization_url = scalekit_client.get_authorization_url(
      redirect_uri=<redirect_uri>,
      options=options
    )

    # Redirect the user to this authorization URL
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers
    import (
      "github.com/scalekit/scalekit-sdk-go"
    )

    func main() {
      // Initialize the SDK client
      scalekitClient := scalekit.NewScalekitClient(
        "<SCALEKIT_ENVIRONMENT_URL>",
        "<SCALEKIT_CLIENT_ID>",
        "<SCALEKIT_CLIENT_SECRET>"
      )

      options := scalekitClient.AuthorizationUrlOptions{}
      // User's email domain detects the correct enterprise SSO connection.
      options.LoginHint = "user@example.com"

      authorizationURL := scalekitClient.GetAuthorizationUrl(
        redirectUrl,
        options,
      )
      // Next step is to redirect the user to this authorization URL
    }

    // Redirect the user to this authorization URL
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java showLineNumbers
    package com.scalekit;

    import com.scalekit.ScalekitClient;
    import com.scalekit.internal.http.AuthorizationUrlOptions;

    public class Main {

      public static void main(String[] args) {
        // Initialize the SDK client
        ScalekitClient scalekitClient = new ScalekitClient(
          "<SCALEKIT_ENVIRONMENT_URL>",
          "<SCALEKIT_CLIENT_ID>",
          "<SCALEKIT_CLIENT_SECRET>"
        );
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        // User's email domain detects the correct enterprise SSO connection.
        options.setLoginHint("user@example.com");
        try {
          String url = scalekitClient
            .authentication()
            .getAuthorizationUrl(redirectUrl, options)
            .toString();
        } catch (Exception e) {
          System.out.println(e.getMessage());
        }
      }
    }
    // Redirect the user to this authorization URL
    ```

    </TabItem>
    </Tabs>

    This redirect will send users to the Scalekit authentication flow, where they'll authenticate with their email before being returned to your application.

    ```sh title="Example authorization URL"
    <YOURAPP_SCALEKIT_ENVIRONMENT_URL>/oauth/authorize?
      client_id=skc_122056050118122349527&
      redirect_uri=https://yourapp.com/auth/callback&
      login_hint=user@example.com&
      response_type=code&
      scope=openid%20profile%20email&
      state=jAy-state1-gM4fdZdV22nqm6Q_jAy-XwpYdYFh..2nqm6Q

    ```

    After redirecting users to the Scalekit authorization endpoint, handle the callback at your `redirect_uri` to retrieve the user profile and complete the authentication process.

3. ### Fetch user details

   After successful user authentication via OTP, Scalekit redirects users to your specified `redirect_uri` with a temporary authorization code parameter. This code must be exchanged for the user's profile information through a secure server-side request.

   <Aside type="caution" title="Validation attempt limits">
     To protect your application, Scalekit limits a user to **five** attempts to enter the correct OTP within a ten-minute window for each authentication request.
     If the user exceeds this limit, they must restart the authentication process.
   </Aside>

    The authorization code exchange process should always be performed server-side to maintain security. This server-side request will:

    1. Validate the authorization code
    2. Return the authenticated user's profile details

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers wrap title="Fetch user profile"
    // Handle oauth redirect_url, fetch code and error_description from request params
    const { code, error, error_description } = req.query;

    if (error) {
      // Handle errors
    }

    const result = await scalekit.authenticateWithCode(code, redirectUri);
    const userEmail = result.user.email;

    // Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```py showLineNumbers title="Fetch user profile"
    # Handle oauth redirect_url, fetch code and error_description from request params
    code = request.args.get('code')
    error = request.args.get('error')
    error_description = request.args.get('error_description')

    if error:
        raise Exception(error_description)

    result = scalekit.authenticate_with_code(code, '<redirect_uri>')

    # result.user has the authenticated user's details
    user_email = result.user.email

    # Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers title="Fetch user profile"
    // Handle oauth redirect_url, fetch code and error_description from request params
    code: = r.URL.Query().Get("code")
    error: = r.URL.Query().Get("error")
    errorDescription: = r.URL.Query().Get("error_description")

    if error != "" {
      // Handle errors
    }

    result, err: = a.scalekit.AuthenticateWithCode(code,<redirectUrl>)

    if err != nil {
      // Handle errors
    }

    // result.User has the authenticated user's details
    userEmail: = result.User.Email

    // Next step: create a session for this user and allow access
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java showLineNumbers title="Fetch user profile" wrap
    // Handle oauth redirect_url, fetch code and error_description from request params
    String code = request.getParameter("code");
    String error = request.getParameter("error");
    String errorDescription = request.getParameter("error_description");

    if (error != null && !error.isEmpty()) {
        // Handle errors
        return;
    }

    try {
        AuthenticationResponse result = scalekit.authentication().authenticateWithCode(code, redirectUrl);
        String userEmail = result.getIdTokenClaims().getEmail();

        // Next step: create a session for this user and allow access
    } catch (Exception e) {
        // Handle errors
    }
    ```

    </TabItem>

    </Tabs>

    The `result` object

    <Tabs>
      <TabItem value="result" label="Result object">
        ```js showLineNumbers=false wrap
        {
          user: {
            email: "john.doe@example.com"  // User's email address
          },
          idToken: "<USER_PROFILE_JWT>",   // JWT containing user profile information
          accessToken: "<API_CALL_JWT>",   // Temporary Access Token for accessing user's email
          expiresIn: 899                    // Token expiration time in seconds
        }
        ```
      </TabItem>
      <TabItem value="idToken" label="Decoded idToken">
        ```json showLineNumbers=false
        {
          "alg": "RS256",
          "kid": "snk_82937465019283746",
          "typ": "JWT"
        }.{
          "amr": [
            "conn_92847563920187364"
          ],
          "at_hash": "j8kqPm3nRt5Kx2Vy9wL_Zp",
          "aud": [
            "skc_73645291837465928"
          ],
          "azp": "skc_73645291837465928",
          "c_hash": "Hy4k2M9pWnX7vqR8_Jt3bg",
          "client_id": "skc_73645291837465928",
          "email": "alice.smith@example.com",
          "email_verified": true,
          "exp": 1751697469,
          "iat": 1751438269,
          "iss": "https://demo-company-dev.scalekit.cloud",
          "sid": "ses_83746592018273645",
          "sub": "conn_92847563920187364;alice.smith@example.com" // A scalekit user ID is sent if user management is enabled
        }.[Signature]
        ```
      </TabItem>
       <TabItem value="idToken" label="Decoded access token">
        ```json showLineNumbers=false
        {
          "alg": "RS256",
          "kid": "snk_794467716206433",
          "typ": "JWT"
        }.{
          "iss": "https://acme-corp-dev.scalekit.cloud",
          "sub": "conn_794467724427269;robert.wilson@acme.com",
          "aud": [
            "skc_794467724259497"
          ],
          "exp": 1751439169,
          "iat": 1751438269,
          "nbf": 1751438269,
          "client_id": "skc_794467724259497",
          "jti": "tkn_794754665320942"
        }.[Signature]
        ```
      </TabItem>
    </Tabs>

</Steps>

Congratulations! You've successfully implemented passwordless authentication in your application. Users can now sign in securely without passwords by entering a verification code or clicking a magic link sent to their email.

<LinkCard
  title="Need more help?"
  href="/support/contact-us"
  description="Reach out to us for any questions or support"
/>

================
File: guides/passwordless/overview.mdx
================
---
title: Overview
description: Passwordless authentication provides a secure and convenient way to authenticate users without the need for passwords.
slug: "guides/passwordless/overview"
tableOfContents: false
next: false
---
import { Badge, LinkCard, CardGrid } from '@astrojs/starlight/components';

Passwordless authentication is an authentication method that allows users to access a system without the need for passwords. It is a secure and convenient way to authenticate users, as it eliminates the risk of password-related vulnerabilities and makes it easier for users to access a system.

Passwordless authentication can be implemented using different methods, such as Email OTP, Email Magic Link, Passkeys and more. Scalekit supports both headless implementation of Passwordless authentication and also complete passwordless implementation via OIDC. Developers can choose the model that fits best based on their implementation needs, context etc.

The main benefits of using passwordless authentication over traditional password-based authentication include:

- **Improved security**: Passwordless authentication eliminates the risk of password-related vulnerabilities such as phishing, credential stuffing and password cracking.
- **Better user experience**: Passwordless authentication provides a seamless and convenient way for users to access a system, without the need to remember and enter passwords.
- **Reduced support costs**: With passwordless authentication, users do not need to reset their passwords or contact support for password-related issues, which reduces the support costs.
- **Modern authentication**: Passwordless authentication aligns with current security best practices and provides a modern and secure way to authenticate users.

## Authentication methods

Scalekit supports multiple passwordless authentication methods:

- **Verification Code (OTP)**: Users receive a one-time passcode via email
- **Magic Link** : Users receive a link via email that the user needs to click to verify their email address.
- **Magic Link + Verification Code** : Users receive a link and a one-time passcode via email and the users can choose either of the options to verify their email address.
- **Passkeys** <Badge variant="note" text="Coming soon" /> : Users authenticate using their biometric data.
- **TOTP (Authenticator App)** <Badge variant="note" text="Coming soon" /> : Users authenticate using a time-based one-time passcode generated by an authenticator app.

## Implementation choices

When implementing passwordless authentication, you have two options:

**Headless Implementation**: You can use our APIs to implement passwordless authentication without any dependence on our UI. You can implement your own UI to collect the OTP from your users or handle the magic link validation.

**OIDC Implementation**: We handle both the security and UI implementation of the OTP and/or magic link workflow. As part of the implementation, you will redirect the user to Scalekit's OIDC Endpoint to complete the email OTP and/or magic link workflow. Once verified, we will send the user back to your pre-configured redirect url endpoint with the email address of the user so that you can complete the workflow.


<CardGrid>

<LinkCard
  title="Headless Implementation"
  href="/guides/passwordless/quickstart"
  description="Learn how to implement Email OTP based passwordless authentication using our headless SDK"
/>

<LinkCard
  title="OIDC Implementation"
  href="/guides/passwordless/oidc"
  description="Learn how to implement Email OTP based passwordless authentication using OIDC"
/>
</CardGrid>

================
File: guides/passwordless/quickstart.mdx
================
---
title: Passwordless quickstart
description: A comprehensive guide to implementing secure, passwordless authentication using Scalekit's Headless API - OTP or Magic Link
sidebar:
 label: 'Quickstart'
 badge:
   text: 'Headless'
   variant: 'default'
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
next: false
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 3
---

import { Aside, Steps, Badge, Tabs, TabItem, LinkCard } from '@astrojs/starlight/components';

This guide explains how you can implement passwordless authentication using Scalekit's APIs to send either verification codes or magic links to your user's email address and verify their identity.

### Prerequisites

Before you begin, ensure you have:

1. Access to your Scalekit Account and the API credentials. If you don't have a Scalekit account yet, you can <a href="https://app.scalekit.com/ws/signup" target="_blank" rel="noopener">signup here</a>.
2. Installed Scalekit SDK into your project

    ```sh showLineNumbers=false
    npm install @scalekit/sdk
    ```

    ```js showLineNumbers=false
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>',
    );
    ```

## Implementation guide

<Steps>

1. ### Configure settings

    Before implementing the code, ensure passwordless authentication is properly configured in your Scalekit dashboard:

    1. Navigate to _Authentication > Auth Methods_
    2. Locate the _Passwordless_ section
    3. Choose the type of passwordless authentication to use.
    4. Save your changes

    ![](@/assets/docs/unlisted/passwordless/1-v2.png)

2. ### Send verification email

   The first step in the passwordless flow is to send a verification email to the user's email. This verification email contains either a **one-time passcode or a magic link or both** based on your selection in the Scalekit dashboard (earlier step).

   Follow these steps to implement the verification email flow:

   1. Create a form to collect the user's email address
   2. Call the passwordless API when the form is submitted
   3. Handle the response to provide feedback to the user

   ```http showLineNumbers=false title="API endpoint"
   POST /api/v1/passwordless/email/send
   ```

   **Example implementation**

   <Tabs syncKey='tech-stack'>
    <TabItem label="cURL">
    ```sh ins={6-11} "/api/v1/passwordless/email/send" title="Request" wrap { "Only if Link or Link+OTP as passwordless option": 10}
    # Send a passwordless verification code to user's email
    curl -L '<SCALEKIT_ENVIRONMENT_URL>/api/v1/passwordless/email/send' \
    -H 'Content-Type: application/json' \
    -H 'Authorization: Bearer eyJh..' \
    --data-raw '{
        "email": "john.doe@example.com",
        "expires_in": 300,
        "state": "jAy-state1-gM4fdZ...2nqm6Q",
        "template": "SIGNIN",

        "magiclink_auth_uri": "https://yourapp.com/passwordless/verify",
         "template_variables": {
          "custom_variable_key": "custom_variable_value"
        }
    }'

   # Response

   # {

   # "auth_request_id": "jAy-state1-gM4fdZ...2nqm6Q"

   # "expires_at": "1748696575"

   # "expires_in": 100

   # "passwordless_type": "OTP" | "LINK" | "LINK_OTP"

   # }

    ```
    <details>
      <summary>Request parameters</summary>

      | Parameter  | Required | Description |
      |------------|----------|-------------|
      | `email` | Yes | Recipient's email address <Badge variant="note" text="string" /> |
      | `expires_in` | No | Code expiration time in seconds (default: 300) <Badge variant="note" text="number" /> |
      | `state` | No | OIDC state parameter for request validation <Badge variant="note" text="string" /> |
      | `template` | No | Email template to use (`SIGNIN` or `SIGNUP`) <Badge variant="note" text="string" /> |
      | `magiclink_auth_uri` | No | Magic Link URI that will be sent to your user to complete the authentication flow. If the URL is of the format `https://yourapp.com/passwordless/verify`, the magic link sent to your user via email will be `https://yourapp.com/passwordless/verify?link_token=<link_token>`. Required if you selected Link or Link + OTP as the passwordless option.<Badge variant="note" text="string" /> |
      | `template_variables` | No | Pass variables to be used in the email template sent to the user. You may include up to 30 key-value pairs to reference in the email template. <Badge variant="note" text="object" /> |
    </details>

    <details>
      <summary>Response parameters</summary>

      | Parameters | Description |
      |-----------|-------------|
      | `auth_request_id` | A unique identifier for the authentication request that can be used to verify the code <Badge variant="note" text="string" /> |
      | `expires_at` | Unix timestamp indicating when the verification code will expire <Badge variant="note" text="string" /> |
      | `expires_in` | The time in seconds after which the verification code will expire. Default is 100 seconds <Badge variant="note" text="number" /> |
      | `passwordless_type` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
    </details>


    </TabItem>
    <TabItem label="Node.js">
    ```js wrap
    const options = {
      template: "SIGNIN",
      state: "jAy-state1-...2nqm6Q",
      expiresIn: 300,
      // Required if you selected Link or Link+OTP as passwordless option
      magiclinkAuthUri: "https://yourapp.com/passwordless/verify",
        templateVariables: {
            employeeID: "EMP523",
            teamName: "Alpha Team",
        },
    };

    const sendResponse = await scalekit.passwordless
      .sendPasswordlessEmail(
        "<john.doe@example.com>",
        options
    );

    // sendResponse = {
    //   authRequestId: string,
    //   expiresAt: number,    // seconds since epoch
    //   expiresIn: number,    // seconds
    //   passwordlessType: string  // "OTP" | "LINK" | "LINK_OTP"
    // }

    ```

     <details>
        <summary>Request parameters</summary>
      | Parameter | Required | Description |
      |-----------|----------|-------------|
      | `email` | Yes | The email address to send the passwordless link to <Badge variant="note" text="string" /> |
      | `template` | No | The template type (`SIGNIN`/`SIGNUP`) <Badge variant="note" text="string" /> |
      | `state` | No | Optional state parameter to maintain state between request and callback <Badge variant="note" text="string" /> |
      | `expiresIn` | No | Optional expiration time in seconds (default: 300) <Badge variant="note" text="number" /> |
      | `magiclinkAuthUri` | No | Magic Link URI that will be sent to your user to complete the authentication flow. If the URL is of the format `https://yourapp.com/passwordless/verify`, the magic link sent to your user via email will be `https://yourapp.com/passwordless/verify?link_token=<link_token>`. Required if you selected Link or Link + OTP as the passwordless option.<Badge variant="note" text="string" /> |
      | `template_variables` | No | Pass variables to be used in the email template sent to the user. You may include up to 30 key-value pairs to reference in the email template. <Badge variant="note" text="object" /> |

    </details>

    <details>
      <summary>Response parameters</summary>

      | Parameters | Description |
      |-----------|-------------|
      | `authRequestId` | Unique identifier for the passwordless authentication request <Badge variant="note" text="string" /> |
      | `expiresAt` | Expiration time in seconds since epoch <Badge variant="note" text="number" /> |
      | `expiresIn` | Expiration time in seconds <Badge variant="note" text="number" /> |
      | `passwordlessType` | Type of passwordless authentication (`OTP`, `LINK` or `LINK_OTP`) <Badge variant="note" text="string" /> |

    </details>
    </TabItem>
   </Tabs>

3. ### Resend a verification email

   Users can request a new verification email if they need one. Use the following endpoint to send a fresh email to verify using OTP or Magic Link.

   <Tabs syncKey='tech-stack'>
    <TabItem label="cURL">
    ```sh ins={5} "/api/v1/passwordless/email/resend" title="Request" wrap
    curl -L '<SCALEKIT_ENVIRONMENT_URL>/api/v1/passwordless/email/resend' \
    -H 'Content-Type: application/json' \
    -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsIm..' \
    -d '{
        "auth_request_id": "jAy-state1-gM4fdZ...2nqm6Q"
    }'

   # Response

   # {

   # "auth_request_id": "jAy-state1-gM4fdZ...2nqm6Q"

   # "expires_at": "1748696575"

   # "expires_in": 300

   # "passwordless_type": "OTP" | "LINK" | "LINK_OTP"

   # }

    ```

    <details>
      <summary>Request parameters</summary>

      | Parameters | Required | Description |
      |-----------|----------|-------------|
      | `auth_request_id` | Yes | The unique identifier for the authentication request that was sent earlier <Badge variant="note" text="string" /> |
    </details>

    <details>
      <summary>Response parameters</summary>

      | Parameters | Description |
      |-----------|-------------|
      | `auth_request_id` | A unique identifier for the authentication request that can be used to verify the code <Badge variant="note" text="string" /> |
      | `expires_at` | Unix timestamp indicating when the verification code will expire <Badge variant="note" text="string" /> |
      | `expires_in` | The time in seconds after which the verification code will expire. Default is 300 seconds <Badge variant="note" text="number" /> |
      | `passwordless_type` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
    </details>
    </TabItem>
    <TabItem label="Node.js">
    ```js
    const { authRequestId } = sendResponse;
    const resendResponse = await scalekit.passwordless
    .resendPasswordlessEmail(
        authRequestId
    );

    // resendResponse = {
    //   authRequestId: "jAy-state1-gM4fdZ...2nqm6Q",
    //   expiresAt: "1748696575",
    //   expiresIn: "300",
    //   passwordlessType: "OTP" | "LINK" | "LINK_OTP"
    // }
    ```

    <details>
      <summary>Request parameters</summary>

      | Parameters | Required | Description |
      |-----------|----------|-------------|
      | `authRequestId` | Yes | The unique identifier for the authentication request that was sent earlier <Badge variant="note" text="string" /> |

    </details>

    <details>
      <summary>Response parameters</summary>

      | Parameters | Description |
      |-----------|-------------|
      | `authRequestId` | Unique identifier for the passwordless authentication request <Badge variant="note" text="string" /> |
      | `expiresAt` | Expiration time in seconds since epoch <Badge variant="note" text="number" /> |
      | `expiresIn` | Expiration time in seconds. Default is 300 seconds <Badge variant="note" text="number" /> |
      | `passwordlessType` | `OTP`, `LINK` or `LINK_OTP` <Badge variant="note" text="string" /> |

    </details>
    </TabItem>
   </Tabs>

   If you enabled **Enable new passwordless credentials on resend** in the Scalekit dashboard, a new verification code or magic link will be sent each time the user requests a new one.

      <Aside type="caution" title="Rate limits">
        You can send a maximum of 2 passwordless emails per minute per email address, including emails resent.
      </Aside>

4. ### Verify the user's identity

   Once the user receives the verification email,
   - If it's Verification code, they'll enter it in your application. Use the following endpoint to validate the code and complete the authentication process.
   - If it's Magic Link, they'll click the link in the email to verify their email address. Capture the `link_token` request parameter from the URL and use it to verify the user's email address.
   - For additional security with magic links, if you enabled the option "Enforce same browser origin", you are required to send the `auth_request_id` to the verification endpoint.

   <Tabs syncKey='verification-type'>
     <TabItem label="Verification code">
       <Steps>
         1. Create a form to collect the verification code
         2. Call the verification API when the form is submitted to verify the code
         3. Handle the response to either grant access or show an error
       </Steps>

       ```http showLineNumbers=false title="API endpoint"
       POST /api/v1/passwordless/email/verify
       ```

       **Example implementation**

       <Tabs syncKey='tech-stack'>
         <TabItem label="cURL">
           ```sh ins={5,6} "/api/v1/passwordless/email/verify" title="Request" showLineNumbers=false wrap
           curl -L '<SCALEKIT_ENVIRONMENT_URL>/api/v1/passwordless/email/verify' \
           -H 'Content-Type: application/json' \
           -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsIm..' \
           -d '{
               "code": "123456",
               "auth_request_id": "YC4QR-dVZVtNNVHcHwrnHNDV..."
           }'
           ```
           <details>
             <summary>Request parameters</summary>
             | Parameters | Required | Description |
             |-----------|----------|-------------|
             | `code` | Yes | The verification code entered by the user <Badge variant="note" text="string" /> |
             | `auth_request_id` | Yes | The request ID from the response when the verification email was sent <Badge variant="note" text="string" /> |
           </details>

           <details>
             <summary>Response parameters</summary>
             | Parameters | Description |
             |-----------|-------------|
             | `email` | The email address of the user <Badge variant="note" text="string" /> |
             | `state` | The state parameter that was passed in the original request <Badge variant="note" text="string" /> |
             | `template` | The template that was used for the verification code <Badge variant="note" text="string" /> |
             | `passwordless_type` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
           </details>
         </TabItem>
         <TabItem label="Node.js">
           ```js wrap
           const { authRequestId } = sendResponse;
           const verifyResponse = await scalekit.passwordless
             .verifyPasswordlessEmail(
               { code: "123456"},
               authRequestId
             );

           // verifyResponse = {
           //   "email": "saifshine7@gmail.com",
           //   "state": "jAy-state1-gM4fdZdV22nqm6Q_j..",
           //   "template": "SIGNIN",
           //   "passwordless_type": "OTP" | "LINK" | "LINK_OTP"
           // }
           ```
           <details>
             <summary>Request parameters</summary>
             | Parameters | Required | Description |
             |-----------|----------|-------------|
             | `options.code` | Yes | The verification code received by the user <Badge variant="note" text="string" /> |
             | `authRequestId` | Yes | The unique identifier for the authentication request that was sent earlier <Badge variant="note" text="string" /> |
           </details>

           <details>
             <summary>Response parameters</summary>
             | Parameters | Description |
             |-----------|-------------|
             | `email` | The email address of the user <Badge variant="note" text="string" /> |
             | `state` | The state parameter that was passed in the original request <Badge variant="note" text="string" /> |
             | `template` | The template that was used for the verification code <Badge variant="note" text="string" /> |
             | `passwordlessType` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
           </details>
         </TabItem>
       </Tabs>
     </TabItem>
     <TabItem label="Magic Link Verification">
       <Steps>
         1. Create a verification endpoint in your application to handle the magic link verification. This is the endpoint that the user lands in when they click the link in the email.
         2. Capture the magic link token from the `link_token` request parameter from the URL.
         3. Call the verification API when the user clicks the link in the email.
         4. Based on token verification, complete the authentication process or show an error with an appropriate error message.
       </Steps>

       ```http showLineNumbers=false title="API endpoint"
       POST /api/v1/passwordless/email/verify
       ```

       **Example implementation**

       <Tabs syncKey='tech-stack'>
         <TabItem label="cURL">
           ```sh ins={5,6} "/api/v1/passwordless/email/verify" title="Request" showLineNumbers=false
           curl -L '<SCALEKIT_ENVIRONMENT_URL>/api/v1/passwordless/email/verify' \
           -H 'Content-Type: application/json' \
           -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsIm..' \
           -d '{
               "link_token": "a4143d8f-...c846ed91e_l",
               "auth_request_id": "YC4QR-dVZVtNNVHcHwrnHNDV..." // (optional)
           }'
           ```
           <details>
             <summary>Request parameters</summary>
             | Parameters | Required | Description |
             |-----------|----------|-------------|
             | `link_token` | Yes | The link token received by the user <Badge variant="note" text="string" /> |
             | `auth_request_id` | No | The request ID you received when the verification email was sent. <Badge variant="note" text="string" /> |

             <Aside type="caution" title="Auth request ID">
              If you use Magic Link or Magic Link + OTP and have enabled same browser origin enforcement in the Scalekit dashboard, it is required to include the auth request ID in your request.
            </Aside>
           </details>

           <details>
             <summary>Response parameters</summary>
             | Parameters | Description |
             |-----------|-------------|
             | `email` | The email address of the user <Badge variant="note" text="string" /> |
             | `state` | The state parameter that was passed in the original request <Badge variant="note" text="string" /> |
             | `template` | The template that was used for the verification code <Badge variant="note" text="string" /> |
             | `passwordless_type` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
           </details>
         </TabItem>
         <TabItem label="Node.js">
           ```js wrap showLineNumbers collapse={15-21}
           // User clicks the magic link in their email
           // Example magic link: https://yourapp.com/passwordless/verify?link_token=a4143d8f-d13d-415c-8f5a-5a5c846ed91e_l

           // 2. Express endpoint to handle the magic link verification
           app.get('/passwordless/verify', async (req, res) => {
             const { link_token } = req.query;

             try {
               // 3. Verify the magic link token with Scalekit
               const verifyResponse = await scalekit.passwordless
                 .verifyPasswordlessEmail(
                   { linkToken: link_token },
                   authRequestId // (optional) sendResponse.authRequestId
                 );

               // 4. Successfully log the user in
               // Set session/token and redirect to dashboard
               res.redirect('/dashboard');
             } catch (error) {
               res.status(400).json({
                    error: 'The magic link is invalid or has expired. Please request a new verification link.'
                });
             }
           });

           // verifyResponse = {
           //   "email": "saifshine7@gmail.com",
           //   "state": "jAy-state1-gM4fdZdV22nqm6Q_j..",
           //   "template": "SIGNIN",
           //   "passwordless_type": "OTP" | "LINK" | "LINK_OTP"
           // }
           ```
           <details>
             <summary>Request parameters</summary>
             | Parameters | Required | Description |
             |-----------|----------|-------------|
             | `options.linkToken` | Yes | The link token received by the user <Badge variant="note" text="string" /> |
             | `authRequestId` | No | The unique identifier for the authentication request that was sent earlier. <Badge variant="note" text="string" /> |
            <Aside type="caution" title="Auth request ID">
            If you use Magic Link or Magic Link + OTP and have enabled same browser origin enforcement in the Scalekit dashboard, it is required to include the auth request ID in your request.
            </Aside>
           </details>

           <details>
             <summary>Response parameters</summary>
             | Parameters | Description |
             |-----------|-------------|
             | `email` | The email address of the user <Badge variant="note" text="string" /> |
             | `state` | The state parameter that was passed in the original request <Badge variant="note" text="string" /> |
             | `template` | The template that was used for the verification code <Badge variant="note" text="string" /> |
             | `passwordlessType` | The type of passwordless authentication to use. Currently supports `OTP`, `LINK` and `LINK_OTP` <Badge variant="note" text="string" /> |
           </details>
         </TabItem>
       </Tabs>
     </TabItem>
   </Tabs>

   <Aside type="caution" title="Validation attempt limits">
     To protect your application, Scalekit allows a user only **five** attempts to enter the correct OTP within a ten-minute window.
     If the user exceeds this limit for an <code>auth_request_id</code>, the <code>/passwordless/email/verify</code> endpoint returns an **HTTP&nbsp;429&nbsp;Too&nbsp;Many&nbsp;Requests** error.
     To continue, the user must restart the authentication flow.
   </Aside>

</Steps>

Congratulations! You've successfully implemented passwordless authentication in your application. Users can now sign in securely without passwords by entering a verification code or clicking a magic link sent to their email.

## Next steps

- **Test your implementation**: Try the complete authentication flow to ensure everything works as expected
- **Enhance security**: Consider implementing rate limiting and suspicious activity monitoring
- **Customize emails**: Update the email templates to match your brand <Badge variant="note" text="Coming soon" />

<Aside type="tip" title="Best Practices">

- Always implement rate limiting on the client side to prevent abuse
- Provide clear error messages for invalid or expired codes
- Monitor failed authentication attempts for security purposes

</Aside>

================
File: guides/sso/admin-portal.mdx
================
---
title: Admin Portal
description: "Learn how to use Scalekit's Admin Portal to simplify SSO and SCIM configuration for your enterprise customers, with both no-code and embedded options."
sidebar:
  label: "Admin Portal"
prev: false
next:
  label: Launch checklist
  link: /sso/guides/launch-checklist/
---

import { LinkButton, Aside, Steps, Tabs, TabItem, CardGrid } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';
import { LinkCard } from '@astrojs/starlight/components';

The Admin Portal simplifies the process of connecting your application to the identity or directory providers used by enterprise organizations.

By offering a self-service portal for your customers, you can minimize the need for extensive back-and-forth communication. Scalekit hosts and manages the Admin Portal entirely, providing two flexible integration options — No-Code and Embedded portals.

## No-Code Admin Portal

A portal will show up for your customers to configure Single sign-on settings by accessing a shareable link. This portal contains the configuration settings that lets your customers setup a connection to their identity provider.

To create and share a link for the Admin Portal, follow these steps:

<Steps>
1. Log in to your [Scalekit Dashboard](https://app.scalekit.com)
2. Navigate to the "Organizations" tab
3. Select the organization you want to provide access to
4. Click "Generate Link" to create a new, shareable Admin Portal link
</Steps>
![Integrate via Shareable Link](@/assets/docs/home/admin-portal/1-admin-portal-v2.png)

```http title="Example" wrap showLineNumbers=false
https://your-app.scalekit.dev/magicLink/2cbe56de-eec4-41d2-abed-90a5b82286c4_p
```

The **link expires in 7 days** but can be revoked at any time from the dashboard for security purposes. You can share the link through communication channels such as email, Slack, or other preferred methods.

{/* ![Integrate via Shareable Link](@/assets/docs/common/admin-portal-2.png) */}

<Aside type="caution">
Be cautious when sharing the link, as anyone with access to it can view and update the organization's connection settings
</Aside>

### Customize the Admin Portal

Customizing your admin portal ensures that the interface aligns with your application's brand identity. Follow this guide to update your custom domain, upload your logo, adjust colors, and set a favicon—all of which create a seamless user experience.

Personalize your admin portal further by matching it to your brand. The following elements can be customized:

- **Logo**: Upload and display your company logo.
- **Colors**: Adjust the accent color to harmonize with your brand palette.
- **Favicon**: Set a favicon that represents your brand identity.

These customization options help ensure that the admin portal feels like an integrated extension of your application.


## Embedded Admin Portal

Users can do the connection setup right from your application by rendering Scalekit-hosted admin portal as a inline frame (iframe). This approach allows easy discovery & convenient access to the portal without the need for external links or separate portals.

Generate the embeddable portal link when page loads or refreshes and inject the `src` of the `<iframe>`, at your app's runtime. This ensure secure programmatic access.

<InstallSDK />

Use the **Generate Portal Link API** to create a unique, embeddable Admin Portal link specific to an organization.

<Tabs syncKey="tech-stack">
  <TabItem value="nodejs" label="Node.js">

    ```javascript
    import { Scalekit } from '@scalekit-sdk/node';

    const scalekit = new Scalekit(
      process.env.ENVIRONMENT_URL,
      process.env.CLIENT_ID,
      process.env.CLIENT_SECRET,
    );

    async function generatePortalLink(orgID) {
      const link = await scalekit.organization.generatePortalLink(orgID);
      console.log(JSON.stringify(link, null, 2));
    }
    ```

  </TabItem>

  <TabItem value="python" label="Python">

    ```python
    from scalekit import Scalekit

    scalekit = Scalekit(
        environment_url=os.environ.get("ENVIRONMENT_URL"),
        client_id=os.environ.get("CLIENT_ID"),
        client_secret=os.environ.get("CLIENT_SECRET")
    )

    def generate_portal_link(org_id):
        link = scalekit.organization.generate_portal_link(org_id)
        print(json.dumps(link, indent=2))
    ```

  </TabItem>

  <TabItem value="go" label="Go">

    ```go
    import (
        "context"
        "encoding/json"
        "fmt"
        "os"

        "github.com/scalekit/sdk-go"
    )

    func generatePortalLink(orgID string) {
        sc := scalekit.New(
            os.Getenv("ENVIRONMENT_URL"),
            os.Getenv("CLIENT_ID"),
            os.Getenv("CLIENT_SECRET"),
        )

        ctx := context.Background()
        link, err := sc.Organization.GeneratePortalLink(ctx, orgID)
        if err != nil {
            panic(err)
        }

        jsonData, _ := json.MarshalIndent(link, "", "  ")
        fmt.Println(string(jsonData))
    }
    ```

  </TabItem>

  <TabItem value="java" label="Java">

    ```java
    import com.scalekit.client.Scalekit;
    import com.scalekit.client.models.Link;
    import com.scalekit.client.models.Feature;

    import java.util.Arrays;

    public class PortalLinkGenerator {
        public static void main(String[] args) {
            Scalekit client = new Scalekit(
                System.getenv("ENVIRONMENT_URL"),
                System.getenv("CLIENT_ID"),
                System.getenv("CLIENT_SECRET")
            );

            Link portalLink = client
                .organizations()
                .generatePortalLink(
                    "org_12345",
                    Arrays.asList(Feature.sso, Feature.dir_sync)
                );

            System.out.println(portalLink.getLocation());
        }
    }
    ```

  </TabItem>
</Tabs>

The API will return a JSON object containing the `location` property, which is the URL to the Admin Portal.

```json title="Generate Portal Link (Response Object)" {3}
{
  "id": "8930509d-68cf-4e2c-8c6d-94d2b5e2db43",
  "location": "https://random-subdomain.scalekit.dev/magicLink/8930509d-68cf-4e2c-8c6d-94d2b5e2db43",
  "expireTime": "2024-10-03T13:35:50.563013Z"
}
```

Access the `location` property and set it as the `src` attribute of an iframe in your web pages at runtime. Ensure your domain is listed as one of the Redirect URIs in the **Scalekit Dashboard > API Config**

```html title="Render admin portal in iframe (example)" {3-9} wrap
<body>
  <h1>Admin Portal (Embed)</h1>
  <iframe
    src="https://random-subdomain.scalekit.dev/magicLink/8930509d-68cf-4e2c-8c6d-94d2b5e2db43"
    width="100%"
    height="600px"
    frameborder="0"
    allow="clipboard-write"
  >
  </iframe>
</body>
```

For example, if your application has a "Settings" page for your users, this page can allow them to configure connection with their IdP right within from your app.

{/* ![Integrate via API](@/assets/docs/common/admin-portal-3.png) */}

<Aside type="note">
1. The programmatically generated link is designed for one-time use and expires after 1 minute. Once activated in iframe, the IT admin can configure Single sign-on for an extended period. The session remains active until the setup is complete.
2. The embedded portal session times out after 6 hours, requiring administrators to complete the configuration within this period.
</Aside>

The Admin Portal can be customized to match your brand's logo and colors. Refer to the [customize Admin Portal](/guides/custom-domain/) for more information.

<CardGrid>

<LinkCard
  title="SSO integrations"
  description="Administrator guides to set up SSO integrations"
  href="/guides/integrations/sso-integrations/"
/>

<LinkCard
  title="Portal events"
  description="Listen to the browser events emitted from the embedded admin portal"
  href="/reference/admin-portal/ui-events/"
/>

</CardGrid>

================
File: guides/authenticate-scalekit-api.mdx
================
---
title: Authenticate with the Scalekit API
description: Learn how to authenticate your server applications with the Scalekit API using the OAuth 2.0 Client Credentials flow
sidebar:
  label: Authenticate Scalekit API
topic: dev-kit
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

This guide explains how to authenticate your server applications with the Scalekit API using the OAuth 2.0 Client Credentials flow. After reading this guide, you'll be able to:

* Generate an access token using your API credentials
* Make authenticated API requests to Scalekit endpoints
* Handle authentication errors appropriately

This guide targets developers who need to integrate Scalekit services into their backend applications or automate tasks through API calls.

## Before you begin

Before starting the authentication process, ensure you have set up your Scalekit account and obtained your API credentials.

## Step 1: Configure your environment

Store your API credentials securely as environment variables:

```sh title="Environment variables"
SCALEKIT_ENVIRONMENT_URL="<SCALEKIT_ENVIRONMENT_URL>"
SCALEKIT_CLIENT_ID="<SCALEKIT_CLIENT_ID>"
SCALEKIT_CLIENT_SECRET="<SCALEKIT_CLIENT_SECRET>"
```

## Step 2: Request an access token

To authenticate your API requests, you must first obtain an access token from the Scalekit authorization server.

### Token endpoint URL

```sh title="Token endpoint URL"
https://<SCALEKIT_ENVIRONMENT_URL>/oauth/token
```

### Send a token request

Choose your preferred method to request an access token:

<Tabs>
<TabItem value="curl" label="cURL">

```bash
curl -X POST \
  "https://<SCALEKIT_ENVIRONMENT_URL>/oauth/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials" \
  -d "client_id=<SCALEKIT_CLIENT_ID>" \
  -d "client_secret=<SCALEKIT_CLIENT_SECRET>" \
  -d "scope=openid profile email"
```

</TabItem>
<TabItem value="nodejs" label="Node.js">

```javascript
import axios from 'axios';

const config = {
  clientId: process.env.SCALEKIT_CLIENT_ID,
  clientSecret: process.env.SCALEKIT_CLIENT_SECRET,
  tokenUrl: `${process.env.SCALEKIT_ENVIRONMENT_URL}/oauth/token`,
  scope: 'openid email profile',
};

async function getClientCredentialsToken() {
  try {
    const params = new URLSearchParams();
    params.append('grant_type', 'client_credentials');
    params.append('client_id', config.clientId);
    params.append('client_secret', config.clientSecret);

    if (config.scope) {
      params.append('scope', config.scope);
    }

    const response = await axios.post(config.tokenUrl, params, {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
    });

    const { access_token, expires_in } = response.data;
    console.log(`Token acquired successfully. Expires in ${expires_in} seconds.`);
    return access_token;
  } catch (error) {
    console.error('Error getting client credentials token:', error);
    throw new Error('Failed to obtain access token');
  }
}
```

</TabItem>
<TabItem value="python" label="Python">

```python
import os
import json
import requests

def get_access_token():
    """Request an access token using client credentials."""
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    params = {
        "grant_type": "client_credentials",
        "client_id": os.environ['SCALEKIT_CLIENT_ID'],
        "client_secret": os.environ['SCALEKIT_CLIENT_SECRET']
    }
    oauth_token_url = os.environ['SCALEKIT_ENVIRONMENT_URL']

    response = requests.post(oauth_token_url, headers=headers, data=params, verify=True)
    access_token = response.json().get('access_token')
    return access_token
```

</TabItem>
</Tabs>

### Understand the token response

When your request succeeds, the server returns a JSON response with the following fields:

| Field | Description |
|-------|-------------|
| `access_token` | The token you'll use to authenticate API requests |
| `token_type` | The token type (always Bearer for this flow) |
| `expires_in` | Token validity period in seconds (typically 24 hours) |
| `scope` | The authorized scopes for this token |

Example token response:

```json title="Token response"
{
  "access_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6InNua181Ok4OTEyMjU2NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 86399,
  "scope": "openid"
}
```

## Step 3: Make authenticated API requests

After obtaining an access token, add it to the `Authorization` header in your API requests.

<Tabs>
<TabItem value="curl" label="cURL">

```bash
curl --request GET "https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access_token>"
```

</TabItem>
<TabItem value="nodejs" label="Node.js (axios)">

```javascript
async function makeAuthenticatedRequest(endpoint) {
  try {
    const access_token = await getClientCredentialsToken();
    const url = `${process.env.SCALEKIT_ENVIRONMENT_URL}${endpoint}`;

    const response = await axios.get(url, {
      headers: {
        Authorization: `Bearer ${access_token}`,
      },
    });

    console.log('API Response:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error making authenticated request:', error);
    throw error;
  }
}
```

</TabItem>
<TabItem value="python" label="Python (requests)">

```python
import os
import json
import requests

env_url = os.environ['SCALEKIT_ENVIRONMENT_URL']

def get_access_token():
    """Request an access token using client credentials."""
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    params = {
        "grant_type": "client_credentials",
        "client_id": os.environ['SCALEKIT_CLIENT_ID'],
        "client_secret": os.environ['SCALEKIT_CLIENT_SECRET']
    }

    response = requests.post(
        url=f"{env_url}/oauth/token",
        headers=headers,
        data=params,
        verify=True)

    access_token = response.json().get('access_token')
    return access_token

def get_organizations(get_orgs_endpoint):
    """Retrieve all organizations for the specified environment."""
    access_token = get_access_token()
    headers = {"Authorization": f"Bearer {access_token}"}

    response = requests.get(
        url=f"{env_url}/{get_orgs_endpoint}",
        headers=headers)
    return response
```

</TabItem>
</Tabs>

```json title="Example API response"
{
  "next_page_token": "",
  "total_size": 3,
  "organizations": [
    {
      "id": "org_64444217115541813",
      "create_time": "2025-03-20T13:55:46.690Z",
      "update_time": "2025-03-21T05:55:03.416772Z",
      "display_name": "Looney Corp",
      "region_code": "US",
      "external_id": "my_unique_id",
      "metadata": {}
    }
  ],
  "prev_page_token": ""
}
```

## Common authentication issues

| Issue | Possible cause | Solution |
|-------|---------------|----------|
| 401 Unauthorized | Invalid or expired token | Generate a new access token |
| 403 Forbidden | Insufficient permissions | Check client credentials scopes |
| Connection error | Network or server issue | Retry with exponential backoff |

## Next steps

Now that you can authenticate with the Scalekit API, you can:

* Browse the complete API reference to discover available endpoints
* Create a token management service to handle token refreshing
* Implement error handling strategies for production use

================
File: guides/client-credentials-practices.mdx
================
---
title: Best practices for client secrets
description: "Learn best practices for managing Scalekit client secrets, including secure storage, rotation procedures, and access control to protect your SSO implementation."
tableOfContents: false
sidebar:
  label: "Client secrets"
prev: false
next: false
---

import CheckItem from '@components/ui/CheckItem.astro';

Client ID and Client Secret are a form of API credentials, like a username and password. You are responsible for keeping Client Secrets safe and secure. Below are some best practices for how you can keep your secrets safe and how you can leverage some of the functionality offered by us to help you do the same.

<CheckItem iconName="approve-check-circle"> **Store secrets securely** </CheckItem>

Whenever a client secret is generated from the Scalekit Dashboard, it is shown only once and cannot be recovered. Therefore, it should be immediately stored in a secure Key Management System (KMS), which offers encryption and access control features. It is crucial not to leave a duplicate copy of the key in the local file.

<CheckItem iconName="approve-check-circle"> **Avoid insecure sharing** </CheckItem>

Sharing of secret keys through insecure channels, such as emails, Slack, or customer support messages, should be strictly avoided.

<CheckItem iconName="approve-check-circle"> **Prevent hardcoding** </CheckItem>

Storing client secrets within source code as hardcoded strings should be avoided. Instead, store them in your properties file or environments file. These files should not be checked into your source code repository.

<CheckItem iconName="approve-check-circle"> **Establish rotation procedures** </CheckItem>

Establishing a Standard Operating Procedure (SOP) for rotating Client Secrets can help in case of accidental secret leakage. Having such procedures in place will ensure a swift and effective response to emergencies, minimizing business impact.

<CheckItem iconName="approve-check-circle"> **Control access** </CheckItem>

Access to create, update, or read keys should be granted only to those individuals who require it for their roles. Regularly auditing access can prevent excess privilege allocation.

<CheckItem iconName="approve-check-circle"> **Monitor usage** </CheckItem>

Regular monitoring of API logs is recommended to identify potential misuse of API keys early. Developers should avoid using live mode keys when a test mode key is suitable.

<CheckItem iconName="approve-check-circle"> **Respond to incidents** </CheckItem>

If suspicious activity is detected or a secret leak is suspected, the current secret should be immediately revoked from the Scalekit Dashboard, and a new one should be generated. In case of uncertainty, it is better to generate a new secret and revoke the existing one.

================
File: guides/custom-domain.mdx
================
---
title: How to add a custom domain
description: Learn how to use a custom domain with Scalekit
sidebar:
  label: Custom domains
prev: false
next: false
---

import { Steps, Aside } from '@astrojs/starlight/components';

Custom domains enable you to offer a fully branded experience. By default, Scalekit assigns a unique endpoint URL, but you can replace it via CNAME configuration. This new URL becomes the base path for:

- The Admin Portal where your customers recognize your brand
- Single sign-on and SCIM Provisioning configuration details for setting up connections to identity providers
- The Scalekit REST API endpoints used by your applications

| Before | After |
|--------|-------|
| `https://yourapp.scalekit.com` | `https://auth.yourapp.com` |

<Aside type="note">
- **Integrations:** All existing integrations remain unaffected by the new CNAME URL if they were configured before the change with previous configuration
- **Environment:** CNAME configuration is available only for production environments
- **SSL:** After successful CNAME configuration, an SSL certificate for your custom domain is automatically provisioned
</Aside>

## Set up your custom domain

To set up your custom domain:

<Steps>
1. Go to your domain's DNS registrar
2. Add a new record to your DNS settings and select **CNAME** as the record type
3. Copy the **Name** (your desired subdomain) from the Scalekit dashboard and paste it into the **Name/Label/Host** field in your DNS registrar
4. Copy the **Value** from the Scalekit dashboard and paste it into the **Destination/Target/Value** field in your DNS registrar
5. Save the record in your DNS registrar. Note that CNAME record changes can take up to 72 hours to propagate, although they typically happen much sooner
6. In the Scalekit dashboard, click **Verify**
</Steps>

## Troubleshoot CNAME verification

If there are any issues during the CNAME verification step:
- Double-check your DNS configuration to ensure all values are correctly entered
- Once the CNAME changes take effect, Scalekit will automatically provision an SSL certificate for your custom domain. This process can take up to 24 hours

You can click on the **Check** button in the Scalekit dashboard to verify SSL certification status. If SSL provisioning takes longer than 24 hours, please contact us at <a href="mailto:support@scalekit.com" target="_blank">support@scalekit.com</a>

## DNS registrar guides

For detailed instructions on adding a CNAME record in specific registrars:
- <a href="https://www.godaddy.com/en-in/help/add-a-cname-record-19236" target="_blank">GoDaddy: Add a CNAME record</a>
- <a href="https://www.namecheap.com/support/knowledgebase/article.aspx/9646/2237/how-to-create-a-cname-record-for-your-domain" target="_blank">Namecheap: How to create a CNAME record</a>

================
File: guides/email-providers.mdx
================
---
title: "Personalize email delivery"
description: "Learn how to personalize email delivery by using Scalekit's managed service or configuring your own SMTP provider for brand consistency and control."
sidebar:
  label: "Personalize email delivery"
tableOfContents: true
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      .sl-markdown-content h3 {
        font-size: var(--sl-text-lg);
      }
---

import { Badge, LinkCard, CardGrid, Card, Steps, Aside, Tabs, TabItem } from '@astrojs/starlight/components';
import CheckItem from '@/components/ui/CheckItem.astro';

Email delivery is a critical part of your authentication flow. By default, Scalekit sends all authentication emails (sign-in verification, sign-up confirmation, password reset) through its own email service. However, for production applications, you may need more control over email branding, deliverability, and compliance requirements.

Here are common scenarios where you'll want to customize email delivery:

- **Brand consistency**: Send emails from your company's domain with your own sender name and email address to maintain brand trust
- **Deliverability optimization**: Use your established email reputation and delivery infrastructure to improve inbox placement
- **Compliance requirements**: Meet specific regulatory or organizational requirements for email handling and data sovereignty
- **Email analytics**: Track email metrics and performance through your existing email service provider
- **Custom domains**: Ensure emails come from your verified domain to avoid spam filters and build user trust
- **Enterprise requirements**: Corporate customers may require emails to come from verified business domains

Scalekit provides two approaches to handle email delivery, allowing you to choose the right balance between simplicity and control.

![Email delivery methods in Scalekit](@/assets/docs/common/email-providers/1-email-delivery-method.png)



## Use Scalekit's managed email service <Badge variant="note" text="Default"/>

   The simplest approach requires no configuration. Scalekit handles all email delivery using its own infrastructure.

   **When to use this approach:**
   - Quick setup for development and testing
   - You don't need custom branding
   - You want Scalekit to handle email deliverability

   **Default settings:**
   - **Sender Name**: Team workspace_name
   - **From Email Address**: hi@scalekit.com
   - **Infrastructure**: Fully managed by Scalekit

   No additional configuration is required. Your authentication emails will be sent automatically with these settings.

   <Aside type="tip">
   You can customize the sender name in your dashboard settings while still using Scalekit's email infrastructure.
   </Aside>

## Configure your own email provider

   For production applications, you'll likely want to use your own email provider to maintain brand consistency and control deliverability.

   When to use this approach:
   - You need emails sent from your domain
   - You want complete control over email deliverability
   - You need to meet compliance requirements (e.g. GDPR, CCPA)
   - You want to integrate with existing email analytics

### Gather your SMTP credentials

    Before configuring, collect the following information from your email provider:

    | Field | Description |
    |-------|-------------|
    | **SMTP Server Host** | Your provider's SMTP hostname |
    | **SMTP Port** | Usually 587 (TLS) or 465 (SSL) |
    | **SMTP Username** | Your authentication username |
    | **SMTP Password** | Your authentication password |
    | **Sender Email** | The email address emails will be sent from |
    | **Sender Name** | The display name recipients will see |

       ### Configure SMTP settings in Scalekit

    <Steps>
    1. Navigate to email settings

       In your Scalekit dashboard, go to **Emails**.

    2. Select custom email provider

       Choose **Use your own email provider** from the email delivery options

    3. Configure sender information

       ```
       From Email Address: noreply@yourdomain.com
       Sender Name: Your Company Name
       ```

    4. Enter SMTP configuration

       ```
       SMTP Server Host: smtp.your-provider.com
       SMTP Port: 587
       SMTP Username: your-username
       SMTP Password: your-password
       ```

    5. Save and test configuration

       Click **Save** to apply your settings, then send a test email to verify the configuration
    </Steps>

   ### Common provider configurations

   <Tabs>
      <TabItem label="SendGrid">
         ```
         Host: smtp.sendgrid.net
         Port: 587
         Username: apikey
         Password: [Your SendGrid API Key]
         ```
      </TabItem>

      <TabItem label="Amazon SES">
         ```
         Host: email-smtp.us-east-1.amazonaws.com
         Port: 587
         Username: [Your SMTP Username from AWS]
         Password: [Your SMTP Password from AWS]
         ```
      </TabItem>

      <TabItem label="Postmark">
         ```
         Host: smtp.postmarkapp.com
         Port: 587
         Username: [Your Postmark Server Token]
         Password: [Your Postmark Server Token]
         ```
      </TabItem>
   </Tabs>

   <Aside type="note">
   All SMTP credentials are encrypted and stored securely. Email transmission uses TLS encryption for security.
   </Aside>

## Test your email configuration

   After configuring your email provider, verify that everything works correctly:

   1. Send a test email through your authentication flow
   2. Check delivery to ensure emails reach the intended recipients
   3. Verify sender information appears correctly in the recipient's inbox
   4. Confirm formatting, branding, links and buttons work as expected

================
File: guides/external-ids-and-metadata.mdx
================
---
title: Managing organization identifiers & metadata
description: "Learn how to use external IDs and metadata to manage and track organizations in Scalekit, associating your own identifiers and storing custom key-value pairs."
sidebar:
  label: External IDs & Metadata
prev: false
next: false
topic: sso
---

import { Aside } from '@astrojs/starlight/components';

Applications often need to manage and track resources in their own systems. Scalekit provides two features to help with this:

* **External IDs**: Associate your own identifiers with organizations
* **Metadata**: Store custom key-value pairs with organizations

### When to use external IDs and metadata

Use these features when you need to:

* Track organizations using your own identifiers instead of Scalekit's IDs
* Store additional information about organizations like billing details or internal codes
* Integrate Scalekit organizations with your existing systems

### Add an external ID to an organization

External IDs let you identify organizations using your own identifiers. You can set an external ID when creating or updating an organization.

#### Create a new organization with an external ID

This example shows how to create an organization with your custom identifier:

```bash title="Create a new organization with an external ID"
curl https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations \
  --request POST \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "external_id": "CUST-12345-MGSFT",
}'
```

#### Update an existing organization's external ID

To change an organization's external ID, use the update endpoint:

```bash title="Update an existing organization's external ID"
curl 'https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations/{id}' \
  --request PATCH \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "external_id": "TENANT-12345-MGSFT",
}'
```

### Add metadata to an organization

Metadata lets you store custom information as key-value pairs. You can add metadata when creating or updating an organization.

#### Create a new organization with metadata

This example shows how to store billing information with a new organization:

```bash title="Create a new organization with metadata"
curl https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations \
  --request POST \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "metadata": {
    "invoice_email": "invoices@megasoft.com"
  }
}'
```

#### Update an existing organization's metadata

To modify an organization's metadata, use the update endpoint:

```bash title="Update an existing organization's metadata"
curl 'https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations/{id}' \
  --request PATCH \
  --header 'Content-Type: application/json' \
  --data '{
  "display_name": "Megasoft Inc",
  "metadata": {
    "invoice_email": "billing@megasoft.com"
  }
}'
```

### View external IDs and metadata

All organization endpoints that return organization details will include the external ID and metadata in their responses. This makes it easy to access your custom data when working with organizations.

================
File: guides/idtoken-claims.mdx
================
---
title: ID token claims
description: Reference for ID token claims
prev: false
next: false
---

An ID token is a JSON Web Token (JWT) containing cryptographically signed claims about a user's profile information. This is issued by Scalekit after successful authentication. The ID token is a Base64-encoded JSON object with three parts: header, payload, and signature.

Here's an example of the payload. Note this is formatted for readability and the header and signature fields are skipped.

```json title="Sample IdToken payload"

{
  "iss": "https://yoursaas.scalekit.com",
  "azp": "skc_12205605011849527",
  "aud": ["skc_12205605011849527"],
  "amr": ["conn_17576372041941092"],
  "sub": "conn_17576372041941092;google-oauth2|104630259163176101050",
  "at_hash": "HK6E_P6Dh8Y93mRNtsDB1Q",
  "c_hash": "HK6E_P6Dh8Y93mRNtsDB1Q",
  "iat": 1353601026,
  "exp": 1353604926,
  "name": "John Doe",
  "given_name": "John",
  "family_name": "Doe",
  "picture": "https://lh3.googleusercontent.com/a/ACg8ocKNE4TZj2kyLOj094kie_gDlUyU7JCZtbaiEma17URCEf=s96-c",
  "locale": "en",
  "email": "john.doe@acmecorp.com",
  "email_verified": true
}
```

## Full list of ID token claims

| Claim                                                              | Presence | Description                                  |
| ------------------------------------------------------------------ | -------- | -------------------------------------------- |
| `aud`            | Always   | Intended audience (client ID)                |
| `amr`            | Always   | Authentication method reference values       |
| `exp`            | Always   | Expiration time (Unix timestamp)             |
| `iat`            | Always   | Issuance time (Unix timestamp)               |
| `iss`            | Always   | Issuer identifier (Scalekit environment URL) |
| `oid`            | Always   | Organization ID of the user                  |
| `sub`            | Always   | Subject identifier for the user              |
| `at_hash`        | Always   | Access token hash                            |
| `c_hash`         | Always   | Authorization code hash                      |
| `azp`            | Always   | Authorized presenter (usually same as `aud`) |
| `email`          | Always   | User's email address                         |
| `email_verified` | Optional | Email verification status                    |
| `name`           | Optional | User's full name                             |
| `family_name`    | Optional | User's surname or last name                  |
| `given_name`     | Optional | User's given name or first name              |
| `locale`         | Optional | User's locale (BCP 47 language tag)          |
| `picture`        | Optional | URL of user's profile picture                |

## Verifying the ID token

In some cases, you may need to parse the ID token manually—for example, to access custom claims that are not part of the standard `User` object in the SDK method. These details are encoded in the ID token as JSON Web Token (JWT).

To verify the signature, you need to:

1.  Fetch the public signing keys from the JSON Web Key Set (JWKS) endpoint.
2.  Use a JWT library for your language to decode and verify the token using the keys.

The JWKS endpoint for your environment is located at:

```sh
https://<YOUR_ENVIRONMENT_URL>/keys
```

For example, if your Scalekit Environment URL is `https://your-environment.scalekit.com`, the keys can be found at `https://your-environment.scalekit.com/keys`.

### Important claims

When validating, pay special attention to these claims:

-   **`iss` (Issuer)**: This must match your Scalekit environment URL.
-   **`aud` (Audience)**: This must match your application's client ID.
-   **`exp` (Expiration Time)**: Ensure the token has not expired.
-   **`sub` (Subject)**: This uniquely identifies the user, often combining the `connection_id` and the identity provider's unique user ID.
-   **`amr`**: Contains the `connection_id` used for authentication.

This structure provides a neutral, factual reference for ID token claims in Scalekit, organized according to the data structure itself.

An ID token is nothing but a cryptographically signed Base64-encoded JSON object containing a set of name/value pairs about the user's profile information. Essentially, it is a JWT token. Ideally, it is advised that you validate an ID token before you use it, but since you are communicating directly with Scalekit over an intermediary-free HTTPS channel and using your client secret to exchange the `code` for the ID token, you can be confident that the token you receive really comes from Scalekit and is valid.

If you are using our Scalekit SDK to exchange the code for the ID token, the work of decoding the base64url-encoded values and parsing the JSON within, validating the JWT and accessing the claims within the ID token is automatically taken care of.

================
File: guides/setup-scalekit.mdx
================
---
title: Set up your Scalekit environment
description: "Learn how to set up your Scalekit environment, obtain API credentials, and instantiate the SDK to start building with our authentication services."
sidebar:
  label: Set up Scalekit
tableOfContents: false
prev: false
next: false
topic: sso
---

import { LinkButton, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx'

Before you start building, you'll need to set up your Scalekit environment and obtain your API credentials.

<Steps>
1. **Create a Scalekit Account**

   Scalekit provides dedicated environments for both development and production use. These environments function as extensions of your application where you can manage your authentication services.

   <LinkButton href="https://app.scalekit.com/ws/signup" variant="secondary" icon='right-arrow'>Create a Scalekit Account</LinkButton>

2. **Set up your Environments**

   After creating your account, you'll have access to two separate environments:

   ```txt showLineNumbers=false wrap title="Environment URLs"
   https://{your-subdomain}.scalekit.dev  (Development)
   https://{your-subdomain}.scalekit.com  (Production)
   ```

    Each environment is isolated, so resources created in one cannot be transferred to another. You can customize the environment URLs such as `auth.example.com` by adding a custom domain.

   You can view your environment URLs by navigating to **Scalekit Dashboard > API Config**.

3. **Obtain your API credentials**

   Scalekit uses the OAuth 2.0 client credentials flow for secure API authentication. This approach provides better security than simple API keys, as your environment and its resources function as extensions of your application's authentication service.

   From the API Config section, note down these three essential values:

   ```sh showLineNumbers=false wrap title="Environment variables"
   SCALEKIT_ENVIRONMENT_URL=<your-environment-url>
   # Example: https://acme.scalekit.dev or https://auth.acme.com

   SCALEKIT_CLIENT_ID=<app-client-id>
   # Example: skc_1234567890abcdef

   SCALEKIT_CLIENT_SECRET=<app-client-secret>
   # Example: test_abcdef1234567890
   ```

4. **Instantiate the SDK**

   <InstallSDK />

    <Tabs syncKey="tech-stack">
      <TabItem value="nodejs" label="Node.js">

      ```js
      import { ScalekitClient } from '@scalekit-sdk/node';

      // Create the Scalekit client
      const scalekit = new ScalekitClient(
        process.env.SCALEKIT_ENVIRONMENT_URL,
        process.env.SCALEKIT_CLIENT_ID,
        process.env.SCALEKIT_CLIENT_SECRET
      );
      ```

      </TabItem>
      <TabItem value="py" label="Python">

      ```python
      from scalekit import ScalekitClient

      # Create the Scalekit client
      scalekit = ScalekitClient(
        '<SCALEKIT_ENVIRONMENT_URL>',
        '<SCALEKIT_CLIENT_ID>',
        '<SCALEKIT_CLIENT_SECRET>'
      )
      ```

      </TabItem>
      <TabItem value="go" label="Go">

      ```go
      import (
        "github.com/scalekit/scalekit-sdk-go"
      )

      // Create the Scalekit client
      scalekitClient := scalekit.NewScalekitClient(
        os.Getenv("SCALEKIT_ENVIRONMENT_URL"),
        os.Getenv("SCALEKIT_CLIENT_ID"),
        os.Getenv("SCALEKIT_CLIENT_SECRET")
      )
      ```

      </TabItem>
      <TabItem value="java" label="Java">

      ```java
      import com.scalekit.ScalekitClient;

      // Create the Scalekit client
      ScalekitClient scalekitClient = new ScalekitClient(
        System.getenv("SCALEKIT_ENVIRONMENT_URL"),
        System.getenv("SCALEKIT_CLIENT_ID"),
        System.getenv("SCALEKIT_CLIENT_SECRET")
      );
      ```

      </TabItem>
    </Tabs>

</Steps>

================
File: guides/webhooks-best-practices.mdx
================
---
title: 'Best practices for webhooks'
description: 'Learn best practices for implementing webhooks in your SCIM integration. Covers security measures, event handling, signature verification, and performance optimization techniques for real-time directory updates.'
sidebar:
  label: 'Webhook best practices'
prev: false
next: false
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';


Webhooks are HTTP endpoints that you register with a system, allowing that system to inform your application about events by sending HTTP POST requests with event information in the body.

Developers register their applications' webhook endpoints with Scalekit to listen to events from the directory providers of their enterprise customers. Here are some common best practices developers follow to ensure their apps are secure and performant:

## Subscribe only to relevant events

While you can listen to all events from Scalekit, it's best to subscribe only to the events your app needs. This approach has several benefits:

- Your app doesn't have to process every event
- You can avoid overloading a single execution context by handling every event type

## Verify webhook signatures

Scalekit sends POST requests to your registered webhook endpoint. To ensure the request is coming from Scalekit and not a malicious actor, you should verify the request using the signing secret found in the Scalekit dashboard > Webhook > _Any Endpoint_.

Here's an example of how to verify webhooks using the Svix library:

<Tabs>
<TabItem label="Node.js">

```javascript
app.post('/webhook', async (req, res) => {
  // Parse the JSON body of the request
  const event = await req.json();

  // Get headers from the request
  const headers = req.headers;

  // Secret from Scalekit dashboard > Webhooks
  const secret = process.env.SCALEKIT_WEBHOOK_SECRET;

  try {
    // Verify the webhook payload
    await scalekit.verifyWebhookPayload(secret, headers, event);
  } catch (error) {
    return res.status(400).json({
      error: 'Invalid signature',
    });
  }
});
```
</TabItem>

<TabItem label="Python">

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/webhook")
async def api_webhook(request: Request):
    # Get request data
    body = await request.body()

    # Extract webhook headers
    headers = {
        'webhook-id': request.headers.get('webhook-id'),
        'webhook-signature': request.headers.get('webhook-signature'),
        'webhook-timestamp': request.headers.get('webhook-timestamp')
    }

    # Verify webhook signature
    is_valid = scalekit.verify_webhook_payload(
        secret='<secret>',
        headers=headers,
        payload=body
    )
    print(is_valid)

    return JSONResponse(
        status_code=201,
        content=''
    )
```
</TabItem>

<TabItem label="Go">

```go
mux.HandleFunc("POST /webhook", func(w http.ResponseWriter, r *http.Request) {
    webhookSecret := os.Getenv("SCALEKIT_WEBHOOK_SECRET")

    // Read request body
    bodyBytes, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Prepare headers for verification
    headers := map[string]string{
        "webhook-id":        r.Header.Get("webhook-id"),
        "webhook-signature": r.Header.Get("webhook-signature"),
        "webhook-timestamp": r.Header.Get("webhook-timestamp"),
    }

    // Verify webhook signature
    _, err = sc.VerifyWebhookPayload(
        webhookSecret,
        headers,
        bodyBytes
    )
    if err != nil {
        http.Error(w, err.Error(), http.StatusUnauthorized)
        return
    }
})
```
</TabItem>

<TabItem label="Java">

```java
@PostMapping("/webhook")
public String webhook(@RequestBody String body, @RequestHeader Map<String, String> headers) {
  String secret = "<WEBHOOK SECRET>";

  // Verify webhook signature
  boolean valid = scalekit.webhook().verifyWebhookPayload(secret, headers, body.getBytes());

  if (!valid) {
    return "error";
  }

  ObjectMapper mapper = new ObjectMapper();

  try {
    // Parse event data
    JsonNode node = mapper.readTree(body);
    String eventType = node.get("type").asText();
    JsonNode data = node.get("data");

    // Handle different event types
    switch (eventType) {
      case "organization.directory.user_created":
        handleUserCreate(data);
        break;
      case "organization.directory.user_updated":
        handleUserUpdate(data);
        break;
      default:
        System.out.println("Unhandled event type: " + eventType);
    }
  } catch (IOException e) {
    return "error";
  }

  return "ok";
}
```
</TabItem>
</Tabs>

## Check the event type before processing

Make sure to check the event.type before consuming the data received by the webhook endpoint. This ensures that your application relies on accurate information, even if more events are added in the future.

<Tabs>
<TabItem label="Node.js">

```javascript
app.post('/webhook', async (req, res) => {
  const event = req.body;

  // Handle different event types
  switch (event.type) {
    case 'organization.directory.user_created':
      const { email, name } = event.data;
      await createUserAccount(email, name);
      break;

    case 'organization.directory.user_updated':
      await updateUserAccount(event.data);
      break;

    default:
      console.log('Unhandled event type:', event.type);
  }

  return res.status(201).json({
    status: 'success',
  });
});

async function createUserAccount(email, name) {
  // Implement your user creation logic
}
```
</TabItem>

<TabItem label="Python">

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/webhook")
async def api_webhook(request: Request):
    # Parse request body
    body = await request.body()
    payload = json.loads(body.decode())
    event_type = payload['type']

    # Handle different event types
    match event_type:
        case 'organization.directory.user_created':
            await handle_user_create(payload['data'])
        case 'organization.directory.user_updated':
            await handle_user_update(payload['data'])
        case _:
            print('Unhandled event type:', event_type)

    return JSONResponse(
        status_code=201,
        content={'status': 'success'}
    )
```
</TabItem>

<TabItem label="Go">

```go
mux.HandleFunc("POST /webhook", func(w http.ResponseWriter, r *http.Request) {
    // Read and verify webhook payload
    bodyBytes, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Parse event data
    var event map[string]interface{}
    err = json.Unmarshal(bodyBytes, &event)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Handle different event types
    eventType := event["type"]
    switch eventType {
    case "organization.directory.user_created":
        handleUserCreate(event["data"])
    case "organization.directory.user_updated":
        handleUserUpdate(event["data"])
    default:
        fmt.Println("Unhandled event type:", eventType)
    }

    w.WriteHeader(http.StatusOK)
})
```
</TabItem>

<TabItem label="Java">

```java
@PostMapping("/webhook")
public String webhook(@RequestBody String body, @RequestHeader Map<String, String> headers) {
  // Verify webhook signature first
  String secret = "<WEBHOOK_SECRET>";
  if (!verifyWebhookSignature(secret, headers, body)) {
    return "error";
  }

  try {
    // Parse event data
    ObjectMapper mapper = new ObjectMapper();
    JsonNode node = mapper.readTree(body);
    String eventType = node.get("type").asText();
    JsonNode data = node.get("data");

    // Handle different event types
    switch (eventType) {
      case "organization.directory.user_created":
        handleUserCreate(data);
        break;
      case "organization.directory.user_updated":
        handleUserUpdate(data);
        break;
      default:
        System.out.println("Unhandled event type: " + eventType);
    }
  } catch (IOException e) {
    return "error";
  }

  return "ok";
}
```
</TabItem>
</Tabs>

## Avoid webhook timeouts

To avoid unnecessary timeouts, respond to the webhook trigger with a response code of 201 and process the event asynchronously.

By following these best practices, you can ensure that your application effectively handles events from Scalekit, maintaining optimal performance and security.

## Do not ignore errors

Do not overlook repeated 4xx and 5xx error codes. Instead, verify that your API interactions are correct. For instance, if an endpoint expects a string but receives a numeric value, a validation error should occur. Likewise, trying to access an unauthorized or nonexistent endpoint will trigger a 4xx error.

================
File: m2m/quickstart.mdx
================
---
title: API Authentication quickstart
description: "Learn how to add secure authentication to your APIs in minutes with Scalekit, including client registration, OAuth 2.0, and token validation."
sidebar:
  label: "Quickstart"
---

import { LinkButton, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

> Add secure authentication to your APIs

Learn how to add authentication to your APIs in minutes. This guide shows you how to:

- Register API clients that need to access your services
- Set up OAuth 2.0 authentication using client credentials
- Validate access tokens to ensure only authorized clients can call your APIs

**Who is this for?** This guide is for developers who want to secure their APIs and control which external systems can access them.

**Prerequisites:**
- A Scalekit account ([sign up here](https://app.scalekit.com/ws/signup) if you don't have one)
- Basic understanding of REST APIs
- Familiarity with OAuth 2.0 (optional)

<InstallSDK />

<Steps>

1. ## Register an API client

    Before an application can access your API, you need to register it as a client. This creates secure credentials that the app developers will use to authenticate its API requests.

    When you register a client, you'll receive a unique client ID and secret - similar to a username and password for applications. Present it to your API client developers to use in their code.

    <Tabs syncKey="tech-stack">
    <TabItem value="curl" label="cURL">

    ```sh wrap {2, 4} title="POST /organizations/{organization_id}/clients"
    # For authentication details, see: http://docs.scalekit.com/apis#description/authentication
    curl -L 'https://<SCALEKIT_ENVIRONMENT_URL>/api/v1/organizations/<ORGANIZATION_ID>/clients' \
    -H 'Content-Type: application/json' \
    -H 'Authorization: Bearer <SCALEKIT_ACCESS_TOKEN>' \
    -d '{
        "name": "GitHub Actions Deployment Service",
        "description": "Service account for GitHub Actions to deploy applications to production",
        "custom_claims": [
            {
                "key": "github_repository",
                "value": "acmecorp/inventory-service"
            },
            {
                "key": "environment",
                "value": "production_us"
            }
        ],
        "scopes": [
            "deploy:applications",
            "read:deployments"
        ],
        "audience": [
            "deployment-api.acmecorp.com"
        ],
        "expiry": 3600
    }'
    ```

    </TabItem>
    <TabItem value="python" label="Python">

    ```python wrap {23}
    from scalekit.v1.clients.clients_pb2 import OrganizationClient

    org_id = "<SCALEKIT_ORGANIZATION_ID>"

    api_client = OrganizationClient(
        name="GitHub Actions Deployment Service",
        description="Service account for GitHub Actions to deploy applications to production",
        custom_claims=[
            {
                "key": "github_repository",
                "value": "acmecorp/inventory-service"
            },
            {
                "key": "environment",
                "value": "production_us"
            }
        ],
        scopes=["deploy:applications", "read:deployments"],
        audience=["deployment-api.acmecorp.com"],
        expiry=3600
    )

    response = scalekit_client.m2m_client.create_organization_client(
        organization_id=org_id,
        m2m_client=api_client
    )
    ```

    </TabItem>
    </Tabs>

    <details>
    <summary>API client registration parameters</summary>

    | Parameter | Type | Description |
    |-----------|------|-------------|
    | <pre>name</pre> | <pre>string</pre> | A descriptive name for the API client (e.g., "GitHub Actions Deployment Service") |
    | <pre>description</pre> | <pre>string</pre> | A detailed explanation of the client's purpose and usage |
    | <pre>custom_claims</pre> | <pre>array</pre> | Key-value pairs that provide additional context about the client. Each claim must have a `key` and `value` field |
    | <pre>scopes</pre> | <pre>array</pre> | List of permissions the client needs (e.g., ["deploy:applications", "read:deployments"]) |
    | <pre>audience</pre> | <pre>array</pre> | List of API endpoints this client will access (e.g., ["deployment-api.acmecorp.com"]) |
    | <pre>expiry</pre> | <pre>number</pre> | Token expiration time in seconds. Defaults to 3600 (1 hour) |

    </details>

    The API response contains the client details, including the `client_id` and `client_secret`.

    ```json title="Register an API client API response" wrap
    {
        "client": {
            "client_id": "m2morg_68315758685323697",
            "secrets": [
                {
                    "id": "sks_68315758802764209",
                    "create_time": "2025-04-16T06:56:05.360Z",
                    "update_time": "2025-04-16T06:56:05.367190455Z",
                    "secret_suffix": "UZ0X",
                    "status": "ACTIVE",
                    "last_used_time": "2025-04-16T06:56:05.360Z"
                }
            ],
            "name": "GitHub Actions Deployment Service",
            "description": "Service account for GitHub Actions to deploy applications to production",
            "organization_id": "org_59615193906282635",
            "create_time": "2025-04-16T06:56:05.290Z",
            "update_time": "2025-04-16T06:56:05.292145150Z",
            "scopes": [
                "deploy:applications",
                "read:deployments"
            ],
            "audience": [
                "deployment-api.acmecorp.com"
            ],
            "custom_claims": [
                {
                    "key": "github_repository",
                    "value": "acmecorp/inventory-service"
                },
                {
                    "key": "environment",
                    "value": "production_us"
                }
            ]
        },
        "plain_secret": "test_ly8G57h0ErRJSObJI6dShkoaq6bigo11Dxcfa6reKG1kKNVbqBKW4H5Ctmb5UZ0X"
    }
    ```

    <Aside type="note">
    Scalekit only returns the `plain_secret` once during client creation and does not store it. Instruct your API client developers to store the `plain_secret` securely.
    </Aside>

2. ## Authenticate the API client

    After registration, the API client authenticates with your Scalekit environment using its `client_id` and `client_secret` (the `plain_secret` obtained earlier) to request an access token. This process uses the OAuth 2.0 client credentials grant type.

    The client sends a POST request to the `/oauth/token` endpoint:

    <Tabs syncKey="tech-stack">
    <TabItem value="curl" label="cURL">

    ```sh wrap {2, 4} title="POST /oauth/token"
    curl -X POST \
      "https://<SCALEKIT_ENVIRONMENT_URL>/oauth/token" \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -d "grant_type=client_credentials" \
      -d "client_id=<API_CLIENT_ID>" \
      -d "client_secret=<API_CLIENT_SECRET>" \
    ```

    </TabItem>
    <TabItem value="python" label="Python">

    ```python showLineNumbers
    client_id = "API_CLIENT_ID"
    client_secret = "API_CLIENT_SECRET"

    token_response = scalekit_client.generate_client_token(
        client_id=client_id,
        client_secret=client_secret
    )
    ```

    </TabItem>
    </Tabs>

    Upon successful authentication, Scalekit issues a JWT access token.

    ```json title="Access token response" wrap {2,6}
    {
      "access_token":"<API_CLIENT_JWT_ACCESS_TOKEN>",
      "token_type":"Bearer",
      "expires_in":86399,
      // Same scopes that were granted during client registration
      "scope":"deploy:applications read:deployments"
    }
    ```

    The client includes this access token in the `Authorization` header of subsequent requests to your API server.

3. ## Validate access tokens in your API server

    Your API server must validate the incoming JWT access token to ensure the request originates from a trusted API client and that the token is legitimate.

    Validate the token in two steps:

    <Steps>

    1.  **Retrieve the public key:** Fetch the appropriate public key from your Scalekit environment's JSON Web Key Set (JWKS) endpoint. Use the `kid` (Key ID) from the JWT header to identify the correct key. Cache the key according to standard JWKS practices.

        <Tabs syncKey="tech-stack">
        <TabItem value="javascript" label="Node.js">

        ```js showLineNumbers
        import jwksClient from 'jwks-rsa';

        const client = jwksClient({
        jwksUri: 'YOUR_JWKS_URI',
        cache: true
        });

        async function getPublicKey(header: any): Promise<string> {
        return new Promise((resolve, reject) => {
            client.getSigningKey(header.kid, (err, key) => {
            if (err) reject(err);
            else resolve(key.getPublicKey());
            });
        });
        }
        ```

        </TabItem>
        <TabItem value="python" label="Python">

        ```py showLineNumbers
        # This is automatically handled by Scalekit SDK
        token = token_response["<API_CLIENT_JWT_ACCESS_TOKEN>"]

        claims = scalekit_client.validate_access_token_and_get_claims(
            token=token
        )
        ```

        </TabItem>
        </Tabs>

    2.  **Verify the token signature:** Use the retrieved public key and a JWT library to verify the token's signature and claims (like issuer, audience, and expiration).

        <Tabs syncKey="tech-stack">
        <TabItem value="javascript" label="Node.js">

        ```js showLineNumbers
        import jwt from 'jsonwebtoken';

        async function verifyToken(token: string, publicKey: string) {
        try {
            const decoded = jwt.decode(token, { complete: true });
            const verified = jwt.verify(token, publicKey, {
            algorithms: ['RS256'],
            complete: true
            });
            return verified.payload;
        } catch (error) {
            throw new Error('Token verification failed');
        }
        }
        ```

        </TabItem>
        <TabItem value="python" label="Python">

        ```py showLineNumbers
        # Token from the incoming API request's authorization header
        token = token_response["<API_CLIENT_JWT_ACCESS_TOKEN>"]

        claims = scalekit_client.validate_access_token_and_get_claims(
            token=token
        )
        ```

        </TabItem>
        </Tabs>
    </Steps>

    Find complete code examples in the <a href="https://github.com/scalekit-developers/gists/tree/main/m2m" target="_blank">Scalekit M2M Gists repository</a>.

    If the token verification succeeds, your API server can trust the request's authenticity and proceed with processing it based on the permissions (scopes) encoded within the token.

</Steps>

================
File: reference/webhooks/directory-events.mdx
================
---
title: Directory events
description: "Explore the webhook events related to directory operations in Scalekit, including user and group creation, updates, and deletions."
sidebar:
  label: Directory events
  order: 3
tableOfContents: true
overviewTitle: "Directory events"
next: false
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
      starlight-toc > nav {
        width: max-content;
      }
---

import { Aside, Badge, CardGrid } from '@astrojs/starlight/components';
import SimpleList from '@components/ui/SimpleList.astro';

This page documents the webhook events related to directory operations in Scalekit.

----

### `organization.directory_enabled`

This webhook is triggered when a directory sync is enabled. The event type is `organization.directory_enabled`

```json title="organization.directory_enabled"
{
  "environment_id": "env_27758032200925221",
  "id": "evt_55136848686613000",
  "object": "Directory",
  "occurred_at": "2025-01-15T08:55:22.802860294Z",
  "organization_id": "org_55135410258444802",
  "spec_version": "1",
  "type": "organization.directory_enabled",
  "data": {
    "directory_type": "SCIM",
    "enabled": false,
    "id": "dir_55135622825771522",
    "organization_id": "org_55135410258444802",
    "provider": "OKTA",
    "updated_at": "2025-01-15T08:55:22.792993454Z"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier for the directory connection |
| `directory_type` | string | The type of directory synchronization |
| `enabled` | boolean | Indicates if the directory sync is enabled |
| `environment_id` | string | Identifier for the environment |
| `last_sync_at` | null | Timestamp of the last synchronization, null if not yet synced |
| `organization_id` | string | Identifier for the organization |
| `provider` | string | The provider of the directory |
| `updated_at` | string | Timestamp of when the configuration was last updated |
| `occurred_at` | string | Timestamp of when the event occurred |

### `organization.directory_disabled`

This webhook is triggered when a directory sync is disabled. The event type is `organization.directory_disabled`

```json title="organization.directory_disabled"
{
  "spec_version": "1",
  "id": "evt_53891640779079756",
  "type": "organization.directory_disabled",
  "occurred_at": "2025-01-06T18:45:21.057814Z",
  "environment_id": "env_53814739859406915",
  "organization_id": "org_53879494091473415",
  "object": "Directory",
  "data": {
    "directory_type": "SCIM",
    "enabled": false,
    "id": "dir_53879621145330183",
    "organization_id": "org_53879494091473415",
    "provider": "OKTA",
    "updated_at": "2025-01-06T18:45:21.04978184Z"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `directory_type` | string | Type of directory protocol used for synchronization |
| `enabled` | boolean | Indicates whether the directory synchronization is currently enabled or disabled |
| `id` | string | Unique identifier for the directory connection |
| `last_sync_at` | string | Timestamp of the most recent directory synchronization |
| `organization_id` | string | Unique identifier of the organization associated with this directory |
| `provider` | string | Identity provider for the directory connection |
| `status` | string | Current status of the directory synchronization process |
| `updated_at` | string | Timestamp of the most recent update to the directory connection |
| `occurred_at` | string | Timestamp of when the event occurred |

## Directory User Events

###  `organization.directory.user_created`

This webhook is triggered when a new directory user is created. The event type is `organization.directory.user_created`

```json title="organization.directory.user_created"
{
  "spec_version": "1",
  "id": "evt_53891546994442316",
  "type": "organization.directory.user_created",
  "occurred_at": "2025-01-06T18:44:25.153954Z",
  "environment_id": "env_53814739859406915",
  "organization_id": "org_53879494091473415",
  "object": "DirectoryUser",
  "data": {
    "active": true,
    "cost_center": "QAUZJUHSTYCN",
    "custom_attributes": {
      "mobile_phone_number": "1-579-4072"
    },
    "department": "HNXJPGISMIFN",
    "division": "MJFUEYJOKICN",
    "dp_id": "<id from IDP>",
    "email": "flavio@runolfsdottir.co.duk",
    "employee_id": "AWNEDTILGaIZN",
    "family_name": "Jaquelin",
    "given_name": "Dayton",
    "groups": [
      {
        "id": "dirgroup_12312312312312",
        "name": "Group Name"
      }
    ],
    "id": "diruser_53891546960887884",
    "language": "se",
    "locale": "LLWLEWESPLDC",
    "name": "QURGUZZDYMFU",
    "nickname": "DTUODYKGFPPC",
    "organization": "AUIITQVUQGVH",
    "organization_id": "org_53879494091473415",
    "phone_number": "1-579-4072",
    "preferred_username": "kuntala1233a",
    "profile": "YMIUQUHKGVAX",
    "raw_attributes": {},
    "title": "FKQBHCWJXZSC",
    "user_type": "RBQFJSQEFAEH",
    "zoneinfo": "America/Araguaina",
    "roles": [
      {
        "role_name": "billing_admin"
      }
    ]
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique ID of the Directory User |
| `organization_id` | string | Unique ID of the Organization to which this directory user belongs |
| `dp_id` | string | Unique ID of the User in the Directory Provider (IdP) system |
| `preferred_username` | string | Preferred username of the directory user |
| `email` | string | Email of the directory user |
| `active` | boolean | Indicates if the directory user is active |
| `name` | string | Fully formatted name of the directory user |
| `roles` | array | Array of roles assigned to the directory user |
| `groups` | array | Array of groups to which the directory user belongs |
| `given_name` | string | Given name of the directory user |
| `family_name` | string | Family name of the directory user |
| `nickname` | string | Nickname of the directory user |
| `picture` | string | URL of the directory user's profile picture |
| `phone_number` | string | Phone number of the directory user |
| `address` | object | Address of the directory user |
| `custom_attributes` | object | Custom attributes of the directory user |
| `raw_attributes` | object | Raw attributes of the directory user as received from the Directory Provider (IdP) |

### `organization.directory.user_updated`

This webhook is triggered when a directory user is updated. The event type is `organization.directory.user_updated`

```json title="organization.directory.user_updated"
{
  "spec_version": "1",
  "id": "evt_53891546994442316",
  "type": "organization.directory.user_updated",
  "occurred_at": "2025-01-06T18:44:25.153954Z",
  "environment_id": "env_53814739859406915",
  "organization_id": "org_53879494091473415",
  "object": "DirectoryUser",
  "data": {
    "id": "diruser_12312312312312",
    "organization_id": "org_53879494091473415",
    "dp_id": "<scim_external_id>",
    "preferred_username": "<idp_user_name>",
    "email": "john.doe@example.com",
    "active": true,
    "name": "John Doe",
    "roles": [
      {
        "role_name": "billing_admin"
      }
    ],
    "groups": [
      {
        "id": "dirgroup_12312312312312",
        "name": "Group Name"
      }
    ],
    "given_name": "John",
    "family_name": "Doe",
    "nickname": "Jhonny boy",
    "picture": "https://image.com/profile.jpg",
    "phone_number": "1234567892",
    "address": {
      "postal_code": "64112",
      "state": "Missouri",
      "formatted": "123, Oxford Lane, Kansas City, Missouri, 64112"
    },
    "custom_attributes": {
      "attribute1": "value1",
      "attribute2": "value2"
    },
    "raw_attributes": {}
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique ID of the Directory User |
| `organization_id` | string | Unique ID of the Organization to which this directory user belongs |
| `dp_id` | string | Unique ID of the User in the Directory Provider (IdP) system |
| `preferred_username` | string | Preferred username of the directory user |
| `email` | string | Email of the directory user |
| `active` | boolean | Indicates if the directory user is active |
| `name` | string | Fully formatted name of the directory user |
| `roles` | array | Array of roles assigned to the directory user |
| `groups` | array | Array of groups to which the directory user belongs |
| `given_name` | string | Given name of the directory user |
| `family_name` | string | Family name of the directory user |
| `nickname` | string | Nickname of the directory user |
| `picture` | string | URL of the directory user's profile picture |
| `phone_number` | string | Phone number of the directory user |
| `address` | object | Address of the directory user |
| `custom_attributes` | object | Custom attributes of the directory user |
| `raw_attributes` | object | Raw attributes of the directory user as received from the Directory Provider (IdP) |

#### `organization.directory.user_deleted`

This webhook is triggered when a directory user is deleted. The event type is `organization.directory.user_deleted`

```json title="organization.directory.user_deleted"
{
  "spec_version": "1",
  "id": "evt_53891546994442316",
  "type": "organization.directory.user_deleted",
  "occurred_at": "2025-01-06T18:44:25.153954Z",
  "environment_id": "env_53814739859406915",
  "organization_id": "org_53879494091473415",
  "object": "DirectoryUser",
  "data": {
    "id": "diruser_12312312312312",
    "organization_id": "org_12312312312312",
    "dp_id": "<scim_external_id>",
    "email": "john.doe@example.com"
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique ID of the Directory User |
| `organization_id` | string | Unique ID of the Organization to which this directory user belongs |
| `dp_id` | string | Unique ID of the User in the Directory Provider (IdP) system |
| `email` | string | Email of the directory user |

## Directory Group Events

### `organization.directory.group_created`

This webhook is triggered when a new directory group is created. The event type is `organization.directory.group_created`

```json title="organization.directory.group_created"
{
  "spec_version": "1",
  "id": "evt_38862741515010639",
  "environment_id": "env_32080745237316098",
  "object": "DirectoryGroup",
  "occurred_at": "2024-09-25T02:26:39.036398577Z",
  "organization_id": "org_38609339635728478",
  "type": "organization.directory.group_created",
  "data": {
    "directory_id": "dir_38610496391217780",
    "display_name": "Avengers",
    "external_id": null,
    "id": "dirgroup_38862741498233423",
    "organization_id": "org_38609339635728478",
    "raw_attributes": {}
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `directory_id` | string | Unique identifier for the directory |
| `display_name` | string | Display name of the directory group |
| `external_id` | null | External identifier for the group, null if not specified |
| `id` | string | Unique identifier for the directory group |
| `organization_id` | string | Identifier for the organization associated with the group |
| `raw_attributes` | object | Raw attributes of the directory provider |

### `organization.directory.group_updated`

This webhook is triggered when a directory group is updated. The event type is `organization.directory.group_updated`

```json title="organization.directory.group_updated"
{
  "spec_version": "1",
  "id": "evt_38864948910162368",
  "organization_id": "org_38609339635728478",
  "type": "organization.directory.group_updated",
  "environment_id": "env_32080745237316098",
  "object": "DirectoryGroup",
  "occurred_at": "2024-09-25T02:48:34.745030921Z",
  "data": {
    "directory_id": "dir_38610496391217780",
    "display_name": "Avengers",
    "external_id": "<external_id>",
    "id": "dirgroup_38862741498233423",
    "organization_id": "org_38609339635728478",
    "raw_attributes": {}
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `directory_id` | string | Unique identifier for the directory |
| `display_name` | string | Display name of the directory group |
| `external_id` | null | External identifier for the group, null if not specified |
| `id` | string | Unique identifier for the directory group |
| `organization_id` | string | Identifier for the organization associated with the group |
| `raw_attributes` | object | Raw attributes of the directory group |

### `organization.directory.group_deleted`

This webhook is triggered when a directory group is deleted. The event type is `organization.directory.group_deleted`

```json title="organization.directory.group_deleted"
{
  "spec_version": "1",
  "id": "evt_40650399597723966",
  "environment_id": "env_12205603854221623",
  "object": "DirectoryGroup",
  "occurred_at": "2024-10-07T10:25:26.289331747Z",
  "organization_id": "org_39802449573184223",
  "type": "organization.directory.group_deleted",
  "data": {
    "directory_id": "dir_39802485862301855",
    "display_name": "Admins",
    "dp_id": "7c66a173-79c6-4270-ac78-8f35a8121e0a",
    "id": "dirgroup_40072007005503806",
    "organization_id": "org_39802449573184223",
    "raw_attributes": {}
  }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `directory_id` | string | Unique identifier for the directory |
| `display_name` | string | Display name of the directory group |
| `dp_id` | string | Unique identifier for the group in the directory provider system |
| `id` | string | Unique identifier for the directory group |
| `organization_id` | string | Identifier for the organization associated with the group |
| `raw_attributes` | object | Raw attributes of the directory group as received from the provider |

================
File: reference/webhooks/event-object.mdx
================
---
title: Webhook event object
description: "Understand the structure of Scalekit's webhook event objects, including standardized fields and event-specific data payloads."
tableOfContents: false
sidebar:
  label: Event object
  order: 1
prev: false
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
next:
  label: Directory webhook events
  link: /reference/webhooks/directory-events/
---

import { Aside, CardGrid } from '@astrojs/starlight/components';
import WideLayout from '@components/ui/WideLayout.astro';
import SideBySide from '@components/ui/SideBySide.astro';

A webhook (also called a web callback or HTTP push API) is a way for Scalekit to provide your applications with real-time information. A webhook delivers data to your applications as it happens, meaning you get data immediately, unlike typical APIs where you would need to poll for data very frequently to get it in real-time. Events represent specific actions or changes, while webhooks are the mechanism used to deliver these event notifications to your specified endpoint.

By leveraging webhooks, you can build responsive and dynamic integrations that react immediately to changes in Scalekit System, enabling you to keep your systems in sync and automate user lifecycle management and other related use cases.


The webhook event object contains standardized fields that provide context about the event, along with event-specific data in the `data` field.

```json title="Sample Event Payload"
{
  "spec_version": "1",
  "id": "evt_123456789",
  "object": "DirectoryUser",
  "environment_id": "env_123456789",
  "occurred_at": "2024-08-21T10:20:17.072Z",
  "organization_id": "org_123456789",
  "type": "organization.directory.user_created",
  "data": {
    // Event Data
  }
}
```

| Property | Description |
|----------|-------------|
| `spec_version` | The version of the event specification format. Currently "1". |
| `id` | A unique identifier for the event (e.g., `evt_123456789`). |
| `object` | The type of object that triggered the event (e.g., "DirectoryUser", "Directory", "Connection"). |
| `environment_id` | The ID of the environment where the event occurred. |
| `occurred_at` | ISO 8601 timestamp indicating when the event occurred. |
| `organization_id` | The ID of the organization associated with the event. |
| `type` | The specific event type (e.g., "organization.directory.user_created"). |
| `data` | Event-specific payload containing details relevant to the event type. |

================
File: reference/contact-us.mdx
================
---
title: Contact Us
description: "Get in touch with the Scalekit team for support, schedule a call, or find answers to frequently asked questions about our services."
tableOfContents: false
prev: false
next: false
slug: "support/contact-us"
---

import { Card, CardGrid, Aside } from "@astrojs/starlight/components";

If you encounter issues that remain unresolved despite your best troubleshooting efforts and our rigorous testing, please reach out to the Scalekit team using the contact information provided below. We will respond as quickly as possible.

<CardGrid>
  <Card title="Talk to a dev" icon="open-book">
    [Write to us](mailto:support@scalekit.com)
    <br />
    [Schedule a call](https://schedule.scalekit.com/meet/ravi-madabhushi/demo-8b100203)
  </Card>
  <Card title="Slack Connect" icon="information">
    Reach out to us directly for Slack support
  </Card>
</CardGrid>

## Frequently Asked Questions

<details>
<summary>What domains do I need to whitelist for Scalekit to work in customer's VPN?</summary>

**Required domains:**

| Domain | Purpose |
|--------|---------|
| `your-app.scalekit.com` | Your Scalekit environment URL (admin portal and authentication) |
| `cdn.scalekit.com` | Content delivery network for static assets |
| `docs.scalekit.com` | Documentation portal |
| `fonts.googleapis.com` | Font resources |

<Aside type="tip">
Replace `your-app.scalekit.com` with your actual Scalekit environment URL. You can find this in your Scalekit dashboard under Settings > API Config.
</Aside>

</details>

<h3>Frequently Asked Questions</h3>

<details>
<summary>What Identity Providers are supported for SSO?</summary>

SSO includes native, prebuilt integrations with all identity providers including Okta, Entra ID (Azure AD), JumpCloud, Google SSO, and more. Works out-of-box with SAML and OIDC.

</details>

<details>
<summary>What directories are supported for SCIM?</summary>

Scalekit provides a single API with a unified data format for multi-directory integration. SCIM solution includes corporate directories and HRMS systems like Okta, Azure AD, Rippling, Google Workspace, and more. For directories that do not offer native SCIM support, we provide batch APIs for user provisioning.

</details>

<details>
<summary>What's Admin Portal?</summary>

Admin Portal enables your customers to self-serve manage SSO and SCIM configurations, thus reducing engineering and support overhead for your team. Using Admin Portal, IT admins (in your customers' organizations) can set up authentication connections, test SSO flows, map custom user attributes, and more. The portal can be embedded into your app with a fully branded UI or shared as a standalone link.

</details>

<details>
<summary>How does Scalekit handle multi-tenancy?</summary>

Scalekit is designed with native multi-tenancy and follows organization-first data model. Each organization in your app can have its own authentication policies, SSO/SCIM configuration—without requiring custom code.

</details>

<details>
<summary>Does Scalekit support both SP-initiated and IdP-initiated SSO?</summary>

Yes, we support both SP-initiated and IdP-initiated SSO flows for seamless enterprise authentication.

</details>

<details>
<summary>Can I test SSO flows before going live?</summary>

Yes, Scalekit provides a built-in IdP Simulator to validate SSO flows in a sandbox environment without affecting production. No real IdP accounts are needed. Test real-world edge cases and simulate error scenarios before deployment.

</details>

<details>
<summary>What user attributes can be mapped through SSO and SCIM?</summary>

Scalekit supports both default and custom attributes. You can define custom attributes and roles in your app and map them from identity providers (SSO) and directories (SCIM). This is a self-serve configuration, manageable by both your team and your customers.

</details>

<details>
<summary>What deployment options are available?</summary>

Scalekit is a multi-tenant auth platform hosted on public cloud infrastructure. Each of your workspace and environment is logically isolated, ensuring strict data security and access controls.

</details>

<details>
<summary>Where is my data stored?</summary>

Currently, our data centers are hosted in the **US region**, and we use Google Cloud Platform (GCP) as our cloud provider.

We have a robust security and compliance posture:

- **SOC 2 & ISO 27001**: Scalekit is a SOC 2 and ISO 27001 compliant authentication provider.
- **GDPR**: We are GDPR compliant, utilizing Standard Contractual Clauses (SCCs) to ensure data protection. This allows us to successfully support customers from the EU region.
- **No PII Storage**: We only persist configuration and metadata. As part of our solution, we **do not store any user or PII information** in our persistent database stores.
- **Log Retention**: All access and authentication logs are stored for only 30 days and are automatically purged on a rolling 30-day basis.

For more details, please see our additional resources:

- [Security & Trust Center](https://www.scalekit.com/trust-center)
- [Data Processing Agreement (DPA)](https://www.scalekit.com/legal/data-processing-agreement)
- [Privacy Policy](https://www.scalekit.com/legal/privacy-policy)

</details>

================
File: reference/glossary.mdx
================
---
title: Glossary
description: "A comprehensive glossary of terms related to authentication, authorization, and identity management in B2B SaaS applications."
tableOfContents: true
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
prev: false
next: false
---

## Access Token
- **Definition**: A credential (often a JWT) issued by the authorization server that the client uses to access the resource server. It represents the client's authorization and typically has an expiry time and scopes attached. The resource server validates this token.

## Administrator
- **Definition**: An IT administrator responsible for managing identity provider configurations within a customer organization.

## Admin Portal
- **Definition**: A customizable web interface for customers' IT administrators to manage identity provider configurations.

## AI Agent Identity and Attestation
- **Definition**: A process by which an AI agent proves its identity to an authorization server, often using cryptographic evidence (e.g. signed JWT assertions or hardware-backed keys), so the server can trust requests coming from that agent.

## API Endpoint
- **Definition**: A specific URL where an API can be accessed to perform specific operations or retrieve data.

## API Key
- **Definition**: A unique identifier used to authenticate API requests to Scalekit, allowing secure access to the platform's features and services.

## App
- **Definition**: Another term for an application, representing the software product or service sold to customers.

## Application
- **Definition**: The software product or service offered by B2B App developers to customers.
- **Example**: A workspace can contain multiple applications.

## Audit Log
- **Definition**: A record of all activities and changes made within the B2B App, used for security and compliance purposes.

## Authentication
- **Definition**: The process of verifying the identity of a user or system attempting to access the B2B App.

## Authorization
- **Definition**: The process of determining what actions or resources a user is allowed to access within the B2B App.

## Authorization Server
- **Definition**: The server in OAuth that authenticates clients and issues tokens (could be a part of your SaaS or a third-party IdP like Okta Azure AD, etc.). It essentially says "Yes, client X, here is a token proving you are authenticated and allowed to do Y."

## Authorization URL
- **Definition**: The URL to which users are redirected to grant authorization for the B2B App.

## B2B App
- **Definition**: An application designed for use by other businesses or organizations to streamline operations.

## B2B SaaS App
- **Definition**: A type of B2B App delivered over the internet, allowing access without local installation.

## Claims
- **Definition**: Information about a user that is passed from an identity provider to a service provider during authentication.

## Client Credentials Flow
- **Definition**: The OAuth process where a machine client exchanges its client ID and secret for an access token from the auth server. No user involved. The resulting token represents the machine and carries scopes for what it can do.

## Configuration
- **Definition**: The settings and parameters that define how the B2B App interacts with Scalekit and other services.

## Connection
- **Definition**: A link between the B2B App and a customer's identity provider for enabling Single Sign-On (SSO).
- **Example**: Each organization can have its own unique connection.

## Customer
- **Definition**: A business or organization that uses the application to meet specific needs.

## Custom Attribute
- **Definition**: Additional fields added to user data in Scalekit for storing extra information.

## Dashboard
- **Definition**: The main control panel within Scalekit for configuring settings, viewing analytics, and managing integrations.

## Deprovisioning
- **Definition**: The process of removing user access and accounts when they are no longer needed or authorized.

## Directory Provider
- **Definition**: An organization offering directory services, including identity providers.

## Directory Sync
- **Definition**: A module in Scalekit for automatic provisioning and deprovisioning of user accounts.

## Documentation
- **Definition**: Comprehensive guides and references that explain how to use and integrate with Scalekit's features and services.

## Dynamic Client Registration
- **Definition**: A protocol (RFC 7591) that allows a client application to programmatically register itself with an authorization server to obtain credentials (client ID/secret, etc.). Useful for large-scale or third-party ecosystems where manual registration of clients is not feasible or to enable self-service integration in a controlled way.

## Environment
- **Definition**: Different versions or instances of an application, such as test and live environments.
- **Example**: Each environment has its own settings and is isolated for security.

## Error Handling
- **Definition**: The process of managing and responding to errors that occur during API calls or application operations.

## Federation
- **Definition**: The process of establishing trust between different identity providers and service providers for seamless authentication.

## ID Token
- **Definition**: A JSON Web Token (JWT) issued by the identity provider containing user identity information.

## Identity Provider (IdP)
- **Definition**: A service that verifies user identity and provides information about user attributes.

## IdP Simulator
- **Definition**: A tool that mimics the behavior of an identity provider for testing integrations.

## Integration
- **Definition**: The process of connecting Scalekit with other systems or services to enable seamless data flow and functionality.

## JWT
- **Definition**: A standard format for representing claims securely between two parties. It is a compact, URL-safe means of representing claims securely between two parties.

## Logout
- **Definition**: The process of ending a user's session and revoking their access to the B2B App.

## Machine-to-Machine (M2M) Authentication
- **Definition**: Methods for verifying identity between two automated services or software entities without human intervention. Ensures a client program (machine) is trusted by the service it calls, typically via tokens, keys, or certificates.

## MFA (Multi-Factor Authentication)
- **Definition**: A security feature that requires users to provide multiple forms of verification before accessing the B2B App.

## Model Context Protocol (MCP)
- **Definition**: A new protocol (spearheaded by Anthropic and others) to standardize how AI models (assistants) can interact with external tools and data. It defines how AI agents can discover available "tools" (APIs) and the context to call them. For auth, MCP leverages OAuth 2.1 – effectively requiring AI agents to go through a secure authorization process to get access to those tools. Think of it as an evolving standard to make AI to SaaS integrations plug-and-play, with security built-in via OAuth.

## Mutual TLS (mTLS)
- **Definition**: A transport layer security mechanism where *both client and server present certificates* to mutually authenticate each other during the TLS handshake. Provides strong assurance of identities at connection level and encrypts the traffic. Used in high-security environments and internal service-to-service auth.

## Normalized Payload
- **Definition**: A standardized format for data sent from Scalekit to the B2B App.

## OAuth
- **Definition**: A standard protocol for authorization enabling limited access to user data.

## OAuth 2.0/OAuth 2.1
- **Definition**: An authorization framework widely used for granting access to resources. OAuth 2.0 defines various *flows* (grant types) for different scenarios (authorization code, client credentials, etc.). OAuth 2.1 is an incremental update that compiles security best practices (PKCE required, no legacy flows, etc.). In M2M context, OAuth's **Client Credentials Grant** is most relevant, allowing a service to get an access token using its own credentials.

## OAuth 2.0 Token Exchange (RFC 8693)
- **Definition**: A protocol that lets one token be exchanged for another—for example, an AI agent exchanging its machine-client token for a token scoped to call a downstream service on behalf of a user or another service. Enables delegation and impersonation scenarios.

## OIDC
- **Definition**: A standard protocol for authentication that builds on OAuth 2.0.

## OpenID Connect (OIDC)
- **Definition**: An identity layer on top of OAuth 2.0 (often used for user authentication). Mentioned here because the discovery document and id_token concepts come from OIDC. OIDC isn't directly about M2M auth (it's user-centric), but the OIDC discovery (`.well-known`) and JWT usage are leveraged in service auth too.

## Organization
- **Definition**: The customers of B2B Apps, typically businesses.
- **Example**: Each business is considered an organization with its own users.

## PKCE (Proof Key for Code Exchange)
- **Definition**: An extension to OAuth used to prevent interception of authorization codes. The client generates a random secret (code verifier) and sends a hashed version (code challenge) in the auth request, then must present the original secret when redeeming the code. Ensures that even if an attacker intercepts the auth code, they can't exchange it without the secret. PKCE is now recommended for any OAuth client that can't secure a client secret – including mobile, SPA, and some machine clients.

## PKI (Public Key Infrastructure)
- **Definition**: The system of certificate authorities, processes, and tools for managing digital certificates (like those used in mTLS). Involves issuing certs, distributing them, rotating when expired, revoking if compromised, etc. A robust PKI is needed to effectively use certificate-based auth at scale.

## Provisioning
- **Definition**: The process of creating and managing user accounts and access rights in the B2B App.

## Rate Limiting
- **Definition**: A mechanism that controls the rate of requests a user or application can make to the API within a specific time period.

## Refresh Token
- **Definition**: A long-lived token that can be used to get new access tokens without re-authenticating. In M2M auth, refresh tokens are rarely used because the client can just use its credentials again. Refresh tokens are more for user-based flows to avoid prompting the user frequently.

## Resource Server
- **Definition**: The API or service that the client wants to use – it receives tokens from clients and decides whether to accept them (by validating them). In our context, your SaaS API is a resource server that expects a valid token for requests.

## Role-Based Access Control (RBAC)
- **Definition**: A method of regulating access to resources based on the roles of individual users within an organization.

## SAML Assertion
- **Definition**: A statement by an identity provider indicating a user's authentication status.

## SCIM
- **Definition**: SCIM (System for Cross-domain Identity Management) is a standard protocol for automating the provisioning and deprovisioning of user accounts and their attributes between an identity provider and a service provider.

## Scopes
- **Definition**: Strings that define what access is being requested or granted in an OAuth token. For example, `read:inventory` or `payments:create`. Scopes let the token carry permissions, enabling the resource server to allow or deny requests based on scope. Principle of least privilege is implemented by granting minimal scopes.

## Service Account
- **Definition**: A non-human account used by a software service. In context, it's an identity set up for a machine to use. For example, a service account could be created for "Data Sync Service" in a customer's tenant on your app. Service accounts have credentials (like client ID/secret or keys) to authenticate, and usually have roles or scopes assigned just like a user would. They enable organization-level or service-level tokens without tying to an actual person.

## Service Provider
- **Definition**: An entity offering a product or service to another organization or individual, especially in SSO contexts.

## Session
- **Definition**: A period of interaction between a user and the B2B App, typically starting with authentication and ending with logout.

## Social Connection
- **Definition**: Allows users to sign in using their social media accounts.

## SSO (Single Sign-On)
- **Definition**: An authentication method that allows users to access multiple applications with a single set of credentials.

## Team Member
- **Definition**: Individuals from the B2B App developer's company who use Scalekit to manage applications.
- **Roles**: Can include developers, product managers, or customer support staff.

## Tenant
- **Definition**: An isolated instance of the B2B App for a specific customer organization, with its own data and configurations.

## Token
- **Definition**: A piece of data that represents a user's authentication status and permissions, used for accessing protected resources.

## User
- **Definition**: An individual who uses the B2B App, typically belonging to a customer organization.

## User Attribute
- **Definition**: Properties describing a user's identity, used for authentication and access control.

## Webhook
- **Definition**: A mechanism for the B2B App to receive notifications or updates from Scalekit.

## Webhook Payload
- **Definition**: The data sent by Scalekit to the B2B App when a webhook is triggered, containing information about the event.

## Workspace
- **Definition**: A centralized hub for B2B App developers to manage applications and settings.
- **Example**: Think of it as a command center for efficient application management.

## Zero Trust Security
- **Definition**: A security model where no user or device is inherently trusted, even if inside the network. Every access request must be authenticated, authorized, and continuously validated. For M2M, this means authenticating every service communication, minimizing implicit trust, and verifying identities at multiple layers (network & application). It often involves micro-segmentation and strict identity and access management for every machine identity.

================
File: reference/ui-events.mdx
================
---
title: UI events from the embedded admin portal
description: "Learn how to listen for and handle UI events from the embedded admin portal, such as SSO connection status and session expiration."
tableOfContents: false
sidebar:
  label: Admin portal events
  order: 2
slug: reference/admin-portal/ui-events
---

import { Steps, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

Listen to the browser events emitted from the embedded admin portal to perform actions on your app. For example, showing a notification when the Single sign-on connection is enabled.

| Event Type       | Description      |
|----------------|----------------|
| [`ORGANIZATION_SSO_ENABLED`](#organization_sso_enabled)  | Triggered when the Single sign-on connection is enabled |
| [`ORGANIZATION_SSO_DISABLED`](#organization_sso_disabled)  | Triggered when the Single sign-on connection is disabled |
| [`PORTAL_SESSION_EXPIRY`](#portal_session_expiry)  | Triggered when the admin portal session expires |
| [`ORGANIZATION_DIRECTORY_ENABLED`](#organization_directory_enabled)  | Triggered when the SCIM Provisioning is enabled |
| [`ORGANIZATION_DIRECTORY_DISABLED`](#organization_directory_disabled)  | Triggered when the SCIM Provisioning is disabled |

To listen to these events:

1. Add a listener to the parent window.
2. Check the event origin and type to determine the action to take.
3. Handle the event data as needed.

```js {3,5} title="Listening to events from the embedded admin portal"
window.onmessage = event => {
  if (
    event.origin === '<SCALEKIT_ENVIRONMENT_URL>' &&
    event.data &&
    event.data.event_type === '<EVENT_TYPE>'
  ) {
    console.log(event.data); // Handle the event data
  }
};
```

The domain of your parent window must be listed in the Scalekit Dashboard > API Config > Redirect URIs for security purpose. Always <u>validate the `event.origin` </u> to ensure events are coming from a trusted source.

**Event types**

The following event types are emitted by the embedded admin portal. Each event includes specific data that you can use to update your application's UI or trigger other actions.

<h3 id="organization_sso_enabled">`ORGANIZATION_SSO_ENABLED`</h3>

```json
{
  "event_type":"ORGANIZATION_SSO_ENABLED",
  "object":"connection",
  "organization_id":"org_4010340X34236531",
  "message": "Single sign-on connection enabled successfully",
  "data":{
      "connection_type":"SSO",
      "id":"conn_4256075523X312",
      "type":"OIDC",
      "provider":"OKTA",
      "enabled":true
  }
}
```

<h3 id="organization_sso_disabled">`ORGANIZATION_SSO_DISABLED`</h3>

```json
{
   "event_type":"ORGANIZATION_SSO_DISABLED",
   "object":"connection",
   "organization_id":"org_4010340X34236531",
   "message": "Single sign-on connection disabled successfully",
   "data":{
      "connection_type":"SSO",
      "id":"conn_4256075523X312",
      "type":"OIDC",
      "provider":"OKTA",
      "enabled": false
   }
}
```

<h3 id="portal_session_warning">`PORTAL_SESSION_WARNING`</h3>

```json
{
  "event_type": "PORTAL_SESSION_WARNING",
  "object": "session",
  "message": "The admin portal session will expire in 5 minutes",
  "organization_id": "org_43982563588440584",
  "data": {
    "expiry": "2025-02-28T12:40:35.911Z"
  }
}
```

<h3 id="portal_session_expiry">`PORTAL_SESSION_EXPIRY`</h3>

```json
{
  "event_type": "PORTAL_SESSION_EXPIRY",
  "object": "session",
  "message": "The admin portal session has expired",
  "organization_id": "org_43982563588440584",
  "data": {
    "expiry": "2025-02-28T12:40:35.911Z"
  }
}
```

<h3 id="organization_directory_enabled">`ORGANIZATION_DIRECTORY_ENABLED`</h3>

```json
{
    "event_type": "ORGANIZATION_DIRECTORY_ENABLED",
    "object": "directory",
    "organization_id": "org_45716217859670289",
    "message": "SCIM Provisioning enabled successfully",
    "data": {
        "directory_type": "SCIM",
        "id": "dir_45716228982964495",
        "provider": "MICROSOFT_AD",
        "enabled": true
    }
}
```

<h3 id="organization_directory_disabled">`ORGANIZATION_DIRECTORY_DISABLED`</h3>

```json
{
    "event_type": "ORGANIZATION_DIRECTORY_DISABLED",
    "object": "directory",
    "organization_id": "org_45716217859670289",
    "message": "SCIM Provisioning disabled successfully",
    "data": {
        "directory_type": "SCIM",
        "id": "dir_45716228982964495",
        "provider": "MICROSOFT_AD",
        "enabled": false
    }
}
```

<Aside type="caution" title="Considerations">
1. The domain of your parent window must be listed in the Scalekit Dashboard > API Config > Redirect URIs for security purpose
2. Always validate the `event.origin` to ensure events are coming from a trusted source.
</Aside>

================
File: sso/guides/add-login-ux-sso.mdx
================
---
title: "Add SSO to login page"
description: "Explore strategies to incorporate single sign-on into your application's login page using Scalekit, improving user experience and authentication efficiency."
sidebar:
  label: "Add SSO to login page"
prev: false
next: false
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

**Login page UX strategies to implement single sign-on**

Using our [quickstart guide](/sso/quickstart), you may already have implemented single sign-on (SSO) between your application and your customer's identity provider. In this article, we'll explore different UX strategies to incorporate SSO into your application's login page. Assuming your users can log in via email and password or through social providers like Google and GitHub, you can adopt one of the following three strategies to implement SSO on your login page:


![Login page with password and social auth methods](@/assets/docs/sso/ux-strategies/simple_login_page.png)

## Strategy 1: Identifier-driven single sign-on

In this strategy, you first collect the user's identifier—the most popular identifier is the email address. Based on the email address, you determine whether to navigate the user to SSO login experience or password-based authentication. The organization can be discovered using either (i) the domain of the user's email address or (ii) an organization identifier shared by the user.

![Identifier-driven login](@/assets/docs/sso/ux-strategies/identifier_first_login.png)

The benefit with this approach is that users don't have to choose the authentication method, thus reducing their cognitive load and making the experience smoother. This is especially useful when users initially log in with passwords, and their admin later mandates SSO. Users don't need to change their behavior; your application can handle it. Popular products like [Google](https://accounts.google.com), [Microsoft](https://login.microsoftonline.com), and [AWS](https://console.aws.amazon.com/console/) use this strategy in their login pages.

## Strategy 2: Login with single sign-on button

In this strategy, you add a "Login with SSO" button on your login page, prompting users to choose this option explicitly. The advantage is that it presents all available authentication options, allowing users to decide how they want to log in.

![Explicit option for login with SSO](@/assets/docs/sso/ux-strategies/sso_button_login.png)

If a user tries to log in with a password, but their admin mandates SSO, you would force SSO-based authentication instead of showing an error message. Popular products like [Cal.com](https://app.cal.com/auth/login) and [Notion](https://www.notion.so/login) use this strategy in their login pages.

<Aside type="tip">
In either of the above strategies, if a user chooses an authentication method (like social login), you need to verify their identity and the appropriate authentication method. If the user is meant to be authenticated through SSO-based login, make sure your application prompts them to re-authenticate through SSO.
</Aside>

## Strategy 3: Tenant specific login page

In this strategy, instead of a single login page at `https://app.b2b-app.com/login`, you serve different login pages for each tenant. For example, `https://customer1.b2b-app.com/login`, `https://customer2.b2b-app.com/login`. Depending on the tenant URL, you would show only the respective authentication methods applicable to that tenant, thus optimizing the user experience further.

Popular products like [Zendesk](https://www.zendesk.com/in/login/) and [Slack](https://scalekit.slack.com/) use this strategy in their login pages. However, the big drawback with this approach is that users need to remember their tenant URL to access the login page.

---

## Initiating single sign-on from your login page

Once you've chosen a UX strategy for your application's login, let's move to the login implementation of SSO through Scalekit. Regardless of the strategy you implemented, you can construct the `authorization_url` using Scalekit SDK and redirect the user to this URL. Refer to the code samples below:

<Tabs>
<TabItem label="Node.js">

```javascript
import { Scalekit } from '@scalekit-sdk/node';
// Initialize the SDK client
const scalekit = new Scalekit('', '', '');
const options = {};
// Option 1: Authorization URL with the organization ID
options['organizationId'] = 'org_15421144869927830';
// Option 2: Authorization URL with login hint
options['loginHint'] = 'user@example.com';
const authorizationURL = scalekit.getAuthorizationUrl(
  redirect_uri,
  options,
);
// Next step is to redirect the user to this authorization URL
```

</TabItem>
<TabItem label="Python">

```python
from scalekit import ScalekitClient, AuthorizationUrlOptions
# Initialize the SDK client
scalekit_client = ScalekitClient('', '', '')
options = AuthorizationUrlOptions()
# Option 1: Authorization URL with the organization ID
options.organization_id = "org_15421144869927830"
# Option 2: Authorization URL with login hint
options.login_hint = "user@example.com"
authorization_url = scalekit_client.get_authorization_url(
  redirect_uri=redirect_uri,
  options=options
)
# Next step is to redirect the user to this authorization_url
```

</TabItem>
<TabItem label="Go">

```go
import (
  "github.com/scalekit/scalekit-sdk-go"
)
func main() {
  // Initialize the SDK client
  scalekitClient := scalekit.NewScalekitClient("", "", "")
  options := scalekit.AuthorizationUrlOptions{}
  // Option 1: Authorization URL with the organization ID
  options.OrganizationId = "org_15421144869927830"
  // Option 2: Authorization URL with login hint
  options.LoginHint = "user@example.com"
  authorizationURL := scalekitClient.GetAuthorizationUrl(
    redirectUrl,
    options,
  )
  // Next step is to redirect the user to this authorizationURL
}
```

</TabItem>
<TabItem label="Java">

```java
import com.scalekit.ScalekitClient;
import com.scalekit.internal.http.AuthorizationUrlOptions;
@PostMapping(path = "/login")
public ResponseEntity<Map<String, String>> loginHandler(@RequestBody LoginRequest body) {
  AuthorizationUrlOptions options = new AuthorizationUrlOptions();
  // Option 1: Authorization URL with the organization ID
  if (body.getOrganizationId() != null) {
    options.setOrganizationId(body.getOrganizationId());
  }
  // Option 2: Authorization URL with login hint
  if (body.getEmail() != null) {
    options.setLoginHint(body.getEmail());
  }
  try {
    String url = scalekit
      .authentication()
      .getAuthorizationUrl(redirectUrl, options)
      .toString();
    return ResponseEntity.ok(Collections.singletonMap("url", url));
  } catch (Exception e) {
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Collections.singletonMap("error", e.getMessage()));
  }
}
// Redirect the user to this authorization URL
```

</TabItem>
</Tabs>

================
File: sso/guides/authorization-url.mdx
================
---
title: 'Authorization URL'
description: 'Learn how to construct and implement authorization URLs in Scalekit to initiate secure single sign-on (SSO) flows with your identity provider.'
tableOfContents: false
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
prev: false
next: false
---

import { Aside, TabItem, Tabs } from '@astrojs/starlight/components'

The authorization endpoint is where your application redirects users to begin the authentication process. Scalekit powers this endpoint and handles redirecting users to the appropriate identity provider.

```sh wrap title="Example authorization URL" showLineNumbers=false
https://SCALEKIT_ENVIRONMENT_URL/oauth/authorize?
    response_type=code&
    client_id=skc_1234&
    scope=openid%20profile&
    redirect_uri=https%3A%2F%2Fyoursaas.com%2Fcallback&
    organization_id=org_1243412&
    state=aHR0cHM6Ly95b3Vyc2Fhcy5jb20vZGVlcGxpbms%3D
```

## Parameters

| Parameter | Requirement | Description |
|-----------|-------------|-------------|
| `client_id` | Required | Your unique client identifier from the API credentials page |
| `nonce` | Optional | Random value for replay protection |
| `organization_id` | Required\* | Identifier for the organization initiating SSO |
| `connection_id` | Required\* | Identifier for the specific SSO connection |
| `domain` | Required\* | Domain portion of email addresses configured for an organization |
| `provider` | Required\* | Social login provider name. Supported providers: `google`, `microsoft`, `github`, `gitlab`, `linkedin`, `salesforce` |
| `response_type` | Required | Must be set to `code` |
| `redirect_uri` | Required | URL where Scalekit sends the response. Must match an authorized redirect URI |
| `scope` | Required | Must be set to `openid email profile` |
| `state` | Optional | Opaque string for request-response correlation |
| `login_hint` | Optional | User's email address for prefilling the login form |

\* You must provide one of `organization_id`, `connection_id`, `domain`, or `provider`.

<Aside type="tip">
**Important security notes:**

- Your `redirect_uri` must exactly match one of the authorized redirect URIs configured in your API settings
- Always include the `state` parameter to protect against cross-site request forgery attacks
- Use `login_hint` to improve user experience by prefilling login forms at the identity provider
</Aside>

## SDK usage

Use Scalekit SDKs to generate authorization URLs programmatically. This approach handles parameter encoding and validation automatically.

<Tabs>
<TabItem label="Node.js">

```javascript wrap ins={14}
import { ScalekitClient } from '@scalekit-sdk/node';

const scalekit = new ScalekitClient(
  'https://your-subdomain.scalekit.dev',
  '<SCALEKIT_CLIENT_ID>',
  '<SCALEKIT_CLIENT_SECRET>'
);

const options = {
  loginHint: 'user@example.com',
  organizationId: 'org_123235245',
};

const authorizationURL = scalekit.getAuthorizationUrl(redirectUri, options);
// Example generated URL:
// https://your-subdomain.scalekit.dev/oauth/authorize?response_type=code&client_id=skc_1234&scope=openid%20profile&redirect_uri=https%3A%2F%2Fyoursaas.com%2Fcallback&organization_id=org_123235245&login_hint=user%40example.com&state=abc123
```

</TabItem>
<TabItem label="Python">

```python wrap ins={14-17}
from scalekit import ScalekitClient, AuthorizationUrlOptions

scalekit = ScalekitClient(
  'https://your-subdomain.scalekit.dev',
  '<SCALEKIT_CLIENT_ID>',
  '<SCALEKIT_CLIENT_SECRET>'
)

options = AuthorizationUrlOptions(
  organization_id="org_12345",
  login_hint="user@example.com",
)

authorization_url = scalekit.get_authorization_url(
  redirect_uri,
  options
)
# Example generated URL:
# https://your-subdomain.scalekit.dev/oauth/authorize?response_type=code&client_id=skc_1234&scope=openid%20profile&redirect_uri=https%3A%2F%2Fyoursaas.com%2Fcallback&organization_id=org_12345&login_hint=user%40example.com&state=abc123
```

</TabItem>
<TabItem label="Go">

```go wrap ins={17-20}
import (
  "github.com/scalekit/scalekit-sdk-go"
)

func main() {
  scalekitClient := scalekit.NewScalekitClient(
    "https://your-subdomain.scalekit.dev",
    "<SCALEKIT_CLIENT_ID>",
    "<SCALEKIT_CLIENT_SECRET>"
  )

  options := scalekitClient.AuthorizationUrlOptions{
    OrganizationId: "org_12345",
    LoginHint: "user@example.com",
  }

  authorizationURL := scalekitClient.GetAuthorizationUrl(
    redirectUrl,
    options,
  )
  // Example generated URL:
  // https://your-subdomain.scalekit.dev/oauth/authorize?response_type=code&client_id=skc_1234&scope=openid%20profile&redirect_uri=https%3A%2F%2Fyoursaas.com%2Fcallback&organization_id=org_12345&login_hint=user%40example.com&state=abc123
}
```

</TabItem>
<TabItem label="Java">

```java wrap ins={22}
package com.scalekit;

import com.scalekit.ScalekitClient;
import com.scalekit.internal.http.AuthorizationUrlOptions;

public class Main {
  public static void main(String[] args) {
    ScalekitClient scalekitClient = new ScalekitClient(
      "https://your-subdomain.scalekit.dev",
      "<SCALEKIT_CLIENT_ID>",
      "<SCALEKIT_CLIENT_SECRET>"
    );
    AuthorizationUrlOptions options = new AuthorizationUrlOptions();
    // Option 1: Authorization URL with the organization ID
    options.setOrganizationId("org_13388706786312310");
    // Option 2: Authorization URL with the connection ID
    options.setConnectionId("con_13388706786312310");
    // Option 3: Authorization URL with login hint
    options.setLoginHint("user@example.com");

    try {
      String url = scalekitClient.authentication().getAuthorizationUrl(redirectUrl, options).toString();
      // Example generated URL:
      // https://your-subdomain.scalekit.dev/oauth/authorize?response_type=code&client_id=skc_1234&scope=openid%20profile&redirect_uri=https%3A%2F%2Fyoursaas.com%2Fcallback&organization_id=org_13388706786312310&connection_id=con_13388706786312310&login_hint=user%40example.com&state=abc123
    } catch (Exception e) {
      System.out.println(e.getMessage());
    }
  }
}
```

</TabItem>
</Tabs>

## Parameter precedence

When you provide multiple connection parameters, Scalekit follows a specific precedence order to determine which identity provider to use:

1. `provider` (highest precedence): If present, Scalekit ignores all other connection parameters and directs users to the specified social login provider. For example, `provider=google` redirects users to Google's login screen. See [Social Login](/social-logins/quickstart/) for more details.

2. `connection_id`: Takes highest precedence among enterprise SSO parameters. Scalekit uses this specific connection if you provide a valid connection ID. If the connection ID is invalid, the authorization request fails.

3. `organization_id`: Scalekit uses this parameter when no valid `connection_id` is provided. It selects the SSO connection configured for the specified organization.

4. `domain`: Scalekit uses this parameter when neither `connection_id` nor `organization_id` are provided. It selects the SSO connection configured for the specified domain.

5. `login_hint` (lowest precedence): Scalekit extracts the domain portion from the email address and uses the corresponding SSO connection mapped to that organization.

<Aside type="note" title="Example scenario">
**Example**: If you provide both `organization_id=org_123` and `login_hint=user@company.com`, Scalekit uses the organization's SSO connection because `organization_id` has higher precedence than `login_hint`.
</Aside>

================
File: sso/guides/idp-init-sso.mdx
================
---
title: "Handle Identity Provider initiated SSO"
description: "Learn how to securely implement IdP-initiated Single Sign-On for your application"
sidebar:
  label: "Handle IdP-initiated SSO"
prev:
  label: "SSO quickstart"
  link: /sso/quickstart/
next:
  label: "Test IdP-initiated SSO"
  link: /sso/guides/test-sso/
---

import { Tabs, TabItem, Steps } from '@astrojs/starlight/components';

IdP-initiated SSO allows users to log into your application directly from their identity provider's portal. The workflow consists of three main steps:

1. The user logs into their identity provider portal and selects your application
2. The identity provider sends the user's details as assertions to your application
3. Your application validates the assertions, retrieves the user information, and if everything checks out, logs the user in

<figure>
  ![Scalekit's recommended workflow for IdP initiated SSO](@/assets/docs/common/idp-init-sso.png)
</figure>

Since the login is initiated from the identity provider's portal, this flow is called IdP-initiated SSO.

To securely implement IdP-initiated SSO, follow these steps to convert incoming IdP-initiated requests to SP-initiated flows:

<Steps>

1. **Set up a default redirect endpoint**: When Scalekit receives an IdP-initiated SSO request, it sends a request to your configured default `redirect_uri` with an `idp_initiated_login` parameter.

   ```sh showLineNumbers=false  "idp_initiated_login=<encoded_jwt_token>" wrap
   https://{your-subdomain}.scalekit.dev/default-redirect-uri?idp_initiated_login=<encoded_jwt_token>
   ```

2. **Extract information from the JWT token**: The `idp_initiated_login` parameter contains a signed JWT with organization, connection, and user details.

   ```js showLineNumbers=false
   {
     "organization_id": "org_225336910XXXX588",
     "connection_id": "conn_22533XXXXX575236",
     "login_hint": "name@example.com",
     "exp": 1723042087,
     "nbf": 1723041787,
     "iat": 1723041787,
     "iss": "https://b2b-app.com"
   }
   ```

3. **Convert to SP-initiated flow**: Use the extracted parameters to initiate a new SSO request. Here are implementation examples:

   <div>
   <Tabs syncKey="tech-stack">
   <TabItem value="nodejs" label="Node.js">

   ```javascript showLineNumbers=false "idp_initiated_login"
   // 1. Default redirect URL is callback with JWT
   const { code, error_description, idp_initiated_login } = req.query;

     if (error_description) {
       return res.status(400).json({ message: error_description });
     }


   // 2. Decode the JWT
   if (idp_initiated_login) {

     const {
       connection_id,
       organization_id,
       login_hint,
       relay_state
     } = await scalekit.getIdpInitiatedLoginClaims(idp_initiated_login);

     let options = {};
     // Either ONE of the following properties
       options["connectionId"] = connection_id
       options["organizationId"] = organization_id
       options["loginHint"] = login_hint

       // 3. Generate Authorization URL
       const url = scalekit.getAuthorizationUrl(
         <redirect_uri>,
         options
       )
       return res.redirect(url);
     }
   ```

   </TabItem>
   <TabItem value="python" label="Python">

   ```python showLineNumbers "idp_initiated_login"
   # 1. Default redirect URL is callback with JWT
   code = request.args.get('code')
   error_description = request.args.get('error_description')
   idp_initiated_login = request.args.get('idp_initiated_login')
   options = AuthorizationUrlOptions()


   if error_description:
       # Handle Error

   # 2. Decode the JWT
   if idp_initiated_login:
       claims = await scalekit.get_idp_initiated_login_claims(idp_initiated_login)
       connection_id = claims.get('connection_id', None)
       organization_id = claims.get('organization_id', None)
       login_hint = claims.get('login_hint', None)
       relay_state = claims.get('relay_state', None)
       options.connection_id=connection_id
       options.state=relay_state

       # 3. Generate Authorization URL
       authorization_url = scalekit.get_authorization_url(
         redirect_uri=redirect_uri,
         options=options
       )

       return redirect(url)
   ```

   </TabItem>
   <TabItem value="golang" label="Go">

   ```go showLineNumbers "idp_initiated_login"
   // 1. Default redirect URL is callback with JWT
   code := r.URL.Query().Get("code")
   err_description := r.URL.Query().Get("error_description")
   if err_description != "" {
       http.Error(w, err_description, http.StatusBadRequest)
       return
   }

   // 2. Decode the JWT
   if idpInitiatedLogin := r.URL.Query().Get("idp_initiated_login"); idpInitiatedLogin != "" {
     claims, err := a.scalekit.GetIdpInitiatedLoginClaims(idpInitiatedLogin)
     if err != nil {
       http.Error(w, err.Error(), http.StatusInternalServerError)
       return
     }

     // 3. Generate Authorization URL
     options := scalekit.AuthorizationUrlOptions{
       // Either ONE of the following properties
       ConnectionId:   claims.ConnectionID,
       OrganizationId: claims.OrganizationID,
       LoginHint:      claims.LoginHint,
     }
     authUrl, err := a.scalekit.GetAuthorizationUrl(a.redirectUrl, options)

     if err != nil {
       http.Error(w, err.Error(), http.StatusInternalServerError)
       return
     }
     http.Redirect(w, r, authUrl.String(), http.StatusFound)
   }
   ```

   </TabItem>
   <TabItem value="java" label="Java">

   ```java showLineNumbers=false wrap "idp_initiated_login"
   // 1. Default redirect URL is callback with JWT
   @GetMapping("/callback")
   public RedirectView callbackHandler(
       @RequestParam(required = false) String code,
       @RequestParam(required = false,
           name = "error_description") String errorDescription,
       @RequestParam(required = false,
           name = "idp_initiated_login") String idpInitiatedLoginToken,

       HttpServletResponse response) throws IOException {
     if (errorDescription != null) {
       // Handle Errors
       }

     // 2. Decode the JWT
     if (idpInitiatedLoginToken != null) {
       IdpInitiatedLoginClaims idpInitiatedLoginClaims =
           scalekit.authentication().getIdpInitiatedLoginClaims(
               idpInitiatedLoginToken);
       if (idpInitiatedLoginClaims == null) {
         response.sendError(HttpStatus.BAD_REQUEST.value(),
             "Invalid idp_initiated_login token");
         return null;
       }
       // Either ONE of the following
       AuthorizationUrlOptions options = new AuthorizationUrlOptions();
       if (idpInitiatedLoginClaims.getConnectionID() != null) {
         options.setConnectionId(idpInitiatedLoginClaims.getConnectionID());
       }
       if (idpInitiatedLoginClaims.getOrganizationID() != null) {
         options.setOrganizationId(idpInitiatedLoginClaims.getOrganizationID());
       }
       if (idpInitiatedLoginClaims.getLoginHint() != null) {
         options.setLoginHint(idpInitiatedLoginClaims.getLoginHint());
       }

       // 3. Generate Authorization URL
       String url = scalekit.authentication()
                       .getAuthorizationUrl(redirectUrl, options)
                       .toString();
       response.sendRedirect(url);
       return null;
     }
   ```

   </TabItem>
   </Tabs>
   </div>

4. **Handle errors**: If errors occur, the redirect URI will receive a callback with error information. See the <a href="/reference/errors/" target="_blank">error handling</a> guide for more details.

   ```sh showLineNumbers=false wrap
   https://{your-subdomain}.scalekit.dev/callback
     ?error="<error_category>"
     &error_description="<details>"
   ```

</Steps>

## Integrating with a Downstream Auth Provider

If your application uses a third-party service like [Firebase Authentication](/guides/integrations/auth-systems/firebase/) to manage user sessions, you must initiate its sign-in flow after completing **Step&nbsp;3**.

This process has two stages: first, the IdP redirects the user to your app via Scalekit, and second, your app triggers a new sign-in flow with Firebase using the Authorization URL you just generated.

```mermaid
graph LR;
    subgraph "Part 1: IdP-initiated"
        User-->IdP-->Scalekit-->YourApp["Your App (default endpoint)"];
    end
    subgraph "Part 2: SP-initiated Hand-off"
        YourApp -- "triggers sign-in" --> Firebase;
        Firebase -- "uses Authorization URL from Step 3" --> Scalekit;
    end
```

The example below shows how to pass the Authorization URL to the Firebase Web SDK.

<Tabs syncKey="downstream-auth">
<TabItem value="firebase-js" label="Firebase (Web SDK)">

```javascript
import { getAuth, OAuthProvider, signInWithRedirect } from "firebase/auth";

const auth = getAuth();

// "scalekit" is the OIDC provider you configured in Firebase.
const scalekitProvider = new OAuthProvider("scalekit");

// This is the `authorizationUrl` from Step 3.
scalekitProvider.setCustomParameters({
  authorization_url: authorizationUrl,
});

signInWithRedirect(auth, scalekitProvider);
```

</TabItem>
</Tabs>

This pattern applies to other OIDC-compatible providers like Auth0 or AWS Cognito. Simply supply the Authorization URL from **Step&nbsp;3** to start the provider's standard sign-in flow.

## Troubleshooting

If you encounter issues implementing IdP-initiated SSO:

1. Verify your redirect URI is properly configured in the Scalekit Dashboard
2. Check that you're correctly processing the JWT token from the `idp_initiated_login` parameter
3. Ensure your error handling properly captures and processes any error messages

## Benefits of this approach

The advantages of using Scalekit's approach are:

- **Enhanced security**: Overcomes the security risks of handling IdP-initiated SSO
- **Seamless experience**: The additional redirect is almost instantaneous, providing a smooth user experience

## Security considerations

While IdP-initiated SSO offers convenience, it comes with significant security risks:

### Potential security risks

**Stolen SAML assertions**: Attackers can steal SAML assertions and use them to gain unauthorized access. If an attacker manages to steal these assertions, they can:

- Inject them into another service provider, gaining access to that user's account
- Inject them back into your application with altered assertions, potentially elevating their privileges

With a stolen SAML assertion, an attacker can gain access to your application as the compromised user, bypassing the usual authentication process.

### How attackers steal SAML assertions

Attackers can steal SAML assertions through various methods:

- **Man-in-the-middle (MITM) attacks**: Intercepting and replacing the SAML response during transmission
- **Open redirect attacks**: Exploiting improper endpoint validation to redirect the SAML response to a malicious server
- **Leaky logs and headers**: Sensitive information, including SAML assertions, can be leaked through logs or headers
- **Browser-based attacks**: Exploiting browser vulnerabilities to steal SAML assertions

### The challenge for service providers

The chief problem with stolen assertions is that everything appears legitimate to the service provider (your application). The message and assertion are valid, issued by the expected identity provider, and signed with the expected key. However, the service provider cannot verify whether the assertions are stolen or not.

================
File: sso/guides/launch-checklist.mdx
================
---
title: Production launch checklist
description: "A comprehensive checklist for launching your Scalekit SSO integration, covering environment variables, security, redirect URIs, testing, and more."
sidebar:
  label: "Launch checklist"
prev: false
next: false
tableOfContents: false
---

import { Aside, TabItem, Tabs, Steps } from "@astrojs/starlight/components"
import CheckItem from '@components/ui/CheckItem.astro';

As you prepare to deploy your Scalekit integration to production, it's crucial to verify that all configurations are optimized for security and user experience.

The following checklists help ensure your implementation is production-ready and efficient.

As you get ready to deploy your Single Sign-On (SSO) implementation to production, it's important to double-check that everything is properly configured for optimal security and a seamless user experience. The checklist below outlines recommended steps to ensure your SSO integration is robust, efficient, and maintainable in a live environment.

<Steps>

1. <CheckItem iconName="approve-check-circle"> **Use appropriate environment variables**</CheckItem>

    Switch from development to production credentials, including the client ID, client secret, and environment URL.

2. <CheckItem iconName="approve-check-circle"> **Secure the client secret** </CheckItem>

    Your client secret is akin to a key to your application. Secure it with the utmost care. Go through our [best practices guide](/guides/client-credentials-practices/) to learn how to manage the client secrets safely and securely.

3. <CheckItem iconName="approve-check-circle"> **Verify redirect URI configuration** </CheckItem>

    Double-check your redirect URI settings in the production environment to ensure they point to the correct endpoints. For guidelines on valid configurations, visit our [Redirect URI configuration guide](/sso/reference/redirects/).

4. <CheckItem iconName="approve-check-circle"> **Test the single sign-on flows** </CheckItem>

    Ensure that you have implemented and tested all possible single sign-on workflows between your application and your customer's identity providers. Go through our [how-to guide](/sso/guides/test-sso) to understand all the SSO scenarios and how to validate them for production readiness. Especially, ensure you have validated for the following important business cases:

    - SP initiated SSO
    - IdP initiated SSO
    - Errors during SSO flow

5. <CheckItem iconName="approve-check-circle"> **Finalize branding & theming** </CheckItem>

    For a consistent and professional user experience, confirm your branding (logos, accent colors, etc) is applied to the Admin Portal.

6. <CheckItem iconName="approve-check-circle"> **Review Admin Portal URL** </CheckItem>

    Customize the Admin Portal URL to match your domain (for example, `https://sso.b2b-app.com`) for a seamless brand experience. Also, remember to update `.env` file post-CNAME configuration.

7. <CheckItem iconName="approve-check-circle"> **Graceful error handling** </CheckItem>

    Test your integration thoroughly across all possible edge cases, including incomplete, invalid, or duplicate data submissions.

</Steps>

================
File: sso/guides/okta-sso-test.mdx
================
---
title: Test SSO integration with Okta
description: Learn how to test your SSO implementation with Okta using Scalekit, covering SP-initiated, IdP-initiated, and error handling scenarios.
sidebar:
  label: Test SSO with Okta
  order: 2
prev: false
next:
  label: Launch checklist
  link: /sso/guides/launch-checklist/
---

import { Steps, Aside, Badge } from '@astrojs/starlight/components'

Using our [Quickstart](/sso/quickstart/), you would have integrated Scalekit and implemented the SSO authentication
in your sandbox environment. Now, it's time to test your SSO integration for all possible customer scenarios.

Before getting started, we recommend you signup for an <a href="https://developer.okta.com/signup/" target="_blank">Okta developer account</a> so
that you can test and verify SSO integration with Scalekit.

## Setup your environment for testing

For effective testing purposes, lets simulate a real scenario of onboarding an enterprise organization to your application. Assume the organization uses Okta as identity provider and is expecting to Single Sign-on with Okta.

<Steps>
1. Create an organization in the [Scalekit Dashboard](https://app.scalekit.com) with a name that reflects your customer
2. Generate an [Admin Portal link](/guides/sso/admin-portal/) in the overview section of the created organization
3. Open the Admin Portal link and follow our [Okta Integration guide](/guides/integrations/sso-integrations/okta-saml/) to setup an active SSO connection using Okta
</Steps>

<Aside>

You can [customize the admin portal](/guides/sso/admin-portal/#customize-the-admin-portal) and theme it according to your
application's brand guidelines to give a more polished experience.

</Aside>

Now that you have an active SSO connection, make sure that you have successfully validated the below scenarios.

## Single Sign-on scenarios to validate

### SP Initiated SSO <Badge text="Scenario 1" variant="note" />

In this scenario, user starts the Single Sign-on flow from your application's login page.

![SP initiated SSO workflow](@/assets/docs/guides/extended/okta-sso-test/how-sso-works.png)

Validate the following:

<Steps>
1. Scalekit redirects the user to the appropriate identity provider based on the
  [Authorization URL](/sso/guides/authorization-url/) you provided
2. Your application can retrieve the user details by exchanging the `code` you received in the above step
</Steps>

### IdP Initiated SSO <Badge text="Scenario 2" variant="note" />

In this scenario, user is logged in the identity provider and selects your application. The SSO flow gets initiated from
the identity provider (IdP). Diagram below explains the workflow

![Scalekit's recommended workflow for IdP initiated SSO](@/assets/docs/guides/extended/okta-sso-test/idp-initiated-sso.png)

Validate the following:

<Steps>
1. User is redirected to the default Redirect URI with request parameters. This Redirect URI is configured in the Scalekit dashboard
2. Your application detects this as IdP-initiated SSO (based on the request parameters) and initiates the SP-initiated SSO. For step-by-step details, check out this guide on the [implementing Idp-initiated SSO](/sso/guides/idp-init-sso/)
3. User is redirected to the appropriate identity provider based on the Authorization URL provided
4. After the user is authenticated by the identity provider, they are navigated to the Redirect URI with a one time `code` along with the `state` parameter sent in the Authorization URL
5. Your application can retrieve the user details by exchanging the `code` you received in the above step
</Steps>

### Handling errors <Badge text="Scenario 3" variant="note" />

Sometimes, SSO login could fail due to improper SSO configuration, incomplete user profiles, or integration issues with the identity provider.

Handle errors and display appropriate error messages to your users. Go through the possible [error codes](/sso/reference/sso-integration-errors/).

================
File: sso/guides/sso-basics.mdx
================
---
title: Introduction to Single Sign-on
description: "Learn the basics of Single Sign-On (SSO), including how SAML and OIDC protocols work, and how Scalekit simplifies enterprise authentication."
sidebar:
  label: SSO basics
next:
  label: SSO quickstart
  link: /sso/quickstart/
---


Single Sign-On (SSO) streamlines user access by enabling a single authentication event to grant access to multiple applications with the same credentials. For example, logging into one Google service, such as Gmail, automatically authenticates you to YouTube, Google Drive, and other Google platforms.

There are two key benefits to the users and organizations with a secure single sign-on implementation:

1. User can seamlessly access multiple applications using only one set of credentials.
2. User credentials are managed in a centralized identity system. This enables Admins to easily configure and manage authentication policies for all their users from the centralized identity provider.

Furthermore, this integrated SSO mechanism enhances user convenience, boosts productivity, and reduces the risks associated with password fatigue and reuse. These security & administration benefits are driving factors for enterprise organizations to only procure SaaS applications that offer SSO-based authentication.

## How Single Sign-On (SSO) works

Fundamentally, Single Sign-on works by exchanging user information in a pre-determined format between two trusted parties - your application and your customer's identity provider (aka IdP). Most of these interactions happen in the browser context as some steps need user intervention.

To ensure secure exchange of user information between your application and your customer's identity provider, most IdPs support two protocols: Secure Assertion Markup Language (SAML) or OpenID Connect (OIDC). The objective of both these protocols is same: allow secure user information exchange between the Service Provider (your application) and Identity Provider (your customer's identity system). These protocols differ in how these systems trust each other, communicate, and exchange user information.

Let's understand these protocols at a high level.

## SAML

SAML 2.0 (Secure Assertion Markup Language) has been in use since 2005 and is also most widely implemented protocol. SAML exchanges user information using XML files via HTTPS or SOAP. But, before the user information is exchanged between the two parties, they need to establish the trust between them. Trust is established by exchanging information about each other as part of SAML configuration parameters like Assetion Consumer Service URL (ACS URL), Entity ID, X.509 Certificates, etc.

After the trust has been established, subsequent user information can be exchanged in two ways -

1. your application requesting for a user's information - this is Service Provider initiated login flow
2. Or the identity provider directly shares user details via a pre-configured ACS URL - this is Identity Provider initiated Login flow

Lets understand these two SSO flows.

### Service Provider initiated SSO

![SP initiated SSO
  workflow](@/assets/docs/home/sso-basics/1.png)


For service provider initiated SSO flow,

1. User tries to access your application and your app identifies that the user's credentials need to be verified by their identity provider.
2. Your application requests the identity provider for the user's information.
3. The identity provider authenticates the user and returns user details as "assertions" to your application.
4. You validate assertions, retrieve the user information, and if everything checks, allow the user to successfully login yo your application.

As you can imagine, in this workflow, the user login behaviour starts from your application and thats why this is termed as service provider initiated SSO (aka SP-initiated SSO)

### Identity Provider initiated SSO


  ![IdP initiated SSO
  workflow](@/assets/docs/home/sso-basics/2-idp-init-sso.png)


In case of Identity Provider initiated SSO,

1. User logs into their identity provider
   portal and selects your application from within the IdP portal.
2. Identity Provider sends the user details as assertions to your application.
3. You validate assertions, retrieve the user information, and if everything checks, allow the user to successfully
   login yo your application.

Since the user login workflow starts from the Identity Provider portal (and not from your application), this flow is called as Identity Provider initiated SSO (aka IdP-initiated SSO).

#### Risks with IdP initiated SSO

IdP initiated SSO is susceptible for common security attacks like Man In the Middle attack, Stolen Assertion attack or Assertion Replay attack etc. Read the [IdP initiated SSO](/sso/guides/idp-init-sso) guide to understand these risks and how to mitigate them.

## OIDC

OpenID Connect (OIDC) is an authentication protocol based on top of OAuth 2.0 to simplify the user information exchange process between Relying Party (your application) and the OpenID Provider (your customer's Identity Provider). The OIDC protocol exchanges user information via signed JSON Web Tokens (JWT) over HTTPS. Because of the simplified nature of handling JWTs, it is often used in modern web applications, native desktop clients and mobile applications. With the latest extensions to the OIDC procotol like Proof Key of Code Exchange (PKCE) and Demonstrating Proof of Possession (DPoP), the overall security of user exchange information is strengthened.

In it's current format, OIDC only supports SP initiated Login. In this flow:

1. User tries to access your application. You identify that this users credentials need to be verified by their Identity Provider.
2. Your application requests the user's Identity Provider for the user's information via an OAuth2 request.
3. Identity Provider authenticates the user and sends the users details with an authorization_code to a pre-registered redirect_url on your server.
4. You will exchange the code for the actual user details by providing your information with the Identity provider.
5. Identity Provider will then send the user information in the form of JWTs. You retrieve the user information from those assertions and if everything is valid, you will allow the user inside your application.

#### How does Scalekit help

Scalekit serves as an intermediary, abstracting the complexities involved in handling SSO with SAML and OIDC protocols. By integrating with Scalekit in just a few lines of code, your application can connect with numerous IdPs efficiently, ensuring security and compliance.

================
File: sso/guides/sso-user-attributes.mdx
================
---
title: User attributes
description: "Learn how to add and map custom user attributes, such as an employee number, from an Identity Provider (IdP) like Okta using Scalekit."
sidebar:
  label: Customize user attributes
prev:
  label: Test SSO
  link: /sso/guides/test-sso/
next:
  label: Launch checklist
  link: /sso/guides/launch-checklist/
---

import { Steps, Aside, Badge } from '@astrojs/starlight/components'

Scalekit simplifies Single Sign-On (SSO) by managing user information between Identity Providers (IdPs) and B2B applications. The IdPs provide standard user properties, such as email and firstname, to your application, thus helping recognize the user.

Consider that we want to get employee number of the user logging into the application. This guide demonstrates how to add your own custom attribute (such as employee number) and map its value from the Identity Provider.

Broadly, we'll go through two steps:

1. Create a new attribute in Scalekit
2. Set up the value that the Identity Provider should relay to this attribute

### Create a new attribute

Let's begin by signing into Scalekit dashboard:

<Steps>
1. Navigate to the "SSO" section
2. In the "User Attributes" section, click on "Add Attribute"
3. Add "Employee Number" as Display name
</Steps>

<figure>
  ![add attribute](@/assets/docs/guides/product/setup-sso/customize-user-attributes/1-add-attribute-scalekit.png)
</figure>

You'll now notice "Employee Number" in the list of user attributes. Scalekit is now ready to receive this attribute from your customers' identity providers (IdPs)

<figure>
  ![see attribute](@/assets/docs/guides/product/setup-sso/customize-user-attributes/2-see-attribute-scalekit.png)
</figure>

### Set up IdP attributes

Now, we'll set up an Identity Provider to send these details. For the purposes of this guide, we'll use Okta as IdP to send the `employee_number` to Scalekit. However, similar functionality can be achieved using any other IdP.

Note that in this specific Okta instance, the "Employee Number" is a default attribute that hasn't been utilized yet. Before we proceed forward, it's important to modify the profile's "employee_number" attribute with any desired number for this example (For example, `1729`). For a detailed guide on how to achieve this, consult <a href="https://help.okta.com/en-us/content/topics/users-groups-profiles/usgp-edit-user-attributes.htm#:~:text=Click%20the%20Profile%20tab" target="_blank" rel="noopener noreferrer">Okta's dedicated help article on updating profile attributes</a>.

Alternatively, you can <a href="https://help.okta.com/en-us/content/topics/users-groups-profiles/usgp-add-custom-user-attributes.htm#:~:text=In%20the%20Admin%20Console%20%2C%20go%20to%20Directory%20Profile%20Editor" target="_blank" rel="noopener noreferrer">add a new custom attribute in the Okta Profile Editor</a>.

<figure>
  ![map attribute](@/assets/docs/guides/product/setup-sso/customize-user-attributes/3-map-attribute-okta.png)
</figure>

### Test SSO for new attributes

In the Scalekit dashboard, navigate to Organizations.

<Steps>
1. Select the Organization that you'd like to add custom attribute
2. Navigate to the SSO Connection
3. Go to **Test Connection** - you'll find this if the IdP has already been established
</Steps>

<figure>
  ![map attr scalekit](@/assets/docs/guides/product/setup-sso/customize-user-attributes/4-map-attribute-scalekit.png)
</figure>

Upon testing the connection, if you notice the update user profile (employee_number as 1729 in this example), this signifies a successful test.

Subsequently, these details will be integrated into your B2B application through Scalekit. This ensures seamless recognition and handling of customer user attributes during the SSO authentication process.

================
File: sso/guides/test-sso.mdx
================
---
title: Test SSO
description: Validate your Single Sign-On implementation using our test environment
sidebar:
  label: Test Single Sign-On
prev:
  link: /sso/quickstart
  label: Integrate SSO
next:
  link: /guides/sso/admin-portal/
  label: Admin Portal
---

import { Aside, TabItem, Tabs, Steps, Badge } from "@astrojs/starlight/components"

After implementing Single Sign-On using our [Quickstart guide](/sso/quickstart/), you need to validate your integration for all possible scenarios. We have set up your development environment with two key components to make testing comprehensive and straightforward:

1. **Identity Provider Simulator:** Test all possible Single Sign-On scenarios without requiring external services like Okta or Microsoft Entra ID.
2. **Test organization:** Access a pre-configured organization with an SSO connection to our IdP Simulator and domains like `@example.com` or `@example.org` for testing.

To ensure a successful SSO implementation, test all three scenarios described in this guide before deploying to production.

## Service provider (SP) initiated SSO <Badge text="Scenario 1" variant="note" />

In this common scenario, users start the Single Sign-On process from your application's login page.

**How SP-initiated SSO works**

<figure>
  ![SP initiated SSO](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/1.png)
  <figcaption>SP (Your application) Initiated SSO</figcaption>
</figure>

**Locating your test organization**

  ![SP initiated SSO](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/1.1.png)


### Generating an authorization URL

Use the following code to generate an authorization URL with your organization ID (as shown in step 2 of the sequence diagram). See the [Authorization URL documentation](/sso/guides/authorization-url/) for more details.

<Tabs syncKey="tech-stack">
<TabItem value="nodejs" label="Node.js">

```js wrap
const options = {};
options['organizationId'] = 'org_32656XXXXXX0438';

// Generate Authorization Url
const authorizationURL = scalekit.getAuthorizationUrl(redirectUrl, options);

res.redirect(authorizationUrl);
```

</TabItem>

<TabItem value="python" label="Python">

```py
options = {"organizationId": 'org_32656XXXXXX0438'}

# Generate Authorization URL
authorization_url = scalekit.get_authorization_url(
    redirect_url,
    options,
)

redirect(authorization_url)
```

</TabItem>

<TabItem value="go" label="Go">

```go
options.organizationId = "org_32656XXXXXX0438"

// Generate Authorization URL
authorizationURL := scalekitClient.GetAuthorizationUrl(
  redirectUrl,
  options,
)

// Redirect the user to the Authorization URL
```

</TabItem>
<TabItem value="java" label="Java">

```java
options.setOrganizationId("org_32656XXXXXX0438");

// Generate Authorization Url
String url = scalekitClient
        .authentication()
        .getAuthorizationUrl(redirectUrl, options)
        .toString();

// Redirect the user to the Authorization URL
```

</TabItem>
</Tabs>

### Testing with the IdP Simulator

1. The user will be redirected to the Identity Provider (IdP) Simulator
2. Select "User login via SSO" to view the simulation form
3. Enter user details to simulate a user signing in via SSO

<figure>
  ![IdP Simulator](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/2.1.png)
</figure>

After entering the user details, your application will receive an `idToken` indicating successful simulation. The token contains the following details:

<figure>
  ![IdP Simulator](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/2.2.png)
</figure>

<Aside>
**Note:** To receive custom attributes from the IdP Simulator, first register them in Scalekit Workspace at Development > Single Sign-On > Custom Attributes.
</Aside>

## Identity Provider (IdP) initiated SSO <Badge text="Scenario 2" variant="note" />

In this scenario, users start the sign-in process from the Identity Provider, typically through an applications catalog. This allows users to conveniently access applications available within their organization.

If you haven't implemented IdP-initiated SSO in your application yet, follow our [guide for implementing IdP-initiated SSO](/sso/guides/idp-init-sso) before testing this scenario.

![How IdP-initiated SSO works](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/4.png)

### Testing IdP-initiated SSO

1. Generate the authorization URL using the Test organization
2. Get redirected to the IdP Simulator
3. Select "IdP initiated SSO" from the dropdown menu
4. Enter test user details to simulate the login

![IdP initiated SSO](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/3.1.png)

### Testing IdP-initiated requests

Implement logic in your callback handler to identify and process IdP-initiated requests from Scalekit. Learn more about [implementing IdP-initiated SSO](/sso/guides/idp-init-sso).

![IdP initiated SSO](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/3.2.png)

For IdP-initiated callbacks, retrieve necessary details (such as `connection_id` or `organization_id`) from Scalekit to construct an authorization URL. This effectively converts an IdP-initiated SSO into an SP-initiated SSO.

<Aside type="tip" >
- For simulation purposes, select and simulate IdP-initiated SSO in the IdP simulator. In real scenarios, users would choose your app from their Identity Provider.
- The IdP simulator uses the default redirect URL as the callback URL. Ensure the correct default redirect URL is configured in your Scalekit dashboard.
</Aside>

## Error handling <Badge text="Scenario 3" variant="note" />

Your application should gracefully handle error scenarios to provide a good user experience.

To test error handling:

  ![Error scenario](@/assets/docs/manual/fundamentals/testing-sso/with-idp-simulator/5.png)

<Steps>
1. Redirect to the authorization URL
2. Select the "Error" scenario in the IdP simulator
3. Process the error in your callback handler
</Steps>

================
File: sso/guides/user-profile-details.mdx
================
---
title: Normalized user profile
description: "Learn how Scalekit's normalized user profiles standardize identity data across providers, streamlining single sign-on (SSO) integration and user management."
prev: false
next: false
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

When a user logs in with SSO, each identity provider shares the user profile information in their own format. This adds
complexity for the application developers to parse the user profile info and code related identity workflows. To make
this seamless for developers, Scalekit normalizes the user profile info into a standard set of fields across all
identity providers.

This means that you'd always receive the user profile payload in a fixed set of fields, irrespective of the identity
provider and protocol you interact with. This is one of our foundational aspects of the unified SSO solution.

```json title="Sample normalized user profile"
{
    "email": "john.doe@acmecorp.com",
    "email_verified": true,
    "family_name": "Doe",
    "given_name": "John",
    "locale": "en",
    "name": "John Doe",
    "picture": "https://lh3.googleusercontent.com/a/ACg8ocKNE4TZ...iEma17URCEf=s96-c",
    "sub": "conn_17576372041941092;google-oauth2|104630259163176101050",
    "identities": [
        {
            "connection_id": "conn_17576372041941092",
            "organization_id": "org_17002852291444836",
            "connection_type": "OIDC",
            "provider_name": "AUTH0",
            "social": false,
            "provider_raw_attributes": {
                "aud": "ztTgHijLLguDXJQab0oiPyIcDLXXrJX6",
                "email": "john.doe@acmecorp.com",
                "email_verified": true,
                "exp": 1714580633,
                "family_name": "Doe",
                "given_name": "John",
                "iat": 1714544633,
                "iss": "https://dev-rmmfmus2g7vverbf.us.auth0.com/",
                "locale": "en",
                "name": "John Doe",
                "nickname": "john.doe",
                "nonce": "Lof9SpxEzs9dhUlJzgrrbQ==",
                "picture": "https://lh3.googleusercontent.com/a/ACg8ocKNE4T...17URCEf=s96-c",
                "sid": "5yqRJIfjPh8c7lr1s2N-IbY6WR8VyaIZ",
                "sub": "google-oauth2|104630259163176101050",
                "updated_at": "2024-04-30T10:02:30.988Z"
            }
        }
    ]
}
```

## Full list of user profile attributes

| Profile attribute | Data type | Description |
|------------------|-----------|-------------|
| `sub` | string | An identifier for the user, as submitted by the identity provider that completed the single sign-on. |
| `email` | string | The user's email address. |
| `email_verified` | boolean | True if the user's e-mail address has been verified as claimed by the identity provider; otherwise false. |
| `name` | string | Fully formatted user's name |
| `family_name` | string | The user's surname or last name. |
| `given_name` | string | The user's given name or first name. |
| `locale` | string | The user's locale, represented by a BCP 47 language tag. Example: 'en' |
| `picture` | string | The user's profile picture in URL format |
| `identities` | Array of [Identity objects](/sso/guides/user-profile-details/#identity-object-attributes) | Array of all identity information received from the identity providers in the raw format |

### Identity object attributes

| Identity attribute | Data type | Description |
|-------------------|-----------|-------------|
| `organization_id` | string | Unique ID of the organization to which this user belongs to |
| `connection_id` | string | Unique ID of the connection for which this identity data is fetched from |
| `connection_type` | string | type of the connection: SAML or OIDC |
| `provider_name` | string | name of the connection provider. Example: Okta, Google, Auth0 |
| `social` | boolean | Is the connection a social provider (like Google, Microsoft, GitHub etc) or an enterprise connection. |
| `provider_raw_attributes` | object | key-value map of all the raw attributes received from the connection provider as-is |

<Aside type="note">

- The `sub` field is a concatenation of the `connection_id` and a unique identifier assigned to the user by the identity provider.
- The identities array may contain multiple objects if the user has authenticated through different methods.
- The `provider_raw_attributes` object contains all original data from the identity provider, which may vary based on the provider and connection type.

</Aside>

================
File: sso/reference/redirects.mdx
================
---
title: Redirect URI
description: "Learn how to configure and validate redirect URIs in Scalekit for secure post-authentication flows, including rules for development and production environments."
sidebar:
  label: Configure redirects
prev: false
next: false
---

import { Aside } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';

A redirect URI is an endpoint where Scalekit redirects users post-authentication with the identity provider (IdP). In the Scalekit dashboard, you can configure up to 5 redirect URIs per environment.

Since redirect URIs can be manipulated by unauthorized parties, Scalekit requires pre-registration of all redirect URIs used in login flows. Registration can be done in the Scalekit dashboard.

<Aside type="note" title="IdP-initiated SAML SSO flow">

Scalekit uses your configured default redirect URI to redirect users when users initiate SSO from their identity provider

</Aside>

## URI Requirements

### Validation Rules

| Validation rule                                                                                                 | Development environment                                                                                                                 | Production environment                         |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| Schemes supported                                                                                               | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `http` <Icon name="approve-check" /> `https`</div>                                     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https`</div> |
| localhost                                                                                                       | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> Allowed</div>                                                                                                                 | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Wildcard support (\*)                                                                                           | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> Allowed</div> | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Max URI length                                                                                                  | 256 characters                                                                                                                          | 256 characters                                 |
| Query parameters <pre>yourapp.com/callback?query=value</pre>     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                                                                                                                | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |
| Fragment component <pre>`yourapp.com/callback#fragment=value`</pre> | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                                                                                                                | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> Not allowed</div>                       |

### Using Wildcards

According to the <a href="https://tools.ietf.org/html/rfc6749#section-3.1.2" target="_blank">OAuth 2.0 specification</a>, a redirection URI must be an absolute URI. But, to make development and testing easier - this restriction is slightly relaxed in the development environments.

For development, wildcards can simplify testing. However, they must follow these rules:

| Validation rule                                                                     | Example                                                                                                                                                                                                          |
| ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Wildcard characters are not allowed as a root-level domain                          | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://*.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://auth-*.acmecorp.com`</div> |
| A redirect URI can have only one wildcard character                                 | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://*.*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div>                                                                            |
| Wildcard character must be located in a subdomain within the hostname component     | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://acmecorp.*.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.acmecorp.com`</div>                                                                  |
| Wildcard must be part of the subdomain that is farthest from the hostname component | <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="error" /> `https://auth.*.acmecorp.com`</div> <div style="display: inline-flex; align-items: center; gap: 0.5rem;"><Icon name="approve-check" /> `https://*.auth.acmecorp.com`</div>                                                        |

================
File: sso/reference/sso-integration-errors.mdx
================
---
title: "Error handling during single sign-on"
description: "Learn how to identify and resolve common single sign-on errors in Scalekit, ensuring a seamless authentication experience for your users"
sidebar:
  label: "Error reference"
prev: false
next: false
---

Reference of error codes and how to handle them

When users attempt to log in via single sign-on (SSO) using Scalekit, any issues encountered will result in error details being sent to your application's redirect URI via the `error` and `error_description` query parameters. Proper error handling ensures a better user experience.

## Integration related errors

If there is any issue between Scalekit and your application, the following errors may occur:

:::tip
Ideally, you would want to catch these errors in the development environments. These errors are not meant to be exposed to your customers in the production environments.
:::

| Error | Error description | Possible resolution strategy |
|-------|------------------|----------------------------|
| <pre>invalid_redirect_uri</pre> | Redirect URI is not part of the pre-approved list of redirect URIs | Add the valid URL in the Scalekit dashboard before using it |
| <pre>invalid_connection_selector</pre> | Missing `organization_id` (or) `connection_id` (or) `domain` (or) `provider` in the authorization URL | Include at least one of these parameters in the request |
| <pre>no_active_connections</pre> | There are no active SSO connections configured to process the single sign-on request | Ensure active SSO connections are set up |
| <pre>connection_not_active</pre> | The configured connection is not active | Enable the SSO connection in the Scalekit dashboard |
| <pre>no_configured_connections</pre> | No active SSO connections configured | Ensure active SSO connections are set up |
| <pre>invalid_organization_id</pre> | Invalid organization ID | Verify and use a valid organization ID |
| <pre>invalid_connection_id</pre> | Invalid connection ID | Verify and use a valid connection ID |
| <pre>domain_not_found</pre> | No domain specified for the SSO connection(s) | Check domain configuration in Scalekit dashboard |
| <pre>invalid_user_domain</pre> | User's domain not allowed for this SSO connection | Ensure user domain is part of the allowed domains list |
| <pre>server_error</pre> | _actual error description from the server_ | This must be a rare occurrence. Please reach out to us via your private slack channel or <a href="mailto:support@scalekit.com" target="_blank" rel="noopener">via email</a> |

## SSO configuration related errors

If SSO configuration issues arise, you will encounter the following errors:

:::tip
Ideally, these errors should have been caught and handled by your customer's IT admin at the time of SSO configuration. If your customers encounter problems with the single sign-on (SSO) setup, they will have the opportunity to review and correct the configuration during the "Test connection" step.

Once your customer configures the SSO settings properly, tests the configuration and enables it - you shouldn't receive these errors unless something has been modified, tampered or changed with identity provider.
:::

| Error code | Error description | Possible resolution strategy |
|------------|------------------|----------------------------|
| <pre>mandatory_attribute_missing</pre> | Missing mandatory user attributes | Ensure all the mandatory user attributes are configured properly |
| <pre>invalid_id_token</pre> | Invalid ID token | Check the identity provider's functioning |
| <pre>failed_to_exchange_token</pre> | Token exchange failure due to incorrect `client_secret` | Update the `client_secret` with the correct value |
| <pre>user_info_retrieve_failed</pre> | User info retrieval failed, possibly due to an incorrect `client_secret` or other issues | Update the `client_secret` with the correct value. If unsuccessful, investigate further. Please reach out to us via your private slack channel or <a href="mailto:support@scalekit.com" target="_blank" rel="noopener">via email</a> |
| <pre>invalid_saml_metadata</pre> | Incorrect SAML metadata configuration | Update SAML metadata URL with the correct value |
| <pre>invalid_saml_response</pre> | Invalid SAML response | Review and fix SAML configuration settings |
| <pre>signature_validation_failed</pre> | Failed signature validation | Review and update the ACS URL in the identity provider's settings |
| <pre>invalid_acs_url</pre> | Invalid ACS URL | Review and update the ACS URL in the identity provider's settings |
| <pre>invalid_status</pre> | Invalid status | Review and update the SAML configuration settings in the identity provider |
| <pre>malformed_saml_response</pre> | Marshalling error | Ensure SAML response is properly formatted |
| <pre>assertion_expired</pre> | Expired SAML assertion | We received an expired SAML assertion. This could be because of clock skew between the identity provider's server and our servers. Please reach out to us via your private slack channel or <a href="mailto:support@scalekit.com" target="_blank" rel="noopener">via email</a> |
| <pre>response_expired</pre> | Expired SAML response | We received an expired SAML response. This could be because of clock skew between the identity provider's server and our servers. Please reach out to us via your private slack channel or <a href="mailto:support@scalekit.com" target="_blank" rel="noopener">via email</a> |

================
File: sso/quickstart.mdx
================
---
title: Getting started with SSO
description: "Learn how to integrate Single Sign-On (SSO) into your B2B SaaS application with Scalekit, supporting both SAML and OIDC protocols."
sidebar:
  order: 1
  label: "Quickstart"
head:
  - tag: style
    content: |
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
next:
  label: Test SSO
  link: /sso/guides/test-sso/
prev: false

---

import { LinkButton, Aside, Steps, Tabs, TabItem, CardGrid, Card } from '@astrojs/starlight/components';

import InstallSDK from '@components/templates/_installsdk.mdx';
import SimpleCode from '@components/ui/SimpleCode.astro';
import CopyPrompt from '@components/ui/CopyPrompt.astro';

Integrate **Single Sign-On (SSO)** with Scalekit to enhance your B2B SaaS application's security. Scalekit provides seamless user experiences by abstracting the complexities of **SAML** and **OIDC** protocols. Using Scalekit's authentication platform, you can implement enterprise-grade SSO with minimal code. We offer [pre-built integrations](/guides/integrations/sso-integrations) with major identity providers including Okta, Microsoft Entra ID, JumpCloud, and OneLogin.

The following diagram illustrates the flow in a nutshell:

![Diagram showing the SSO authentication flow: User initiates login → Scalekit handles protocol translation → Identity Provider authenticates → User gains access to your application](@/assets/docs/sso-quickstart/1.png)

This quickstart guide walks you through the SSO implementation process. You will learn how to deliver enterprise authentication features without managing complex protocol details.

<Card title="Generate SSO Code with AI in Minutes" icon="seti:vite" style="background-color: white !important;">
<div style={{display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '0.5rem'}}>
<div style={{flex: '3'}}>
Input this prompt in your IDE to analyze your existing code base and generate SSO implementation code accordingly.

<span style={{fontSize: '0.875rem', color: '#6b7280', fontStyle: 'italic'}}>Compatible with Cursor, Windsurf, VS Code, and any AI-powered IDE</span>
</div>
<div style={{flex: '1'}}>
<CopyPrompt
        promptType="ssoQuickstartPrompt"
       label="Copy Prompt"
        variant="secondary"
        title="Generate SSO integration code"
/>
</div>
</div>
</Card>

<Steps>

1. ### Environment Setup

    Before implementing SSO with Scalekit, prepare your development environment with the necessary credentials and SDK. Sign up and get API credentials from the Scalekit dashboard.

    <InstallSDK />

    Now you're ready to start integrating SSO into your app! Next, we'll cover how to use the SDK to authenticate users.

2. ### Authorize users

    To initiate Single Sign-On (SSO) authentication, redirect users to the Scalekit Authorization URL with the appropriate enterprise identity provider parameters.

    Construct your authorization URL with these essential parameters:

    | Parameter | Description |
    |-----------|-------------|
    | `redirect_uri` | Your application endpoint that will receive the authorization code after successful authentication. Example: `https://your-app.com/auth/callback` |
    | `client_id` | Your unique Scalekit application identifier that specifies both your app and environment (staging, production). |
    | SSO Connection identifier | Choose the appropriate identifier based on your implementation (use one). |

    <Aside type="caution" title="Check your redirect_uri is registered">
    Make sure your `redirect_uri` matches one of the **Allowed Callback URLs** you configured in your Scalekit dashboard. Scalekit uses this URL to send the authorization code back to your app after successful authentication.
    </Aside>

    **SSO connection identifiers**

    When initiating SSO authentication, you must specify which connection to use through one of these identifiers, listed in order of precedence:

    - `connection_id` (e.g., conn_124234234): Specifies a particular SSO connection with highest precedence. If valid, this connection will be used regardless of other parameters.
    - `organization_id` (e.g., org_124234234): Directs users to a specific organization's SSO. Used when no valid connection_id is provided. If an organization has multiple SSO connections, the system selects the first active one.
    - `domain` (e.g., acmecorp.com): Uses the SSO connection configured for the specified domain. Applied when neither connection_id nor organization_id are provided.
    - `login_hint` (e.g., john<span></span>@acmecorp.com): Lowest precedence. The system extracts the domain portion of the email address and uses the corresponding SSO connection.

    <Aside type="tip">
    For social login, use `provider=google` to bypass all enterprise SSO parameters and direct users straight to Google's login screen. See [Social Logins](/social-logins/quickstart/) for more information.
    </Aside>

    After selecting the appropriate parameters for your implementation needs, construct your complete authorization URL and implement a redirect to this URL when users initiate the login process.

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers wrap
    import { ScalekitClient } from '@scalekit-sdk/node';
    // Initialize the SDK client
    const scalekit = new ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>',
    );

    const options = {};

    // Option 1: Authorization URL with the organization ID
    options['organizationId'] = 'org_15421144869927830';

    // Option 2: Authorization URL with login hint
    options['connectionId'] = 'conn_15696105471768821';

    // Option 3: Authorization URL with login hint
    options['loginHint'] = 'user@example.com';

    const authorizationURL = scalekit.getAuthorizationUrl(redirectUrl, options);
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```python showLineNumbers wrap
    from scalekit import ScalekitClient, AuthorizationUrlOptions, CodeAuthenticationOptions

    # Initialize the SDK client
    scalekit = ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>'
    )

    options = AuthorizationUrlOptions()


    # Option 1: Authorization URL with the organization ID
    options.organization_id = 'org_15421144869927830'

    # Option 2: Authorization URL with login hint
    options.login_hint = 'user@example.com'

    # Option 3: Authorization URL with the connection ID
    options.connection_id = 'conn_15696105471768821'

    authorization_url = scalekit_client.get_authorization_url(
      redirect_uri=<redirect_uri>,
      options=options
    )

    # Redirect the user to this authorization URL
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers
    import (
      "github.com/scalekit/scalekit-sdk-go"
    )

    func main() {
      // Initialize the SDK client
      scalekitClient := scalekit.NewScalekitClient(
        "<SCALEKIT_ENVIRONMENT_URL>",
        "<SCALEKIT_CLIENT_ID>",
        "<SCALEKIT_CLIENT_SECRET>"
      )

      options := scalekitClient.AuthorizationUrlOptions{}


      // Option 1: Authorization URL with the organization ID
      options.OrganizationId = "org_15421144869927830"

      // Option 2: Authorization URL with the connection ID
      options.ConnectionId = "conn_15696105471768821"

      // Option 3: Authorization URL with Login Hint
      // User's email domain detects the correct enterprise SSO connection.
      options.LoginHint = "user@example.com"

      authorizationURL := scalekitClient.GetAuthorizationUrl(
        redirectUrl,
        options,
      )
      // Next step is to redirect the user to this authorization URL
    }

    // Redirect the user to this authorization URL
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java showLineNumbers
    package com.scalekit;

    import com.scalekit.ScalekitClient;
    import com.scalekit.internal.http.AuthorizationUrlOptions;

    public class Main {

      public static void main(String[] args) {
        // Initialize the SDK client
        ScalekitClient scalekitClient = new ScalekitClient(
          "<SCALEKIT_ENVIRONMENT_URL>",
          "<SCALEKIT_CLIENT_ID>",
          "<SCALEKIT_CLIENT_SECRET>"
        );
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        // Option 1: Authorization URL with the organization ID
        options.setOrganizationId("org_13388706786312310");
        // Option 2: Authorization URL with the connection ID
        options.setConnectionId("con_13388706786312310");
        // Option 3: Authorization URL with Login Hint
        // User's email domain detects the correct enterprise SSO connection.
        options.setLoginHint("user@example.com");
        try {
          String url = scalekitClient
            .authentication()
            .getAuthorizationUrl(redirectUrl, options)
            .toString();
        } catch (Exception e) {
          System.out.println(e.getMessage());
        }
      }
    }
    // Redirect the user to this authorization URL
    ```

    </TabItem>
    </Tabs>

    This redirect will send users to the Scalekit authentication flow, where they'll authenticate with their organization's identity provider before being returned to your application.

    ```sh title="Example Authorization URL"
    https://auth.scalekit.com/authorize?
      client_id=skc_122056050118122349527&
      redirect_uri=https://yourapp.com/auth/callback&
      organization_id=org_12434341
    ```

    After redirecting users to the Scalekit authorization endpoint, handle the callback at your `redirect_uri` to retrieve the user profile and complete the authentication process.

3. ### Fetch user details

    After successful SSO authentication, Scalekit redirects users to your specified redirect_uri with a temporary authorization code parameter. This code must be exchanged for the user's profile information through a secure server-side request.

    The authorization code exchange process should always be performed server-side to maintain security. This server-side request will:

    1. Validate the authorization code
    2. Return the authenticated user's profile details
    3. Establish the user's session in your application

    The following section demonstrates how to implement this exchange process to retrieve comprehensive user information and complete the authentication flow.

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers wrap title="Fetch user profile"
    // Handle oauth redirect_url, fetch code and error_description from request params
    const { code, error, error_description, idp_initiated_login, connection_id, relay_state } =
      req.query;

    if (error) {
      // Handle errors
    }

    // Recommended: Handle idp initiated login

    const result = await scalekit.authenticateWithCode(code, redirectUri);
    const userEmail = result.user.email;

    // Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```py showLineNumbers title="Fetch user profile"
    # Handle oauth redirect_url, fetch code and error_description from request params
    code = request.args.get('code')
    error = request.args.get('error')
    error_description = request.args.get('error_description')
    idp_initiated_login = request.args.get('idp_initiated_login')
    connection_id = request.args.get('connection_id')
    relay_state = request.args.get('relay_state')

    if error:
        raise Exception(error_description)

    # Recommended: Handle idp initiated login

    result = scalekit.authenticate_with_code(code, '<redirect_uri>')

    # result.user has the authenticated user's details
    user_email = result.user.email

    # Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers title="Fetch user profile"
    // Handle oauth redirect_url, fetch code and error_description from request params
    code: = r.URL.Query().Get("code")
    error: = r.URL.Query().Get("error")
    errorDescription: = r.URL.Query().Get("error_description")
    idpInitiatedLogin: = r.URL.Query().Get("idp_initiated_login")
    connectionID: = r.URL.Query().Get("connection_id")
    relayState: = r.URL.Query().Get("relay_state")

    if error != "" {
      // Handle errors
    }

    // Recommended: Handle idp initiated login

    result, err: = a.scalekit.AuthenticateWithCode(code,<redirectUrl>)

    if err != nil {
      // Handle errors
    }

    // result.User has the authenticated user's details
    userEmail: = result.User.Email

    // Next step: create a session for this user and allow access
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java showLineNumbers title="Fetch user profile" wrap
    // Handle oauth redirect_url, fetch code and error_description from request params
    String code = request.getParameter("code");
    String error = request.getParameter("error");
    String errorDescription = request.getParameter("error_description");
    String idpInitiatedLogin = request.getParameter("idp_initiated_login");
    String connectionID = request.getParameter("connection_id");
    String relayState = request.getParameter("relay_state");

    if (error != null && !error.isEmpty()) {
        // Handle errors
        return;
    }

    // Recommended: Handle idp initiated login

    try {
        AuthenticationResponse result = scalekit.authentication().authenticateWithCode(code, redirectUrl);
        String userEmail = result.getIdTokenClaims().getEmail();

        // Next step: create a session for this user and allow access
    } catch (Exception e) {
        // Handle errors
    }
    ```

    </TabItem>

    </Tabs>

    The `result` object

    ```json title="Result object"
    {
      user: {
        email: "john.doe@example.com",
        familyName: "Doe",
        givenName: "John",
        username: "john.doe@example.com",
        id: "conn_326735950921X7829;cc4aaef2-b395-4b40-81ae-b8183c1006e1"
      },
      idToken: "<USER_PROFILE_JWT>", // JWT containing user profile information
      accessToken: "<API_CALL_JWT>", // Token for API calls
      expiresIn: 899
    }
    ```

</Steps>

<Aside type="note" title="Scalekit does not store user profile information">

- The `idToken` is a JWT containing user profile information, while the `accessToken` is used for API calls.

- For security and compliance reasons, Scalekit does not store user profile information in persistent databases.

</Aside>

================
File: sso/social-logins-quickstart.mdx
================
---
title: Getting started with social connections
description: "Learn how to add social login to your B2B SaaS application using Scalekit, enabling users to authenticate with providers like Google, Microsoft, and GitHub."
sidebar:
  label: "Quickstart"
prev: false
tableOfContents: false
head:
  - tag: style
    content: |
      .sl-markdown-content h2 {
        font-size: var(--sl-text-xl);
      }
      table td:not(:last-child), table th:not(:last-child) {
        white-space: nowrap;
      }
next:
  label: "Configure Google, Microsoft and more"
  link: "/guides/integrations/social-connections/"
slug: "social-logins/quickstart"
---

import { LinkButton, Aside, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import InstallSDK from '@components/templates/_installsdk.mdx';

Single sign-on (SSO) enhances B2B SaaS application security and user experience by enabling secure authentication
through an organization's identity provider (IdP). Some organizations use social identity providers like Google,
Microsoft, GitHub, Salesforce etc.

This guide shows you how to add social login functionality to your B2B SaaS application using Scalekit. You'll learn how to enable users to authenticate with popular identity providers like Google, Microsoft, GitHub, and more through OAuth 2.0.

  ![How Scalekit works](@/assets/docs/common/social-connections/0.png)

<Steps>

1. ### Set up your environment

    Before implementing social login, ensure you have the necessary tools and access:

    - Access to your [Scalekit account](https://app.scalekit.com/ws/login) and API credentials
    - Your application's codebase for implementing and testing changes

   <InstallSDK />

    You're now ready to integrate social connections into your application! The next step covers how to use the SDK to authenticate users.

2. ### Create authorization URL

    To start the social login process, your application must redirect users to Scalekit's authorization endpoint with the appropriate social provider details.

    Construct the authorization URL using these required parameters:

    | Parameter | Description |
    | :-------- | :---------- |
    | `redirect_uri` | The URL where Scalekit sends users after successful authentication. After users complete authentication with the social provider, Scalekit redirects them to this URI with a one-time authorization `code`. You'll use this code in the next step to fetch user details. |
    | `client_id` | Your application's unique Scalekit identifier. This parameter is mandatory for all requests and uniquely identifies both your application and environment (staging, production). |
    | `provider` | Specifies which social provider to use. Set this to the unique code of your chosen provider (e.g., `google`, `microsoft`). |

    ```sh title="Example authorization URL"
    https://auth.scalekit.com/authorize?
      client_id=skc_122056050118122349527&
      redirect_uri=https://yourapp.com/auth/callback&
      provider=google
    ```

    Next, construct your authorization URL with these parameters and redirect users to this URL when they attempt to log in.

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers
    import { Scalekit } from '@scalekit-sdk/node';

    // Initialize the SDK client
    const scalekit = new Scalekit('<SCALEKIT_ENVIRONMENT_URL>', '<SCALEKIT_CLIENT_ID>', '<SCALEKIT_CLIENT_SECRET>');

    const authorizationURL = scalekit.getAuthorizationUrl(redirectUri, {
      provider: 'google',
      state: state, // optional
    });

    // Redirect the user to this authorizationURL
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```python showLineNumbers
    from scalekit import ScalekitClient, AuthorizationUrlOptions, CodeAuthenticationOptions

    # Initialize the SDK client
    scalekit_client = ScalekitClient(
      '<SCALEKIT_ENVIRONMENT_URL>',
      '<SCALEKIT_CLIENT_ID>',
      '<SCALEKIT_CLIENT_SECRET>'
    )

    options = AuthorizationUrlOptions()

    options.provider = 'google'

    authorization_url = scalekit_client.get_authorization_url(
      redirect_uri=<redirect_uri>,
      options=options
    )

    # Redirect the user to this authorization URL
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers
    import (
      "github.com/scalekit/scalekit-sdk-go"
    )

    func main() {
      scalekitClient := scalekit.NewScalekitClient(
        "<SCALEKIT_ENVIRONMENT_URL>",
        "<SCALEKIT_CLIENT_ID>",
        "<SCALEKIT_CLIENT_SECRET>"
      )

      options := scalekitClient.AuthorizationUrlOptions{}
      // Pass the social login provider details while constructing the authorization URL.
      options.Provider = "google"

      authorizationURL := scalekitClient.GetAuthorizationUrl(
        redirectUrl,
        options,
      )
      // Next step is to redirect the user to this authorization URL
    }
    ```

    </TabItem>
    <TabItem value="java" label="Java">

    ```java showLineNumbers
    package com.scalekit;

    import com.scalekit.internal.http.AuthorizationUrlOptions;

    public class Main {

      public static void main(String[] args) {
        ScalekitClient scalekitClient = new ScalekitClient(
          "<SCALEKIT_ENVIRONMENT_URL>",
          "<SCALEKIT_CLIENT_ID>",
          "<SCALEKIT_CLIENT_SECRET>"
        );
        AuthorizationUrlOptions options = new AuthorizationUrlOptions();
        options.setProvider("google");
        try {
          // Pass the social login provider details while constructing the authorization URL.
          String url = scalekitClient.authentication().getAuthorizationUrl(redirectUrl, options).toString();
        } catch (Exception e) {
          System.out.println(e.getMessage());
        }
      }
    }
    ```

    </TabItem>
    </Tabs>

    After users complete authentication, Scalekit redirects them to your `redirect_uri` with an authorization code. Handle this callback to complete the authentication process.

3. ### Retrieve user information

    After successful social authentication, Scalekit redirects users to your `redirect_uri` with a unique authorization `code`. Exchange this code for user profile details on your server side.

    Here's how to convert the authorization code into user data:

    <Tabs syncKey="tech-stack">
    <TabItem value="nodejs" label="Node.js">

    ```javascript showLineNumbers
    const { code, state } = req.query;

    if (error) {
      // Handle errors
    }

    const res = await scalekit.authenticateWithCode(code, redirectUri);

    // res.user has the authenticated user's details
    const userEmail = res.user.email;

    // Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="py" label="Python">

    ```python showLineNumbers
    code = request.args.get('code')
    error = request.args.get('error')
    error_description = request.args.get('error_description')

    if error:
        raise Exception(error_description)

    result = scalekit_client.authenticate_with_code(
      code,
      <redirect_uri>
    )

    # result.user has the authenticated user's details
    user_email = result.user.email

    # Next step: create a session for this user and allow access
    ```

    </TabItem>
    <TabItem value="golang" label="Go">

    ```go showLineNumbers
    code := r.URL.Query().Get("code")
    error := r.URL.Query().Get("error")
    errorDescription := r.URL.Query().Get("error_description")

    if error != "" {
      // Handle errors and exit
    }

    res, err := sc.AuthenticateWithCode(code, redirectUrl)
    if err != nil {
      // Handle errors and exit
    }

    // res.User has the authenticated user's details
    userEmail := res.User.Email

    // Next step: create a session for this user and allow access
    ```

    </TabItem>

    <TabItem value="java" label="Java">

    ```java showLineNumbers
    String code = request.getParameter("code");
    String error = request.getParameter("error");
    String errorDescription = request.getParameter("error_description");
    if (error != null && !error.isEmpty()) {
      // Handle errors
      return;
    }
    try {
      AuthenticationResponse res = scalekitClient.authentication().authenticateWithCode(code, redirectUrl);
      // res.getIdTokenClaims() has the authenticated user's details
      String userEmail = res.getIdTokenClaims().getEmail();

    } catch (Exception e) {
      // Handle errors
    }

    // Next step: create a session for this user and allow access
    ```

    </TabItem>
    </Tabs>

</Steps>

## Next steps

You've successfully implemented social login functionality in your application. Your users can now authenticate using their preferred social identity providers.

<Aside type="note" title="Important notes about user data">

- The `idToken` is a JWT containing user profile information, while the `accessToken` is used for API calls
- For security and compliance reasons, Scalekit does not store user profile information in persistent databases
- Always validate the authorization code on your server side before creating user sessions

</Aside>

================
File: index.mdx
================
---
title: "Welcome to Scalekit Docs 👋"
description: "Fast, secure B2B authentication with SSO, SCIM, passwordless, APIs, SDKs, and guides to power your apps—no engineering overhead"
template: splash
tableOfContents: false
editUrl: false
topic: full-stack-auth
head:
  - tag: style
    content: |
      :root {
        --sl-content-width: 55rem !important;
      }
      .hero {
        padding: 2rem 0;
      }
      .hero-content {
        margin: 0 20% 0 auto;
        text-align: left;
      }
      .card-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.5rem;
        margin-top: 1rem;
        align-items: stretch;
      }
      .card-grid-3 {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin: 1rem 0;
        align-items: stretch;
      }
      .card-grid > *, .card-grid-3 > * {
        margin-top: 0 !important;
      }

      .card {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      .card-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .featured-card {
        border: 1.5px solid var(--sl-color-green) !important;
        border-radius: 0.6rem;
      }
      .featured-card .sl-flex {
        border-radius: 0.5rem;
      }
      .featured-card .sl-flex * {
        background: transparent !important;
      }
      .two-column-layout {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 3rem;
        margin-top: 2rem;
        align-items: stretch;
      }
      .auth-modules-section {
        flex: 1;
        margin-top: 0;
      }
      .full-stack-section {
        margin-top: 0;
        flex: 1;
        padding-left: 2rem;
        border-left: 1.5px solid var(--sl-color-green);
        background: var(--sl-color-bg-sidebar);
      }
      .full-stack-section h3 {
        margin-bottom: 1rem !important;
        font-size: 1.5rem;
      }
      .full-stack-section p {
        margin-bottom: 1.5rem;
      }
      @media (max-width: 768px) {
        .two-column-layout {
          grid-template-columns: 1fr;
          gap: 2rem;
        }
      }
      .sl-link-button {
        &.minimal {
          padding-inline: 0rem;
          padding-bottom: 0rem
        }
      }
      [data-theme='light'] .card {
        background-color: white !important;
      }

      /* Green accent border on hover for sl-link-card items */
      .sl-link-card {
        transition: border-color 0.2s ease-in-out;
      }

      .sl-link-card:hover {
        border-color: var(--sl-color-green) !important;
      }
  - tag: script
    content: |
      // Collapse Starlight’s sidebar groups on the first page load.
      (function () {
        // Guard against SSR.
        if (typeof window === 'undefined') return;

        // Ensure the script only runs once per session.
        if (window.__sidebarCollapsed) return;
        window.__sidebarCollapsed = true;

        function collapse() {
          const groups = document.querySelectorAll('#starlight__sidebar details[open]');
          groups.forEach((d) => d.removeAttribute('open'));
        }

        // If the DOM is still loading, wait for it to finish.
        if (document.readyState === 'loading') {
          window.addEventListener('DOMContentLoaded', collapse, { once: true });
        } else {
          // DOM is already ready – collapse immediately.
          collapse();
        }
      })();
---

import {
  Card,
  CardGrid,
  LinkButton,
  LinkCard,
  Icon,
} from "@astrojs/starlight/components";
import SimpleList from "@components/ui/SimpleList.astro";
import {
  ShowcaseText,
  ShowcaseCTA,
  ShowcaseYouTube,
} from "starlight-showcases";
import Footer from "@/components/templates/_footer.mdx";
import CheckItem from "@components/ui/CheckItem.astro";

<div class="hero-content">

Scalekit helps developers handle authentication across agents, users, and APIs with drop-in modules.
Explore our API reference, SDKs, quickstarts, and sample apps to get started quickly.


<LinkButton href="/fsa/quickstart" variant="primary" icon='rocket'>
  Get started
</LinkButton>
</div>

  <div class="auth-modules-section" id="auth-modules">

    <h1 style={{ textAlign: 'left', marginTop: '2rem', marginBottom: '0rem' }}>Drop-in auth modules for agents, users, and APIs</h1>
   <p style={{ textAlign: 'left', marginBottom: '2rem', marginTop: '0.3rem' }}>Bring your user management or use Scalekit's full-stack auth</p>

      <h3 style={{ marginTop: '0.2rem' }}>Secure AI agents and APIs</h3>
      <div class="card-grid-3">

      <LinkCard title="Add MCP Auth" description=' Ship MCP servers with OAuth 2.1 built in — including DCR, PKCE, and scoped token issuance' href="/guides/mcp/overview/" />

     <LinkCard title="Add API Auth" description='Protect your APIs with user- and org-scoped tokens using secure OAuth flows' href="/m2m/quickstart/" />

      </div>
    </div>

     <br />
    <div>
      <h3>Win enterprise customers</h3>
      <div class="card-grid-3">
        <LinkCard title="Add enterprise SSO" description='Support both SAML and OIDC flows for any IdPs your customers bring' href="/sso/quickstart/" />
        <LinkCard title="Enable SCIM provisioning" description='Automatically sync users, roles, and access controls from any customer directory' href="/directory/scim/quickstart/" />
      </div>
    </div>


    <div>
    <br />
      <div>
      <h3>Modernize your login flows</h3>
      <div class="card-grid-3">
     <LinkCard title="Go passwordless" description='Offer modern auth methods like magic links, passkeys, OTPs, and MFA' href="/guides/passwordless/quickstart/" />

      <LinkCard title="Add social login" description='Let users sign in with their existing accounts — Google, GitHub, Microsoft, and more' href="/social-logins/quickstart/" />
      </div>
    </div>

   <h1 style={{ textAlign: 'left', marginTop: '3rem', marginBottom: '0rem' }}>Or let us handle your complete auth stack</h1>
    <div>
      <div>

      <p style={{ marginTop: '0rem' }}>Power every customer’s unique setup:</p>
      <ul style={{ marginTop: '0rem' }}>
        <li>Native multi-tenant auth with org hierarchies and automatic org detection</li>
        <li>Manage orgs, users,and role-based permissions</li>
        <li>Enable magic links, Email OTP, social login, and passkeys</li>
        <li>Deploy ready-to-use login pages, org management, and user portals with our UI components</li>
      </ul>
      <LinkButton href="/fsa/quickstart/" variant="primary" icon='right-arrow'>Full Stack Auth quickstart</LinkButton>
    </div>
    </div>

  </div>

# Deploy faster with our dev tool kit

<div class="card-grid">

<Card title="SDKs & APIs">
  <SimpleList>
    <CheckItem iconName="seti:webpack">
      SDKs available for [Node.js](https://github.com/scalekit-inc/scalekit-sdk-node), [Go](https://github.com/scalekit-inc/scalekit-sdk-go), [Python](https://github.com/scalekit-inc/scalekit-sdk-python), and [Java](https://github.com/scalekit-inc/scalekit-sdk-java)
    </CheckItem>
    <CheckItem iconName="seti:pipeline">
      Browse our [API reference](https://docs.scalekit.com/apis/) for all endpoints
    </CheckItem>
  </SimpleList>
</Card>

<Card title="Build faster">
  <SimpleList>
    <CheckItem iconName="github">
      <a href="https://github.com/orgs/scalekit-developers/repositories">Try our sample apps</a> to get started quickly
    </CheckItem>
    <CheckItem iconName="document">
      <a href="https://github.com/scalekit-developers/api-collections">Download Postman collections</a> to play with APIs
    </CheckItem>
  </SimpleList>
</Card>

</div>

<Footer />



================================================================
Instruction
================================================================
# Scalekit Documentation Instructions

This repository contains the Scalekit developer documentation. When analyzing this documentation, please follow these guidelines:

## Focus Areas
1. **Full Stack Auth (FSA)** - Complete authentication solution documentation
2. **SSO Integration** - Single Sign-On setup and configuration guides
3. **Directory/SCIM** - User provisioning and directory synchronization
4. **M2M Authentication** - Machine-to-machine authentication patterns
5. **API References** - Technical API documentation and endpoints

## Documentation Structure
- Pay special attention to the `fsa/` directory for core authentication features
- Review `sso/` directory for SSO integration patterns
- Check `directory/` for SCIM and user provisioning guides
- Examine `guides/` for implementation examples and best practices
- Reference `reference/` for technical specifications and API details

## Key Considerations
- This is developer documentation for a B2B authentication platform
- Focus on practical implementation guidance and code examples
- Pay attention to security best practices mentioned throughout
- Consider the target audience: developers integrating authentication into their applications
- Look for configuration examples and setup instructions

## Important Sections
- Quickstart guides for getting started quickly
- Integration guides for specific authentication providers
- Reference documentation for API endpoints and SDKs
- Troubleshooting and error handling information


================================================================
End of Codebase
================================================================
